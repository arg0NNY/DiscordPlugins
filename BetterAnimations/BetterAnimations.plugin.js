/**
 * @name BetterAnimations
 * @description 🌊 Discord Animations Client Mod & Framework
 * @author arg0NNY
 * @authorLink https://github.com/arg0NNY/DiscordPlugins
 * @invite M8DBtcZjXD
 * @donate https://boosty.to/arg0nny/donate
 * @website https://docs.betteranimations.net
 * @source https://github.com/arg0NNY/BetterAnimations
 * @version 2.0.2
 */

/* ### CONFIG START ### */
const config = {
  "info": {
    "name": "BetterAnimations",
    "version": "2.0.2",
    "description": "🌊 Discord Animations Client Mod & Framework"
  },
  "changelog": [
    {
      "type": "fixed",
      "title": "Fixes",
      "items": [
        "Fixed the plugin failing to load."
      ]
    }
  ]
}
/* ### CONFIG END ### */

var BetterAnimations = function(require$$0$1, EventEmitter, classNames, fs, path, reactDom) {
  "use strict";
  const name$1 = "BetterAnimations";
  const author = "arg0NNY";
  const invite = "M8DBtcZjXD";
  const config = {
    name: name$1,
    author,
    invite
  };
  const bdApi = new BdApi(config.name);
  const {
    Patcher: BDPatcher,
    Webpack,
    Utils,
    DOM,
    Data: BDData,
    Plugins,
    UI,
    Net,
    ContextMenu: ContextMenu$1,
    Themes,
    version: bdVersion
  } = bdApi;
  const LogTypes = {
    err: "error",
    error: "error",
    dbg: "debug",
    debug: "debug",
    log: "log",
    warn: "warn",
    info: "info",
    group: "group",
    groupCollapsed: "groupCollapsed"
  };
  class Logger {
    static stacktrace(module2, message, error2) {
      console.error(`%c[${config.name}] %c[${module2}]%c ${message}

%c`, "color: #3E82E5; font-weight: 700;", "color: #3a71c1; font-weight: 700;", "color: red; font-weight: 700;", "color: red;", error2);
    }
    static err(module2, ...message) {
      Logger._log(module2, message, "error");
    }
    static error(module2, ...message) {
      Logger._log(module2, message, "error");
    }
    static warn(module2, ...message) {
      Logger._log(module2, message, "warn");
    }
    static info(module2, ...message) {
      Logger._log(module2, message, "info");
    }
    static debug(module2, ...message) {
      Logger._log(module2, message, "debug");
    }
    static log(module2, ...message) {
      Logger._log(module2, message);
    }
    static group(module2, ...message) {
      Logger._log(module2, message, "group");
    }
    static groupCollapsed(module2, ...message) {
      Logger._log(module2, message, "groupCollapsed");
    }
    static groupEnd() {
      console.groupEnd();
    }
    static stylized(module2, type, message, ...entries) {
      Logger._log(module2, entries, type, message);
    }
    static _log(module2, message, type = "log", after = "") {
      type = Logger.parseType(type);
      if (!Array.isArray(message)) message = [message];
      console[type](`%c[${config.name}]%c [${module2}]%c` + (after ? ` ${after}` : ""), "color: #3E82E5; font-weight: 700;", "color: #3a71c1;", "", ...message);
    }
    static parseType(type) {
      return LogTypes[type] || "log";
    }
  }
  let ErrorManager$1 = class ErrorManager {
    get name() {
      return "ErrorManager";
    }
    constructor() {
      this.registerInternalError = (error2) => this.registerError(error2);
      this.registerAddonError = (error2) => this.registerError(error2);
      this.registerAnimationError = (error2) => this.registerError(error2);
    }
    registerError(error2) {
      Logger.error(this.name, error2);
    }
  };
  new ErrorManager$1();
  function mangled(module2 = {}, map = {}) {
    const mangled2 = {};
    const values = Object.values(module2);
    for (const key2 in map) {
      mangled2[key2] = values.find(map[key2]);
    }
    return mangled2;
  }
  function keyed(module2 = {}, filter = () => false) {
    const key2 = Object.keys(module2).find((key3) => filter(module2[key3]));
    return [key2 && module2, key2];
  }
  async function lazyKeyed(modulePromise, filter) {
    return keyed(await modulePromise, filter);
  }
  function unkeyed(keyed2) {
    return keyed2[0][keyed2[1]];
  }
  function unkeyedFn(keyedComponent) {
    return (...args) => unkeyed(keyedComponent)(...args);
  }
  const { Filters } = Webpack;
  const [
    Text$1,
    Heading,
    ModalScrimModule,
    Clickable,
    Switch$1,
    CheckboxModule,
    FormTitle,
    FormTitleTags,
    FormText,
    FormSection,
    Breadcrumbs,
    RadioGroupModule,
    FormSwitch,
    FormItem,
    Slider$1,
    ReferencePositionLayer,
    SearchableSelect,
    TextBadge,
    SearchBar,
    Paginator,
    Spinner,
    Popout,
    Routes,
    StaticChannelRoute,
    useStateFromStores,
    BasePopout,
    SpringTransitionPhases,
    Button$1,
    TextButton,
    ButtonGroup$1,
    InviteStates,
    TextInput,
    AppPanels,
    GuildActionRow,
    Message$1,
    ChannelTextArea,
    ExpressionPicker,
    ChannelTextAreaButtons,
    ChannelAppLauncher,
    AppLauncherPopup,
    GuildIcon,
    Timestamp,
    getThemeClass,
    CSSTransition,
    TransitionGroup,
    ChannelMessageList,
    ChannelView,
    MessageDivider,
    GuildChannelRouteParams,
    handleClick,
    Timeout,
    GatewaySocket,
    { Anchor } = {},
    Dispatcher,
    Transition,
    Flux,
    App,
    Flex$1,
    { defaultRules: Parser } = {},
    InviteEmbed,
    InviteActions,
    { ImpressionNames } = {},
    { colors } = {},
    humanize,
    useListNavigator,
    ThemeStore,
    ChannelStore,
    SortedGuildStore,
    PrivateChannelSortStore,
    LayerStore$1,
    InviteStore,
    SelectedGuildStore,
    SelectedChannelStore,
    GuildStore,
    ModalActionsModule,
    TooltipModule,
    ListRawModule,
    ToastStoreModule,
    ToastModule,
    AppViewModule,
    RouterModule,
    ContextMenuModule,
    MenuSubmenuItemModule,
    MenuSubmenuListItemModule,
    PopoutCSSAnimatorModule,
    AppLayerModule,
    ModalsModule,
    LayersModule,
    GuildChannelListModule,
    ChannelSectionStore,
    ChatSidebarModule,
    VoiceChannelViewModule,
    CallChatSidebarModule,
    SelectModule,
    LayerActionsModule,
    AlertModule,
    UserSettingsModal,
    ModalModule,
    MenuItemModule,
    ChannelItemModule,
    VoiceChannelItemModule,
    StageVoiceChannelItemModule,
    AppContextModule,
    ExpressionPickerStoreModule,
    ProfileEffectsModule,
    EmojiModule,
    UseIsVisibleModule,
    RootElementContextModule,
    ListNavigatorModule,
    FocusLockModule,
    ManaModalRootModule,
    BasePopoverModule,
    ChannelThreadList,
    matchSorter,
    CopiableField
  ] = Webpack.getBulk(
    // Text
    {
      filter: (m) => Filters.byStrings("WebkitLineClamp", "data-text-variant")(m?.render),
      searchExports: true
    },
    // Heading
    {
      filter: (m) => Filters.byStrings("variant", "data-excessive-heading-level")(m?.render),
      searchExports: true
    },
    // ModalScrimModule
    {
      filter: Filters.bySource("scrim", '"lightbox"')
    },
    // Clickable
    {
      filter: Filters.byPrototypeKeys("renderInner", "renderNonInteractive"),
      searchExports: true
    },
    // Switch
    {
      filter: Filters.byStrings("checkbox", "animated.rect"),
      searchExports: true
    },
    // CheckboxModule
    {
      filter: Filters.bySource("Checkbox:", "is not a valid hex color")
    },
    // FormTitle
    {
      filter: Filters.byStrings("defaultMargin", "errorMessage"),
      searchExports: true
    },
    // FormTitleTags
    {
      filter: Filters.byKeys("H1", "LABEL", "LEGEND"),
      searchExports: true
    },
    // FormText
    {
      filter: (m) => Filters.byKeys("DESCRIPTION", "ERROR")(m?.Types),
      searchExports: true
    },
    // FormSection
    {
      filter: (m) => Filters.byStrings("titleId", "sectionTitle")(m?.render),
      searchExports: true
    },
    // Breadcrumbs
    {
      filter: (m) => Filters.byStrings("renderBreadcrumb")(m?.prototype?.render),
      searchExports: true
    },
    // RadioGroupModule
    {
      filter: Filters.bySource('"radiogroup"', "getFocusableElements")
    },
    // FormSwitch
    {
      filter: Filters.byStrings("labelRow", "checked"),
      searchExports: true
    },
    // FormItem
    {
      filter: (m) => Filters.byStrings("titleId", "errorId", "setIsFocused")(m?.render),
      searchExports: true
    },
    // Slider
    {
      filter: (m) => Filters.byKeys("stickToMarkers", "initialValue")(m?.defaultProps),
      searchExports: true
    },
    // ReferencePositionLayer
    {
      filter: Filters.byPrototypeKeys("getHorizontalAlignmentStyle", "nudgeLeftAlignment"),
      searchExports: true
    },
    // SearchableSelect
    {
      filter: (m) => Filters.byStrings("searchable", "select")(m?.render),
      searchExports: true
    },
    // TextBadge
    {
      filter: Filters.byStrings("textBadge", "STATUS_DANGER"),
      searchExports: true
    },
    // SearchBar
    {
      filter: (m) => Filters.byKeys("isLoading", "size")(m?.defaultProps) && Filters.byPrototypeKeys("blur", "focus")(m),
      searchExports: true
    },
    // Paginator
    {
      filter: Filters.byStrings("pageControlContainer", "endButtonInner"),
      searchExports: true
    },
    // Spinner
    {
      filter: (m) => Filters.byKeys("WANDERING_CUBES")(m?.Type),
      searchExports: true
    },
    // Popout
    {
      filter: (m) => Filters.byKeys("Animation")(m) && Filters.byStrings("renderPopout")(m?.prototype?.render),
      searchExports: true
    },
    // Routes
    {
      filter: Filters.byKeys("CHANNEL_THREAD_VIEW", "GUILD_DISCOVERY"),
      searchExports: true
    },
    // StaticChannelRoute
    {
      filter: Filters.byKeys("ROLE_SUBSCRIPTIONS", "CHANNEL_BROWSER"),
      searchExports: true
    },
    // useStateFromStores
    {
      filter: Filters.byStrings("useStateFromStores"),
      searchExports: true
    },
    // BasePopout
    {
      filter: (m) => m?.defaultProps?.loadingComponent,
      searchExports: true
    },
    // SpringTransitionPhases
    {
      filter: Filters.byKeys("ENTER", "LEAVE"),
      searchExports: true
    },
    // Button
    {
      filter: Filters.byStrings("button", "hasText", "expressiveWrapper"),
      searchExports: true
    },
    // TextButton
    {
      filter: Filters.byStrings("textButton", "textVariant"),
      searchExports: true
    },
    // ButtonGroup
    {
      filter: Filters.byStrings("fullWidth", "wrap", '"horizontal"'),
      searchExports: true
    },
    // InviteStates
    {
      filter: Filters.byKeys("APP_NOT_OPENED", "RESOLVING"),
      searchExports: true
    },
    // TextInput
    {
      filter: Filters.byStrings("inputWrapper", "prefixElement"),
      searchExports: true
    },
    // AppPanels
    {
      filter: (m) => Filters.byStrings("panels", "ACCOUNT_PANEL")(m?.type),
      searchExports: true
    },
    // GuildActionRow
    {
      filter: Filters.byKeys("GUILD_ROLE_SUBSCRIPTIONS", "CHANNELS_AND_ROLES"),
      searchExports: true
    },
    // Message
    {
      filter: (m) => Filters.byStrings("must not be a thread starter message")(m?.type),
      searchExports: true
    },
    // ChannelTextArea
    {
      filter: (m) => Filters.byStrings("channelTextArea", "markdown")(m?.type?.render)
    },
    // ExpressionPicker
    {
      filter: (m) => Filters.byStrings("EXPRESSION_PICKER", "positionContainer")(m?.type),
      searchExports: true
    },
    // ChannelTextAreaButtons
    {
      filter: (m) => Filters.byStrings("buttons", "sticker", "gif")(m?.type),
      searchExports: true
    },
    // ChannelAppLauncher
    {
      filter: (m) => Filters.byStrings("channelAppLauncher")(m?.type),
      searchExports: true
    },
    // AppLauncherPopup
    {
      filter: (m) => Filters.byStrings("positionLayer", '"positionTargetRef"')(m?.type),
      searchExports: true
    },
    // GuildIcon
    {
      filter: (m) => Filters.byKeys("badgeStrokeColor", "animate")(m?.defaultProps),
      searchExports: true
    },
    // Timestamp
    {
      filter: (m) => Filters.byStrings("timestamp", "timestampTooltip")(m?.type),
      searchExports: true
    },
    // getThemeClass
    {
      filter: Filters.byStrings('" theme-"'),
      searchExports: true
    },
    // CSSTransition
    {
      filter: (m) => m?.defaultProps?.classNames === ""
    },
    // TransitionGroup
    {
      filter: (m) => Filters.byPrototypeKeys("handleExited")(m) && !m.childContextTypes,
      searchExports: true
    },
    // ChannelMessageList
    {
      filter: (m) => Filters.byStrings("channel", "messageDisplayCompact")(m?.type)
    },
    // ChannelView
    {
      filter: (m) => Filters.byStrings("providedChannel")(m?.type)
    },
    // MessageDivider
    {
      filter: (m) => Filters.byStrings("divider", "unreadPill")(m?.render)
    },
    // GuildChannelRouteParams
    {
      filter: (m) => Filters.byStrings("escapeRegExp")(m?.guildId),
      searchExports: true
    },
    // handleClick
    {
      filter: Filters.byStrings("sanitizeUrl", "shouldConfirm"),
      searchExports: true
    },
    // Timeout
    {
      filter: (m) => Filters.byPrototypeKeys("isStarted", "start", "stop")(m) && Filters.byStrings("setTimeout")(m),
      searchExports: true
    },
    // GatewaySocket
    {
      filter: (m) => m?.dispatcher?.scheduler,
      searchExports: true
    },
    // Anchor
    {
      filter: Filters.byKeys("Anchor")
    },
    // Dispatcher
    {
      filter: Filters.byKeys("dispatch", "subscribe")
    },
    // Transition
    {
      filter: Filters.byKeys("ENTERING", "EXITING", "contextType")
    },
    // Flux
    {
      filter: Filters.byKeys("Store", "connectStores")
    },
    // App
    {
      filter: Filters.byKeys("setEnableHardwareAcceleration", "releaseChannel")
    },
    // Flex
    {
      filter: Filters.byKeys("Direction", "Justify", "Child")
    },
    // Parser
    {
      filter: Filters.byKeys("defaultRules", "parse")
    },
    // InviteEmbed
    {
      filter: Filters.byStrings("Invite Button Embed", "getInvite")
    },
    // InviteActions
    {
      filter: Filters.byKeys("resolveInvite", "createInvite")
    },
    // ImpressionNames
    {
      filter: Filters.byKeys("ImpressionNames")
    },
    // colors
    {
      filter: Filters.byKeys("colors", "modules")
    },
    // humanize
    {
      filter: Filters.byKeys("humanize", "filesize")
    },
    // useListNavigator
    {
      filter: Filters.byStrings("focusLastVisibleItem", '"focus"')
    },
    // ThemeStore
    {
      filter: Filters.byStoreName("ThemeStore")
    },
    // ChannelStore
    {
      filter: Filters.byStoreName("ChannelStore")
    },
    // SortedGuildStore
    {
      filter: Filters.byStoreName("SortedGuildStore")
    },
    // PrivateChannelSortStore
    {
      filter: Filters.byStoreName("PrivateChannelSortStore")
    },
    // LayerStore
    {
      filter: Filters.byStoreName("LayerStore")
    },
    // InviteStore
    {
      filter: Filters.byStoreName("InviteStore")
    },
    // SelectedGuildStore
    {
      filter: Filters.byStoreName("SelectedGuildStore")
    },
    // SelectedChannelStore
    {
      filter: Filters.byStoreName("SelectedChannelStore")
    },
    // GuildStore
    {
      filter: Filters.byStoreName("GuildStore")
    },
    // ModalActionsModule
    {
      filter: Filters.bySource("POPOUT", "OVERLAY", "modalKey")
    },
    // TooltipModule
    {
      filter: Filters.bySource("renderTooltip", "tooltipPointer")
    },
    // ListRawModule
    {
      filter: Filters.bySource("thin", "none", "fade", "ResizeObserver"),
      raw: true
    },
    // ToastStoreModule
    {
      filter: Filters.bySource("currentToast", "queuedToasts")
    },
    // ToastModule
    {
      filter: Filters.bySource("toast", "position", "STATUS_DANGER")
    },
    // AppViewModule
    {
      filter: Filters.bySource("CHANNEL_THREAD_VIEW", "GUILD_DISCOVERY", "data-fullscreen")
    },
    // RouterModule
    {
      filter: Filters.bySource("props.computedMatch", "isExact")
    },
    // ContextMenuModule
    {
      filter: Filters.bySource("getContextMenu", "renderWindow")
    },
    // MenuSubmenuItemModule
    {
      filter: Filters.bySource("subMenuClassName", "submenuPaddingContainer")
    },
    // MenuSubmenuListItemModule
    {
      filter: Filters.bySource("menuSubmenuProps", "listClassName", "submenuPaddingContainer")
    },
    // PopoutCSSAnimatorModule
    {
      filter: Filters.bySource("animatorTop", "TRANSLATE")
    },
    // AppLayerModule
    {
      filter: Filters.bySource("layerContext", '"App"')
    },
    // ModalsModule
    {
      filter: Filters.bySource("modalKey", '"layer-"')
    },
    // LayersModule
    {
      filter: Filters.bySource("getLayers", "hasFullScreenLayer")
    },
    // GuildChannelListModule
    {
      filter: Filters.bySource("GUILD_CHANNEL_LIST", "favorites-channel-list")
    },
    // ChannelSectionStore
    {
      filter: Filters.byStoreName("ChannelSectionStore")
    },
    // ChatSidebarModule
    {
      filter: Filters.bySource("sidebarType", "postSidebarWidth")
    },
    // VoiceChannelViewModule
    {
      filter: Filters.bySource("shouldUseVoiceEffectsActionBar")
    },
    // CallChatSidebarModule
    {
      filter: Filters.bySource("CallChatSidebar", "chatInputType")
    },
    // SelectModule
    {
      filter: Filters.bySource("select", "newValues")
    },
    // LayerActionsModule
    {
      filter: Filters.bySource('"LAYER_PUSH"', '"LAYER_POP_ALL"')
    },
    // AlertModule
    {
      filter: Filters.bySource("messageType", "iconDiv")
    },
    // UserSettingsModal
    {
      filter: Filters.byKeys("open", "setSection", "updateAccount")
    },
    // ModalModule
    {
      filter: Filters.bySource("MODAL", "rootWithShadow")
    },
    // MenuItemModule
    {
      filter: Filters.bySource("dontCloseOnActionIfHoldingShiftKey", "data-menu-item")
    },
    // ChannelItemModule
    {
      filter: Filters.bySource("shouldIndicateNewChannel", "MANAGE_CHANNELS")
    },
    // VoiceChannelItemModule
    {
      filter: Filters.bySource("isFavoriteSuggestion", "PLAYING", "MANAGE_CHANNELS")
    },
    // StageVoiceChannelItemModule
    {
      filter: Filters.bySource("getStageInstanceByChannel", "isFavoriteSuggestion", "MANAGE_CHANNELS")
    },
    // AppContextModule
    {
      filter: Filters.bySource("renderWindow", "ownerDocument.defaultView")
    },
    // ExpressionPickerStoreModule
    {
      filter: Filters.bySource("expression-picker-last-active-view")
    },
    // ProfileEffectsModule
    {
      filter: Filters.bySource("profileEffectConfig", "useReducedMotion")
    },
    // EmojiModule
    {
      filter: Filters.bySource('"Unknown Src for Emoji"')
    },
    // UseIsVisibleModule
    {
      filter: Filters.bySource("isIntersecting", "threshold:1")
    },
    // RootElementContextModule
    {
      filter: Filters.bySource("useRootElementContext", "createContext")
    },
    // ListNavigatorModule
    {
      filter: Filters.bySource("NO_LIST", "listitem")
    },
    // FocusLockModule
    {
      filter: Filters.bySource("disableReturnRef", '"app-mount"')
    },
    // ManaModalRootModule
    {
      filter: Filters.bySource("MODAL", '"padding-size-"')
    },
    // BasePopoverModule
    {
      filter: Filters.bySource("popoverGradientWrapper", "spacing")
    },
    // ChannelThreadList
    {
      filter: (m) => Filters.byStrings("sortedThreadIds", "spineBorder")(m?.type),
      searchExports: true
    },
    // matchSorter
    {
      filter: (m) => Filters.byKeys("MATCHES", "STARTS_WITH")(m?.rankings),
      searchExports: true
    },
    // CopiableField
    {
      filter: Filters.byStrings("copyValue", "TEXT_COPIED"),
      searchExports: true
    }
  );
  const { RadioGroup } = mangled(RadioGroupModule, {
    RadioGroup: Filters.byStrings("container", "labelledBy")
  });
  const ModalScrim = Object.values(ModalScrimModule ?? {}).find((m) => m?.render);
  const { Checkbox, CheckboxTypes } = mangled(CheckboxModule, {
    Checkbox: Filters.byStrings("checkboxWrapper"),
    CheckboxTypes: Filters.byKeys("INVERTED")
  });
  const { useModalsStore, useIsModalAtTop, ...ModalActions } = mangled(ModalActionsModule, {
    openModal: Filters.byStrings("onCloseRequest", "onCloseCallback", "stackingBehavior"),
    closeModal: Filters.byStrings("onCloseCallback()", "filter"),
    closeAllModals: Filters.byStrings(".getState();for"),
    useModalsStore: Filters.byKeys("setState"),
    useIsModalAtTop: Filters.byStrings("popout:", ".at(-1)")
  });
  const { Tooltip: Tooltip$1, TooltipLayer } = mangled(TooltipModule, {
    Tooltip: Filters.byPrototypeKeys("renderTooltip"),
    TooltipLayer: Filters.byStrings("tooltipPointer")
  });
  const ListThin = (() => {
    if (!ListRawModule) return;
    const { id, exports: exports2 } = ListRawModule;
    const source = Webpack.modules[id].toString();
    return exports2[source.match(new RegExp(`(\\w+):\\(\\)=>${source.match(/let (\w+)=/)[1]}`))[1]];
  })();
  const { showToast, useToastStore } = mangled(ToastStoreModule, {
    showToast: Filters.byStrings("currentToastMap.has"),
    useToastStore: Filters.byKeys("setState")
  });
  const popToastKeyed = keyed(ToastStoreModule, Filters.byStrings(".delete"));
  const popToast = unkeyedFn(popToastKeyed);
  const { Toast: Toast$1, createToast } = mangled(ToastModule, {
    Toast: Filters.byKeys("type"),
    createToast: Filters.byStrings("type", "position")
  });
  const AppViewKeyed = keyed(AppViewModule, Filters.byStrings("CHANNEL_THREAD_VIEW", "GUILD_DISCOVERY"));
  const Router = mangled(RouterModule, {
    Router: (m) => m?.computeRootMatch,
    Route: (m) => Filters.byStrings("props.computedMatch", "props.path")(m?.prototype?.render),
    Switch: (m) => Filters.byStrings("props.location", "cloneElement")(m?.prototype?.render),
    matchPath: Filters.byStrings("strict", "isExact"),
    useLocation: Filters.byStrings(").location"),
    useParams: Filters.byStrings(".match", ".params")
  });
  const TransitionGroupContext = Transition && new Transition({ children: require$$0$1.createElement("div") }).render().type;
  const ContextMenuKeyed = keyed(ContextMenuModule, Filters.byStrings("getContextMenu", "isOpen"));
  const MenuSubmenuItemKeyed = keyed(MenuSubmenuItemModule, Filters.byStrings("subMenuClassName", "submenuPaddingContainer"));
  const MenuSubmenuListItemKeyed = keyed(MenuSubmenuListItemModule, Filters.byStrings("menuSubmenuProps", "listClassName", "submenuPaddingContainer"));
  const PopoutCSSAnimatorKeyed = keyed(PopoutCSSAnimatorModule, (m) => Filters.byKeys("TRANSLATE", "SCALE")(m?.Types));
  const { AppLayer, appLayerContext } = mangled(AppLayerModule, {
    AppLayer: Filters.byDisplayName("AppLayer"),
    appLayerContext: (m) => m?.Provider
  });
  const ModalsKeyed = keyed(ModalsModule, Filters.byStrings("modalKey", '"layer-"'));
  const LayersKeyed = keyed(LayersModule, Filters.byStrings("hasFullScreenLayer"));
  const GuildChannelListKeyed = keyed(GuildChannelListModule, Filters.byStrings("getGuild", "guildId"));
  const ChatSidebarKeyed = keyed(ChatSidebarModule, Filters.byStrings("chatLayerWrapper"));
  const VoiceChannelViewKeyed = keyed(VoiceChannelViewModule, Filters.byStrings("shouldUseVoiceEffectsActionBar"));
  const CallChatSidebarKeyed = keyed(CallChatSidebarModule, Filters.byStrings("CallChatSidebar", "chatInputType"));
  const SelectKeyed = keyed(SelectModule, Filters.byStrings("listbox", "renderPopout", "closeOnSelect"));
  const SingleSelectKeyed = keyed(SelectModule, (m) => Filters.byStrings("value", "onChange")(m) && !Filters.byStrings("isSelected")(m));
  const SingleSelect = unkeyedFn(SingleSelectKeyed);
  const LayerActions = mangled(LayerActionsModule, {
    pushLayer: Filters.byStrings('"LAYER_PUSH"'),
    popLayer: Filters.byStrings('"LAYER_POP"'),
    popAllLayers: Filters.byStrings('"LAYER_POP_ALL"')
  });
  const { Alert, AlertTypes } = mangled(AlertModule, {
    Alert: Filters.byStrings("messageType", "iconDiv"),
    AlertTypes: Filters.byKeys("WARNING", "ERROR")
  });
  const { ModalRoot, ModalSize, ModalHeader, ModalFooter, ModalContent, ModalCloseButton } = mangled(ModalModule, {
    ModalRoot: Filters.byStrings("MODAL", "rootWithShadow"),
    ModalSize: Filters.byKeys("MEDIUM", "LARGE"),
    ModalHeader: Filters.byStrings("headerIdIsManaged", "HORIZONTAL"),
    ModalFooter: Filters.byStrings("footerSeparator"),
    ModalContent: Filters.byStrings("content", "scrollbarType"),
    ModalCloseButton: Filters.byStrings("closeIcon")
  });
  const MenuItemKeyed = keyed(MenuItemModule, Filters.byStrings("dontCloseOnActionIfHoldingShiftKey", "data-menu-item"));
  const ChannelItemKeyed = keyed(ChannelItemModule, Filters.byStrings("shouldIndicateNewChannel", "MANAGE_CHANNELS"));
  const VoiceChannelItemKeyed = keyed(VoiceChannelItemModule, Filters.byStrings("PLAYING", "MANAGE_CHANNELS"));
  const StageVoiceChannelItemKeyed = keyed(StageVoiceChannelItemModule, Filters.byStrings("getStageInstanceByChannel", "MANAGE_CHANNELS"));
  const { AppContext } = mangled(AppContextModule, { AppContext: (m) => m?.Provider });
  const useExpressionPickerStoreKeyed = keyed(ExpressionPickerStoreModule, Filters.byKeys("getState", "setState"));
  const ProfileEffectsKeyed = keyed(ProfileEffectsModule, Filters.byStrings("profileEffectConfig", "useReducedMotion"));
  const EmojiKeyed = keyed(EmojiModule, Filters.byStrings("emojiId", "emojiName", "animated", "shouldAnimate"));
  const useIsVisibleKeyed = keyed(UseIsVisibleModule, Filters.byStrings("isIntersecting", "arguments.length"));
  const useIsVisible = unkeyedFn(useIsVisibleKeyed);
  const useRootElementContextKeyed = keyed(RootElementContextModule, Filters.byStrings("useRootElementContext"));
  const { useListItem, useListContainerProps, ListNavigatorProvider } = mangled(ListNavigatorModule, {
    useListItem: Filters.byStrings('"listitem"'),
    useListContainerProps: Filters.byStrings('"list"', "useContext"),
    ListNavigatorProvider: Filters.byStrings("containerProps", ".Provider")
  });
  const ListNavigatorContainer = ({ children: children2 }) => children2(useListContainerProps());
  const { useFocusLock, FocusLock } = mangled(FocusLockModule, {
    useFocusLock: Filters.byStrings("disableReturnRef"),
    FocusLock: Filters.byStrings("children", "containerRef")
  });
  const Mana = {
    ModalRootKeyed: keyed(ManaModalRootModule, Filters.byStrings("MODAL", '"padding-size-"')),
    get ModalRoot() {
      return unkeyed(this.ModalRootKeyed);
    }
  };
  const BasePopoverKeyed = keyed(BasePopoverModule, Filters.byStrings("popoverGradientWrapper", "spacing"));
  const StandardSidebarViewWrapper = Webpack.waitForModule(Filters.byPrototypeKeys("getPredicateSections", "renderSidebar"));
  const StandardSidebarViewModule = Webpack.waitForModule(Filters.bySource("standardSidebarView", "section"));
  const StandardSidebarViewKeyed = lazyKeyed(StandardSidebarViewModule, Filters.byStrings("standardSidebarView", "section"));
  const SettingsNotice = Webpack.waitForModule(Filters.byStrings("resetButton", "EMPHASIZE_NOTICE"));
  const MembersModViewSidebarModule = Webpack.waitForModule(Filters.bySource("MEMBER_SAFETY_PAGE", "closeGuildSidebar"));
  const MembersModViewSidebarKeyed = lazyKeyed(MembersModViewSidebarModule, Filters.byStrings("MEMBER_SAFETY_PAGE", "closeGuildSidebar"));
  const GenerateUserSettingsSectionsModule = Webpack.waitForModule(Filters.bySource("ACCOUNT_PROFILE", "CUSTOM", '"logout"'));
  const generateUserSettingsSectionsKeyed = lazyKeyed(GenerateUserSettingsSectionsModule, Filters.byStrings("ACCOUNT_PROFILE", "CUSTOM", '"logout"'));
  const DiscordModules = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Alert,
    AlertModule,
    AlertTypes,
    Anchor,
    App,
    AppContext,
    AppContextModule,
    AppLauncherPopup,
    AppLayer,
    AppLayerModule,
    AppPanels,
    AppViewKeyed,
    AppViewModule,
    BasePopout,
    BasePopoverKeyed,
    BasePopoverModule,
    Breadcrumbs,
    Button: Button$1,
    ButtonGroup: ButtonGroup$1,
    CSSTransition,
    CallChatSidebarKeyed,
    CallChatSidebarModule,
    ChannelAppLauncher,
    ChannelItemKeyed,
    ChannelItemModule,
    ChannelMessageList,
    ChannelSectionStore,
    ChannelStore,
    ChannelTextArea,
    ChannelTextAreaButtons,
    ChannelThreadList,
    ChannelView,
    ChatSidebarKeyed,
    ChatSidebarModule,
    Checkbox,
    CheckboxModule,
    CheckboxTypes,
    Clickable,
    ContextMenuKeyed,
    ContextMenuModule,
    CopiableField,
    Dispatcher,
    EmojiKeyed,
    EmojiModule,
    ExpressionPicker,
    ExpressionPickerStoreModule,
    Flex: Flex$1,
    Flux,
    FocusLock,
    FocusLockModule,
    FormItem,
    FormSection,
    FormSwitch,
    FormText,
    FormTitle,
    FormTitleTags,
    GatewaySocket,
    GenerateUserSettingsSectionsModule,
    GuildActionRow,
    GuildChannelListKeyed,
    GuildChannelListModule,
    GuildChannelRouteParams,
    GuildIcon,
    GuildStore,
    Heading,
    ImpressionNames,
    InviteActions,
    InviteEmbed,
    InviteStates,
    InviteStore,
    LayerActions,
    LayerActionsModule,
    LayerStore: LayerStore$1,
    LayersKeyed,
    LayersModule,
    ListNavigatorContainer,
    ListNavigatorModule,
    ListNavigatorProvider,
    ListRawModule,
    ListThin,
    Mana,
    ManaModalRootModule,
    MembersModViewSidebarKeyed,
    MembersModViewSidebarModule,
    MenuItemKeyed,
    MenuItemModule,
    MenuSubmenuItemKeyed,
    MenuSubmenuItemModule,
    MenuSubmenuListItemKeyed,
    MenuSubmenuListItemModule,
    Message: Message$1,
    MessageDivider,
    ModalActions,
    ModalActionsModule,
    ModalCloseButton,
    ModalContent,
    ModalFooter,
    ModalHeader,
    ModalModule,
    ModalRoot,
    ModalScrim,
    ModalScrimModule,
    ModalSize,
    ModalsKeyed,
    ModalsModule,
    Paginator,
    Parser,
    Popout,
    PopoutCSSAnimatorKeyed,
    PopoutCSSAnimatorModule,
    PrivateChannelSortStore,
    ProfileEffectsKeyed,
    ProfileEffectsModule,
    RadioGroup,
    RadioGroupModule,
    ReferencePositionLayer,
    RootElementContextModule,
    Router,
    RouterModule,
    Routes,
    SearchBar,
    SearchableSelect,
    SelectKeyed,
    SelectModule,
    SelectedChannelStore,
    SelectedGuildStore,
    SettingsNotice,
    SingleSelect,
    SingleSelectKeyed,
    Slider: Slider$1,
    SortedGuildStore,
    Spinner,
    SpringTransitionPhases,
    StageVoiceChannelItemKeyed,
    StageVoiceChannelItemModule,
    StandardSidebarViewKeyed,
    StandardSidebarViewModule,
    StandardSidebarViewWrapper,
    StaticChannelRoute,
    Switch: Switch$1,
    Text: Text$1,
    TextBadge,
    TextButton,
    TextInput,
    ThemeStore,
    Timeout,
    Timestamp,
    Toast: Toast$1,
    ToastModule,
    ToastStoreModule,
    Tooltip: Tooltip$1,
    TooltipLayer,
    TooltipModule,
    Transition,
    TransitionGroup,
    TransitionGroupContext,
    UseIsVisibleModule,
    UserSettingsModal,
    VoiceChannelItemKeyed,
    VoiceChannelItemModule,
    VoiceChannelViewKeyed,
    VoiceChannelViewModule,
    appLayerContext,
    colors,
    createToast,
    generateUserSettingsSectionsKeyed,
    getThemeClass,
    handleClick,
    humanize,
    matchSorter,
    popToast,
    popToastKeyed,
    showToast,
    useExpressionPickerStoreKeyed,
    useFocusLock,
    useIsModalAtTop,
    useIsVisible,
    useIsVisibleKeyed,
    useListContainerProps,
    useListItem,
    useListNavigator,
    useModalsStore,
    useRootElementContextKeyed,
    useStateFromStores,
    useToastStore
  }, Symbol.toStringTag, { value: "Module" }));
  const sizes = {
    xxs: 12,
    xs: 16,
    sm: 20,
    md: 24,
    lg: 32,
    xl: 48,
    custom: void 0,
    refresh_sm: 20
  };
  function useIconSize(size = "md", { width = 24, height = 24 } = {}) {
    return {
      width: sizes[size] ?? width,
      height: sizes[size] ?? height
    };
  }
  const IconBrandTypes = {
    DEFAULT: 0,
    INFO: 1,
    SUCCESS: 2,
    WARNING: 3,
    ERROR: 4
  };
  function IconBrand({ type = IconBrandTypes.DEFAULT, size, width, height, color = "var(--brand-500)", ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...props,
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 740 740"
      },
      type === IconBrandTypes.DEFAULT ? /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          d: "M43.48,153.61c0,.51,0,1,0,1.55a13.16,13.16,0,0,1-.15,1.54,15.3,15.3,0,0,1-.75,3,12,12,0,0,1-.6,1.43,15.12,15.12,0,0,1-.74,1.37c-2.67,4.32-6.48,6.14-11.2,7.35-3.57,0-6.64-.38-9.76-2.24-.43-.26-.84-.53-1.24-.82s-.78-.61-1.14-.94a13,13,0,0,1-1.05-1.05c-.33-.36-.64-.75-.94-1.14s-.57-.81-.82-1.23a13.75,13.75,0,0,1-.7-1.31,15.77,15.77,0,0,1-1-2.79c-.13-.5-.23-1-.31-1.52s-.12-1-.14-1.55a13.36,13.36,0,0,1,0-1.55c0-.52.08-1,.16-1.55s.19-1,.32-1.52a15,15,0,0,1,.47-1.48c.18-.49.39-1,.61-1.43a13.89,13.89,0,0,1,.76-1.36c2.73-4.32,6.61-6.1,11.37-7.22a17.55,17.55,0,0,1,9,1.94,14.46,14.46,0,0,1,1.32.8c.42.29.83.61,1.22.94a14,14,0,0,1,1.13,1c.35.37.69.76,1,1.16a13.79,13.79,0,0,1,.89,1.27c.27.43.52.88.75,1.34a13.73,13.73,0,0,1,.6,1.42,14.74,14.74,0,0,1,.46,1.47,15.17,15.17,0,0,1,.32,1.52C43.39,152.58,43.45,153.09,43.48,153.61ZM149.61,266.66a13.24,13.24,0,0,0,.48,1.51,13.79,13.79,0,0,0,.61,1.42,13.41,13.41,0,0,0,.74,1.34,14.24,14.24,0,0,0,.89,1.26,13.87,13.87,0,0,0,1,1.16,14.16,14.16,0,0,0,1.13,1.06c.39.33.8.64,1.22.93a13.48,13.48,0,0,0,1.31.8,12.58,12.58,0,0,0,1.39.66,16.84,16.84,0,0,0,9.18.9c4.61-1.5,8.28-3.72,10.53-8.2a14.8,14.8,0,0,0,.61-1.42c.18-.49.34-1,.47-1.48a15.17,15.17,0,0,0,.32-1.52c.08-.51.13-1,.16-1.54s0-1,0-1.55-.08-1-.15-1.54-.18-1-.31-1.52a12.63,12.63,0,0,0-.45-1.48c-.17-.48-.37-.95-.59-1.42s-.47-.91-.74-1.34-.56-.86-.87-1.27-.63-.79-1-1.17a12.26,12.26,0,0,0-1.1-1.06,13.51,13.51,0,0,0-1.2-.95c-.42-.3-.85-.57-1.3-.83a13.43,13.43,0,0,0-1.37-.68c-3.15-1.39-6-1.39-9.37-1.16-4.6,1.52-8.28,3.71-10.53,8.21q-.34.72-.63,1.47a15.73,15.73,0,0,0-.47,1.52,13.47,13.47,0,0,0-.32,1.56c-.08.53-.13,1.05-.16,1.59a14.06,14.06,0,0,0,0,1.59c0,.53.09,1.06.17,1.59A14.45,14.45,0,0,0,149.61,266.66ZM139,214c.19-.43.35-.86.5-1.3s.26-.89.36-1.35a12.63,12.63,0,0,0,.23-1.37,13,13,0,0,0,.08-1.39,12.82,12.82,0,0,0,0-1.39c-.05-.47-.11-.93-.2-1.38a12.11,12.11,0,0,0-.34-1.35,11.3,11.3,0,0,0-.47-1.31,12.89,12.89,0,0,0-7.81-7.14c-5.5-1.89-36.88-1.26-44.37-.74-4.16,1.48-7.23,3.46-9.19,7.59-.2.41-.37.83-.53,1.26s-.29.88-.4,1.32-.2.89-.27,1.35-.11.91-.13,1.37,0,.91,0,1.37a12.72,12.72,0,0,0,.14,1.37,10.75,10.75,0,0,0,.27,1.35,12.33,12.33,0,0,0,.4,1.31,12.58,12.58,0,0,0,6.73,7.15,16.52,16.52,0,0,0,5.48,1.35c5.55.48,11.31,0,16.88,0,7.77,0,15.57.28,23.32-.1C133.91,220.35,137.07,218.29,139,214ZM563.65,356.72c16.78-20.29,29.88-50.55,35.31-76.23,6.57-31.05,4.69-64.76-13.18-91.9-15.27-23.2-41-38.35-68-43.69-24.91-4.92-52.95-3.17-78.45-3.24l-115-.19-173.55-.42H95c-8,0-16.15-.47-24.12-.08A16.54,16.54,0,0,0,62,143.7a12.72,12.72,0,0,0-5.18,8.35c-.07.46-.13.92-.16,1.38a12.71,12.71,0,0,0,0,1.38,12.85,12.85,0,0,0,.12,1.38,12.51,12.51,0,0,0,.25,1.36,15.27,15.27,0,0,0,.92,2.62c.2.41.41.82.65,1.22s.5.78.77,1.15a14.22,14.22,0,0,0,7.93,5.3c5.3,1.09,25.27.2,31.65.2H216.36c5.11,0,10.61-.53,15.67.33,3.8.65,7,2.26,9.15,5.58a14.42,14.42,0,0,1,2.08,10.58,12.76,12.76,0,0,1-8.55,9.41c-5.61,2-12.67,1.23-18.58,1.21L180,195c-6,0-12.57-.61-18.46.26a16.73,16.73,0,0,0-6.87,2.48,11.76,11.76,0,0,0-5.34,8c-.61,3.64,0,8,2.32,10.92a13.13,13.13,0,0,0,7.28,4.85c6.46,1.62,14.69.68,21.37.63H225c6.67,0,14.08-.76,20.66.08,3.9.5,7.37,1.88,9.8,5.08A13.56,13.56,0,0,1,258.15,238a12.9,12.9,0,0,1-8.06,9.95c-11.9,4.67-45.6-3.16-55.29,4.25a12.9,12.9,0,0,0-4.7,9,13.34,13.34,0,0,0,3,10.4,13.59,13.59,0,0,0,9.09,4.59c5.95.7,12.57.14,18.59.14H259.7l133.11,0h41.63c8.22,0,16.67-.38,24.87.3,4.67,1.68,8.62,3.88,10.93,8.54,2.12,4.27,1.83,8.63,1,13.15a31.48,31.48,0,0,1-15.81,19.08,27.83,27.83,0,0,1-8.06,2.78c-8,.59-16.21.28-24.27.28-16.27,0-32.58-.27-48.84,0-8.59,34.28-18.2,68.38-26.38,102.75l48.68,0c8.09,0,16.86-.72,24.85.32,4.41,1.41,8.4,3.74,10.7,7.92,2.52,4.6,2.36,10.29.78,15.16a31.67,31.67,0,0,1-16.36,18.2,26.42,26.42,0,0,1-9.23,2.4c-5.45.47-11.08.12-16.55.09H365.42c-24.21,0-48.52.48-72.72,0,.6-5.14,2.44-10.51,3.75-15.55l7.94-30.55,26-100.7-134.54-.06C183,369.2,171.12,418.36,157.91,467.14c-7.7,32.21-16.48,64.25-24.75,96.32l-6.87,26.72c-.67,2.69-1.77,5.32-2.32,8a6.12,6.12,0,0,0,0,3.26,3.9,3.9,0,0,0,2.58.35c17.41.72,35.11.09,52.54.09l100.92,0h74.11c26.67,0,53.31.31,79.73-3.91,24.91-4,49.55-11.66,70.65-25.8,39.71-26.61,56.91-68.87,65.69-113.91,6.18-31.69,7-66.64-11.74-94.45l0-.22C560.3,361.35,562,359.06,563.65,356.72Z",
          fill: typeof color === "string" ? color : color.css
        }
      ) : /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          d: "M43.31,152.07c3.1,19.82-27.18,24.62-30.21,4.75C10.21,137.17,40.17,132.39,43.31,152.07ZM179.2,258.93c-5-19.44-34.75-11.8-29.59,7.73C154.63,285.85,184.07,278.1,179.2,258.93ZM139,214c3.22-6.85-.36-15.74-7.7-18-5.5-1.89-36.88-1.26-44.37-.74-4.16,1.48-7.23,3.46-9.19,7.59-7.19,19.7,15,20.55,28.57,19.18C117.26,221,133.2,226.53,139,214Zm378.79-69.07c-48.37-7.35-143.33-1.56-193.47-3.44-40.76,0-191.42-.58-229.28-.43-14.25-.07-45-4.59-37.09,19.13,6,13.42,29,6.67,41,7.87H216.36c8.35.15,19.39-2.15,24.82,5.91,4.85,7,1.86,17.43-6.47,20-12.21,2.88-41.89.43-54.75,1.08-10.58.07-27.67-3-30.67,10.7-2.87,18.25,18.51,17.41,31,16.4H225c12.53-.53,35.47-3.1,33.17,15.85-5.8,23.24-50.14,3.38-63.35,14.19-9.11,7.13-4.39,23.43,7.42,23.94,60.92.54,171-.11,232.22.12,12.09.86,28.84-4.21,35.8,8.84,5.45,12.49-3.57,26.5-14.79,32.23-9.88,5.14-21.61,2.52-32.33,3.06-16.27,0-32.58-.27-48.84,0-7.06,28.18-14.8,56.23-21.87,84.41,52.36-73.63,148.44-111.33,236.94-93.06C619.67,244.72,597.55,158.81,517.78,144.91ZM195.83,320.31C172.48,414,146.4,507.87,124,601.46c52.8,1.61,137.31-.22,190.54.41a237.65,237.65,0,0,1,5.37-134.46c-9.08,0-18.16-.05-27.22-.24,7.23-31.13,29.69-114.61,37.67-146.8Z",
          fill: typeof color === "string" ? color : color.css
        }
      ),
      type === IconBrandTypes.SUCCESS && /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          d: "M516.18,634,654.59,495.57l-27.48-27.49L516.18,579l-56-56-27.48,27.49Zm27.49,106a191.11,191.11,0,0,1-76.57-15.46,196.08,196.08,0,0,1-104.31-104.3,197.35,197.35,0,0,1,0-153.14A196.05,196.05,0,0,1,467.1,362.79a197.35,197.35,0,0,1,153.14,0A196.08,196.08,0,0,1,724.54,467.1a197.35,197.35,0,0,1,0,153.14,196.1,196.1,0,0,1-104.3,104.3A191.14,191.14,0,0,1,543.67,740Z",
          fill: "#239452"
        }
      ),
      type === IconBrandTypes.ERROR && /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          d: "M543.67,347.33A196.34,196.34,0,1,0,740,543.67,196.16,196.16,0,0,0,543.67,347.33Zm98.16,266.82-27.68,27.68-70.48-70.48-70.49,70.48L445.5,614.15,516,543.67,445.5,473.18l27.68-27.68L543.67,516l70.48-70.48,27.68,27.68-70.48,70.49Z",
          fill: "#f23f42"
        }
      ),
      type === IconBrandTypes.WARNING && /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          d: "M543.67,641.83a19.28,19.28,0,1,0-14-5.64A19,19,0,0,0,543.67,641.83ZM524,563.3H563.3V445.5H524ZM543.67,740a191.11,191.11,0,0,1-76.57-15.46,196.08,196.08,0,0,1-104.31-104.3,197.35,197.35,0,0,1,0-153.14A196.05,196.05,0,0,1,467.1,362.79a197.35,197.35,0,0,1,153.14,0A196.08,196.08,0,0,1,724.54,467.1a197.35,197.35,0,0,1,0,153.14,196.1,196.1,0,0,1-104.3,104.3A191.14,191.14,0,0,1,543.67,740Z",
          fill: "#f0b132"
        }
      ),
      type === IconBrandTypes.INFO && /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          d: "M524.06,641.84h39.26V524.06H524.06Zm19.63-157a19.27,19.27,0,1,0-14-5.64A19,19,0,0,0,543.69,484.79Zm0,255.21a191.06,191.06,0,0,1-76.56-15.46,196,196,0,0,1-104.3-104.29,197.42,197.42,0,0,1,0-153.12,196.1,196.1,0,0,1,104.3-104.3,197.42,197.42,0,0,1,153.12,0,196,196,0,0,1,104.29,104.3,197.3,197.3,0,0,1,0,153.12A196,196,0,0,1,620.25,724.54,191.13,191.13,0,0,1,543.69,740Z",
          fill: "#4a90e2"
        }
      )
    );
  }
  class Style {
    get name() {
      return "Style";
    }
    get styleId() {
      return `${config.name}-style`;
    }
    constructor() {
      this.initialized = false;
      this.styles = [];
      this._raf = null;
    }
    initialize() {
      this.injectStyle();
      this.initialized = true;
      Logger.info(this.name, "Initialized.");
    }
    shutdown() {
      this.removeStyle();
      this.initialized = false;
      Logger.info(this.name, "Shutdown.");
    }
    buildStyle() {
      return this.styles.reduce(
        (str, { description, style: style2 }) => str + `/* ====== ${description} ====== */
${style2}

`,
        ""
      );
    }
    buildStyleElement() {
      const style2 = document.createElement("style");
      style2.id = this.styleId;
      style2.appendChild(document.createTextNode(this.buildStyle()));
      return style2;
    }
    updateStyle() {
      if (!this.initialized) return;
      this.removeStyle();
      this.injectStyle();
      Logger.log(this.name, "Styles updated.");
    }
    scheduleUpdate() {
      if (this._raf) return;
      this._raf = requestAnimationFrame(() => {
        this._raf = null;
        this.updateStyle();
      });
    }
    registerStyle(description, style2) {
      const index2 = this.styles.findIndex((s) => s.description === description);
      if (index2 !== -1) {
        this.styles.splice(index2, 1, { description, style: style2 });
        Logger.warn(this.name, `Style "${description}" has been overridden.`);
      } else this.styles.push({ description, style: style2 });
      this.scheduleUpdate();
    }
    injectStyle() {
      document.body.appendChild(this.buildStyleElement());
    }
    removeStyle() {
      document.getElementById(this.styleId)?.remove();
    }
  }
  const createCSS = (style2) => (strings, ...values) => (description, ...descriptionValues) => style2.registerStyle(
    String.raw(description, ...descriptionValues),
    String.raw(strings, ...values)
  );
  const style = new class extends Style {
    injectStyle() {
      Logger.log(this.name, `Injecting ${this.styles.length} registered styles...`);
      DOM.addStyle(this.styleId, this.buildStyle());
    }
    removeStyle() {
      Logger.log(this.name, "Removing styles...");
      DOM.removeStyle(this.styleId);
    }
  }();
  const css = createCSS(style);
  let meta = {};
  function saveMeta(m) {
    meta = m;
  }
  const meta$1 = new Proxy({}, { get: (obj, prop) => meta[prop] ?? void 0 });
  const updateReducer = (num) => (num + 1) % 1e6;
  function useUpdate() {
    const [, update] = require$$0$1.useReducer(updateReducer, 0);
    return update;
  }
  const Emitter = new class Emitter extends EventEmitter {
    dispatch(eventName, ...args) {
      this.emit(eventName, ...args);
    }
  }();
  function useEmitterEffect(events, callback) {
    const update = useUpdate();
    const callbackRef = require$$0$1.useRef(callback);
    require$$0$1.useEffect(() => {
      callbackRef.current = callback;
    }, [callback]);
    require$$0$1.useEffect(() => {
      const _events = [].concat(events);
      const _callback = (...args) => (callbackRef.current ?? update)(...args);
      _events.forEach((e) => Emitter.on(e, _callback));
      return () => _events.forEach((e) => Emitter.off(e, _callback));
    }, [events]);
    return require$$0$1.useCallback(Emitter.emit.bind(Emitter), []);
  }
  function enumirize(values) {
    if (!Array.isArray(values)) return values;
    return values.reduce(
      (obj, name2, i) => ({ ...obj, [name2]: i }),
      {}
    );
  }
  function Enum(values) {
    const raw = enumirize(values);
    return Object.freeze(
      Object.assign(
        { raw },
        raw,
        {
          keys: () => Object.keys(raw),
          values: () => Object.values(raw)
        }
      )
    );
  }
  const Events = Enum({
    PluginDisabled: "plugin-disabled",
    PackLoaded: "pack-loaded",
    PackUnloaded: "pack-unloaded",
    PackEnabled: "pack-enabled",
    PackDisabled: "pack-disabled",
    PackUpdated: "pack-updated",
    ModuleToggled: "module-toggled",
    ModuleSettingsChanged: "module-settings-changed",
    SettingsChanged: "settings-changed",
    SettingsLoaded: "settings-loaded",
    SettingsSaved: "settings-saved",
    PackRegistryUpdated: "pack-registry-updated",
    SettingsModeChanged: "settings-mode-changed",
    DismissibleUpdated: "dismissible-updated",
    ErrorOccurred: "error-occurred",
    MigratorUpdated: "migrator-updated"
  });
  function Modal$2({
    title,
    children: children2,
    footerLeading,
    footer,
    onClose,
    confirmText = "Close",
    confirmButtonVariant = "secondary",
    cancelText,
    onConfirm,
    onCancel,
    loading = false,
    disabled = loading,
    ...props
  }) {
    useEmitterEffect(Events.PluginDisabled, onClose);
    const onCallback = (callback) => () => {
      let shouldClose = true;
      const preventClose = () => shouldClose = false;
      callback?.(preventClose);
      if (shouldClose) onClose?.();
    };
    return /* @__PURE__ */ BdApi.React.createElement(
      ModalRoot,
      {
        className: "BA__modal",
        ...props
      },
      /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, null, /* @__PURE__ */ BdApi.React.createElement(ModalHeader, { separator: false }, /* @__PURE__ */ BdApi.React.createElement(
        Tooltip$1,
        {
          text: meta$1.name,
          shouldShow: !!title,
          position: "bottom",
          align: "left"
        },
        (props2) => /* @__PURE__ */ BdApi.React.createElement(
          IconBrand,
          {
            ...props2,
            className: "BA__modalIcon",
            size: "custom",
            width: 36,
            height: 36
          }
        )
      ), /* @__PURE__ */ BdApi.React.createElement(Heading, { variant: "heading-lg/semibold" }, title ?? meta$1.name)), /* @__PURE__ */ BdApi.React.createElement(ModalContent, { className: "BA__modalContent" }, children2), footer !== false && /* @__PURE__ */ BdApi.React.createElement(ModalFooter, null, footer ?? /* @__PURE__ */ BdApi.React.createElement(
        ButtonGroup$1,
        {
          className: "BA__modalButtonGroup",
          direction: "horizontal-reverse"
        },
        /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            type: "submit",
            variant: confirmButtonVariant,
            text: confirmText,
            loading,
            disabled,
            onClick: onCallback(onConfirm)
          }
        ),
        cancelText ? /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            type: "button",
            variant: "secondary",
            text: cancelText,
            disabled: loading,
            onClick: onCallback(onCancel)
          }
        ) : null
      ), footerLeading))
    );
  }
  css`.BA__modal {
    min-height: unset;
}

.BA__modalIcon {
    margin-right: 4px;
}

.BA__modalContent {
    padding-bottom: 20px;
}

.BA__modalButtonGroup {
    width: auto;
}``Modal`;
  function Divider$2({ className, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        className: classNames("BA__divider", className),
        ...props
      }
    );
  }
  css`.BA__divider {
    border-top: thin solid var(--border-subtle);
    height: 1px;
    width: 100%;
}``Divider`;
  const _Classes = {
    ChatSidebar: Webpack.getByKeys("chatLayerWrapper", "chatTarget"),
    StandardSidebarView: () => Webpack.getByKeys("standardSidebarView", "contentRegion"),
    Modal: Webpack.getByKeys("root", "rootWithShadow"),
    ModalBackdrop: Webpack.getByKeys("backdrop", "withLayer"),
    Layers: Webpack.getByKeys("layer", "baseLayer"),
    Margins: Webpack.getByKeys("marginTop20", "marginLeft8"),
    AppMount: Webpack.getByKeys("appMount"),
    AppView: Webpack.getByKeys("base", "content"),
    ChannelView: Webpack.getByKeys("chat", "chatContent"),
    VoiceChannelView: Webpack.getByKeys("channelChatWrapper", "noChat"),
    ChannelItem: Webpack.getByKeys("containerDefault", "channelInfo"),
    MessageList: Webpack.getByKeys("message", "groupStart"),
    Layer: Webpack.getByKeys("layer", "layerContainer"),
    Toast: Webpack.getByKeys("toast", "icon"),
    Scroller: Webpack.getByKeys("thin", "disableScrollAnchor"),
    Select: Webpack.getByKeys("select", "measurement"),
    ManaModal: Webpack.getByKeys("actionBar", "headerTrailing")
  };
  const DiscordClasses = new Proxy(_Classes, {
    get(obj, prop) {
      const value = obj[prop];
      if (typeof value !== "function") return value;
      const resolved = value();
      if (!resolved) return void 0;
      return obj[prop] = resolved;
    }
  });
  function buildIndent(level) {
    return " ".repeat(level * 2);
  }
  function indent(text2, level = 1) {
    const indent2 = buildIndent(level);
    return (text2.slice(0, 2) !== "\n" ? indent2 : "") + text2.replaceAll("\n", `
${indent2}`);
  }
  function capitalize(text2) {
    return text2.charAt(0).toUpperCase() + text2.slice(1);
  }
  function sanitize$1(text2) {
    return text2.replace(
      /([\uE000-\uF8FF]|\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDDFF])/g,
      ""
    ).replace(/\s+/g, " ").trim();
  }
  const version$1 = "2.0.2";
  class BaseError extends Error {
    constructor(message, options = {}, additionalMeta = []) {
      const { module: module2, pack } = options;
      const meta2 = [
        `${config.name} ${version$1}`,
        module2 && `Module: ${module2.name}`,
        pack && "Pack: " + [
          pack.name,
          pack.version && `v${pack.version}`,
          pack.author && `by ${pack.author}`
        ].filter(Boolean).join(" "),
        ...additionalMeta
      ];
      super(message + "\n\n" + indent(meta2.filter(Boolean).join("\n"), 2) + "\n");
      this.module = module2;
      this.pack = pack;
    }
  }
  class Validator {
    get name() {
      return "Validator";
    }
    constructor() {
      this.issues = /* @__PURE__ */ new Map();
    }
    shouldSkip(module2) {
      return module2 instanceof Flux.Store || module2 === (GatewaySocket ?? {});
    }
    collectIssues(modules2) {
      const issues = [];
      for (const [key2, module2] of Object.entries(modules2)) {
        if (module2 === void 0 || Array.isArray(module2) && module2.includes(void 0))
          issues.push([key2, "Unresolved module."]);
        else if (typeof module2 === "object" && module2 !== null && !this.shouldSkip(module2)) {
          const keys2 = Object.keys(module2).filter((k) => module2[k] === void 0);
          if (keys2.length) issues.push([key2, `Unresolved module keys: ${keys2.join(", ")}.`]);
        }
      }
      return issues;
    }
    buildMessage(name2, issues = this.issues.get(name2) ?? []) {
      return `Found ${issues.length} issue${issues.length > 1 ? "s" : ""} in ${name2}:
` + issues.map(([key2, value]) => `  • ${key2}: ${value}`).join("\n");
    }
    validateModules(name2, modules2) {
      Logger.info(this.name, `Validating ${name2}...`);
      const issues = this.collectIssues(modules2);
      if (!issues.length) {
        Logger.info(this.name, `No issues found in ${name2}.`);
        return true;
      }
      this.issues.set(name2, issues);
      const message = this.buildMessage(name2, issues);
      Logger.warn(this.name, message);
      return false;
    }
    onStartup() {
      this.validateModules("DiscordModules", DiscordModules);
      this.validateModules("DiscordClasses", _Classes);
    }
  }
  const Validator$1 = new Validator();
  class InternalError extends BaseError {
    static Category = {
      GENERAL: 0,
      MODULE: 1,
      PRIORITIZE_ANIMATION_SMOOTHNESS: 2,
      CACHE_USER_SETTINGS_SECTIONS: 3
    };
    constructor(message, { category, ...options } = {}) {
      const meta2 = [];
      if (Validator$1.issues.has("DiscordModules"))
        meta2.push(`${Validator$1.name}: ${Validator$1.buildMessage("DiscordModules")}`);
      super(message, options, meta2);
      this.category = category ?? InternalError.Category.GENERAL;
    }
    get name() {
      return "InternalError";
    }
  }
  class AddonError extends BaseError {
    constructor(type, addon, message, options = {}) {
      super(message, {
        [type]: addon,
        ...options
      });
      this.type = type;
      this.addon = addon;
    }
    get name() {
      return `${capitalize(this.type)}Error`;
    }
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n) {
    if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a2() {
        var isInstance = false;
        try {
          isInstance = this instanceof a2;
        } catch {
        }
        if (isInstance) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  const __viteBrowserExternal = {};
  const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  var objectInspect$1;
  var hasRequiredObjectInspect;
  function requireObjectInspect() {
    if (hasRequiredObjectInspect) return objectInspect$1;
    hasRequiredObjectInspect = 1;
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString2 = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int2 = num < 0 ? -$floor(-num) : $floor(num);
        if (int2 !== num) {
          var intStr = String(int2);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require$$0;
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    objectInspect$1 = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray2(obj) ? "[Array]" : "[Object]";
      }
      var indent2 = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name2 = nameOf(obj);
        var keys2 = arrObjKeys(obj, inspect);
        return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement2(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray2(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent2 && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent2) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap2(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key2) {
            mapParts.push(inspect(key2, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent2);
      }
      if (isSet2(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent2);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber2(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag2 = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag2 || protoTag ? "[" + $join.call($concat.call([], stringTag2 || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent2) {
          return tag + "{" + indentedJoin(ys, indent2) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var style2 = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style2];
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function canTrustToString(obj) {
      return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
    }
    function isArray2(obj) {
      return toStr(obj) === "[object Array]" && canTrustToString(obj);
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && canTrustToString(obj);
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && canTrustToString(obj);
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && canTrustToString(obj);
    }
    function isNumber2(obj) {
      return toStr(obj) === "[object Number]" && canTrustToString(obj);
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
      return key2 in this;
    };
    function has(obj, key2) {
      return hasOwn.call(obj, key2);
    }
    function toStr(obj) {
      return objectToString2.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap2(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet2(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement2(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent2) {
      var joinedEntries = indent2 ? indentedJoin(entries, indent2) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent2) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent2.prev + indent2.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent2.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr2 = isArray2(obj);
      var xs = [];
      if (isArr2) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key2 in obj) {
        if (!has(obj, key2)) {
          continue;
        }
        if (isArr2 && String(Number(key2)) === key2 && key2 < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key2)) {
          xs.push(inspect(key2, obj) + ": " + inspect(obj[key2], obj));
        } else {
          xs.push(key2 + ": " + inspect(obj[key2], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
    return objectInspect$1;
  }
  var objectInspectExports = /* @__PURE__ */ requireObjectInspect();
  const objectInspect = /* @__PURE__ */ getDefaultExportFromCjs(objectInspectExports);
  function getPath$2(obj, path2) {
    if (!path2.length) return obj;
    if (typeof obj !== "object" || obj === null) return void 0;
    const [key2, ...rest] = path2;
    return getPath$2(obj[key2], rest);
  }
  function pick(obj, keys2 = []) {
    return Object.fromEntries(
      keys2.filter((k) => Object.hasOwn(obj, k)).map((k) => [k, obj[k]])
    );
  }
  function omit(obj, keys2 = []) {
    return Object.fromEntries(
      Object.entries(obj).filter(([k]) => !keys2.includes(k))
    );
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function assocIndexOf(array, key2) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key2)) {
        return length;
      }
    }
    return -1;
  }
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key2) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index2 == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key2) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
    return index2 < 0 ? void 0 : data2[index2][1];
  }
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  function listCacheSet(key2, value) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
    if (index2 < 0) {
      ++this.size;
      data2.push([key2, value]);
    } else {
      data2[index2][1] = value;
    }
    return this;
  }
  function ListCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key2) {
    var data2 = this.__data__, result = data2["delete"](key2);
    this.size = data2.size;
    return result;
  }
  function stackGet(key2) {
    return this.__data__.get(key2);
  }
  function stackHas(key2) {
    return this.__data__.has(key2);
  }
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root$2 = freeGlobal || freeSelf || Function("return this")();
  var Symbol$1 = root$2.Symbol;
  var objectProto$e = Object.prototype;
  var hasOwnProperty$b = objectProto$e.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$e.toString;
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var objectProto$d = Object.prototype;
  var nativeObjectToString = objectProto$d.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
  }
  var coreJsData = root$2["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var funcProto$2 = Function.prototype;
  var funcToString$2 = funcProto$2.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
  var funcToString$1 = funcProto$1.toString;
  var hasOwnProperty$a = objectProto$c.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function getValue(object, key2) {
    return object == null ? void 0 : object[key2];
  }
  function getNative(object, key2) {
    var value = getValue(object, key2);
    return baseIsNative(value) ? value : void 0;
  }
  var Map$1 = getNative(root$2, "Map");
  var nativeCreate = getNative(Object, "create");
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key2) {
    var result = this.has(key2) && delete this.__data__[key2];
    this.size -= result ? 1 : 0;
    return result;
  }
  var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
  var objectProto$b = Object.prototype;
  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
  function hashGet(key2) {
    var data2 = this.__data__;
    if (nativeCreate) {
      var result = data2[key2];
      return result === HASH_UNDEFINED$2 ? void 0 : result;
    }
    return hasOwnProperty$9.call(data2, key2) ? data2[key2] : void 0;
  }
  var objectProto$a = Object.prototype;
  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
  function hashHas(key2) {
    var data2 = this.__data__;
    return nativeCreate ? data2[key2] !== void 0 : hasOwnProperty$8.call(data2, key2);
  }
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  function hashSet(key2, value) {
    var data2 = this.__data__;
    this.size += this.has(key2) ? 0 : 1;
    data2[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
    return this;
  }
  function Hash(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$1 || ListCache)(),
      "string": new Hash()
    };
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function getMapData(map, key2) {
    var data2 = map.__data__;
    return isKeyable(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
  }
  function mapCacheDelete(key2) {
    var result = getMapData(this, key2)["delete"](key2);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  function mapCacheSet(key2, value) {
    var data2 = getMapData(this, key2), size = data2.size;
    data2.set(key2, value);
    this.size += data2.size == size ? 0 : 1;
    return this;
  }
  function MapCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key2, value) {
    var data2 = this.__data__;
    if (data2 instanceof ListCache) {
      var pairs = data2.__data__;
      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key2, value]);
        this.size = ++data2.size;
        return this;
      }
      data2 = this.__data__ = new MapCache(pairs);
    }
    data2.set(key2, value);
    this.size = data2.size;
    return this;
  }
  function Stack(entries) {
    var data2 = this.__data__ = new ListCache(entries);
    this.size = data2.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayEach(array, iteratee) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (iteratee(array[index2], index2, array) === false) {
        break;
      }
    }
    return array;
  }
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  function baseAssignValue(object, key2, value) {
    if (key2 == "__proto__" && defineProperty) {
      defineProperty(object, key2, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key2] = value;
    }
  }
  var objectProto$9 = Object.prototype;
  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
  function assignValue(object, key2, value) {
    var objValue = object[key2];
    if (!(hasOwnProperty$7.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
      baseAssignValue(object, key2, value);
    }
  }
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var argsTag$3 = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$3;
  }
  var objectProto$8 = Object.prototype;
  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
  var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
  var isArguments = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$6.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
  };
  var isArray = Array.isArray;
  function stubFalse() {
    return false;
  }
  var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
  var Buffer$1 = moduleExports$2 ? root$2.Buffer : void 0;
  var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse;
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
  var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
  typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
  var freeProcess = moduleExports$1 && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  var objectProto$7 = Object.prototype;
  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr2 = isArray(value), isArg = !isArr2 && isArguments(value), isBuff = !isArr2 && !isArg && isBuffer(value), isType = !isArr2 && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr2 || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key2 in value) {
      if (hasOwnProperty$5.call(value, key2) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
      isIndex(key2, length)))) {
        result.push(key2);
      }
    }
    return result;
  }
  var objectProto$6 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
    return value === proto;
  }
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var nativeKeys = overArg(Object.keys, Object);
  var objectProto$5 = Object.prototype;
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key2 in Object(object)) {
      if (hasOwnProperty$4.call(object, key2) && key2 != "constructor") {
        result.push(key2);
      }
    }
    return result;
  }
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function keys$1(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root$2.Buffer : void 0;
  Buffer ? Buffer.allocUnsafe : void 0;
  function cloneBuffer(buffer, isDeep) {
    {
      return buffer.slice();
    }
  }
  function arrayFilter(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function stubArray() {
    return [];
  }
  var objectProto$4 = Object.prototype;
  var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  function arrayPush(array, values) {
    var index2 = -1, length = values.length, offset = array.length;
    while (++index2 < length) {
      array[offset + index2] = values[index2];
    }
    return array;
  }
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys$1, getSymbols);
  }
  var DataView$1 = getNative(root$2, "DataView");
  var Promise$1 = getNative(root$2, "Promise");
  var Set$1 = getNative(root$2, "Set");
  var WeakMap$1 = getNative(root$2, "WeakMap");
  var mapTag$4 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
  var dataViewTag$3 = "[object DataView]";
  var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
  var getTag = baseGetTag;
  if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag$3 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$3;
          case mapCtorString:
            return mapTag$4;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag$4;
          case weakMapCtorString:
            return weakMapTag$1;
        }
      }
      return result;
    };
  }
  var objectProto$3 = Object.prototype;
  var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
  function initCloneArray(array) {
    var length = array.length, result = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty$3.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  var Uint8Array$1 = root$2.Uint8Array;
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = cloneArrayBuffer(dataView.buffer);
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = cloneArrayBuffer(typedArray.buffer);
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
  var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag$2:
        return cloneArrayBuffer(object);
      case boolTag$2:
      case dateTag$2:
        return new Ctor(+object);
      case dataViewTag$2:
        return cloneDataView(object);
      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return cloneTypedArray(object);
      case mapTag$3:
        return new Ctor();
      case numberTag$2:
      case stringTag$2:
        return new Ctor(object);
      case regexpTag$2:
        return cloneRegExp(object);
      case setTag$3:
        return new Ctor();
      case symbolTag$2:
        return cloneSymbol(object);
    }
  }
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function() {
    function object() {
    }
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  var mapTag$2 = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag$2;
  }
  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  var setTag$2 = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag$2;
  }
  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  function baseClone(value, bitmask, customizer, key2, object, stack) {
    var result;
    if (result !== void 0) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr2 = isArray(value);
    if (isArr2) {
      result = initCloneArray(value);
    } else {
      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value)) {
        return cloneBuffer(value);
      }
      if (tag == objectTag$2 || tag == argsTag$1 || isFunc && !object) {
        result = isFunc ? {} : initCloneObject(value);
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key3) {
        result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
      });
    }
    var keysFunc = getAllKeys;
    var props = isArr2 ? void 0 : keysFunc(value);
    arrayEach(props || value, function(subValue, key3) {
      if (props) {
        key3 = subValue;
        subValue = value[key3];
      }
      assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
    });
    return result;
  }
  var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }
  var util;
  (function(util2) {
    util2.assertEqual = (_) => {
    };
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items2) => {
      const obj = {};
      for (const item of items2) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys2 = [];
      for (const key2 in object) {
        if (Object.prototype.hasOwnProperty.call(object, key2)) {
          keys2.push(key2);
        }
      }
      return keys2;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const getParsedType = (data2) => {
    const t = typeof data2;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return Number.isNaN(data2) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data2)) {
          return ZodParsedType.array;
        }
        if (data2 === null) {
          return ZodParsedType.null;
        }
        if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data2 instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data2 instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data2 instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  class ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error2) => {
        for (const issue of error2.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  ZodError.create = (issues) => {
    const error2 = new ZodError(issues);
    return error2;
  };
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "bigint")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  let overrideErrorMap = errorMap;
  function getErrorMap() {
    return overrideErrorMap;
  }
  const makeIssue = (params) => {
    const { data: data2, path: path2, errorMaps, issueData } = params;
    const fullPath = [...path2, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data: data2, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === errorMap ? void 0 : errorMap
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key2 = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key: key2,
          value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key: key2, value } = pair;
        if (key2.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key2.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key2.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  const INVALID = Object.freeze({
    status: "aborted"
  });
  const DIRTY = (value) => ({ status: "dirty", value });
  const OK = (value) => ({ status: "valid", value });
  const isAborted = (x) => x.status === "aborted";
  const isDirty = (x) => x.status === "dirty";
  const isValid = (x) => x.status === "valid";
  const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil || (errorUtil = {}));
  class ParseInputLazyPath {
    constructor(parent, value, path2, key2) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path2;
      this._key = key2;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (Array.isArray(this._key)) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error2 = new ZodError(ctx.common.issues);
          this._error = error2;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message ?? ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: message ?? required_error ?? ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data2, params) {
      const result = this.safeParse(data2, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data2, params) {
      const ctx = {
        common: {
          issues: [],
          async: params?.async ?? false,
          contextualErrorMap: params?.errorMap
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: data2,
        parsedType: getParsedType(data2)
      };
      const result = this._parseSync({ data: data2, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    "~validate"(data2) {
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: data2,
        parsedType: getParsedType(data2)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data: data2, path: [], parent: ctx });
          return isValid(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if (err?.message?.toLowerCase()?.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data: data2, path: [], parent: ctx }).then((result) => isValid(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data2, params) {
      const result = await this.safeParseAsync(data2, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data2, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params?.errorMap,
          async: true
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: data2,
        parsedType: getParsedType(data2)
      };
      const maybeAsyncResult = this._parse({ data: data2, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data2) => {
            if (!data2) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data2) => this["~validate"](data2)
      };
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform2) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform: transform2 }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[0-9a-z]+$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const nanoidRegex = /^[a-z0-9_-]{21}$/i;
  const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex;
  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  const dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
      secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex2 = `${regex2}(${opts.join("|")})`;
    return new RegExp(`^${regex2}$`);
  }
  function isValidIP(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      if (!header)
        return false;
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if ("typ" in decoded && decoded?.typ !== "JWT")
        return false;
      if (!decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch {
      return false;
    }
  }
  function isValidCidr(ip, version2) {
    if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex2 = datetimeRegex(check);
          if (!regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex2 = dateRegex;
          if (!regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex2 = timeRegex(check);
          if (!regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex2, validation, message) {
      return this.refinement((data2) => regex2.test(data2), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex2, message) {
      return this._addCheck({
        kind: "regex",
        regex: regex2,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
  }
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max2 = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max2);
    }
  }
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
  }
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2 != null ? new Date(max2) : null;
    }
  }
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  }
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key2 in schema.shape) {
        const fieldSchema = schema.shape[key2];
        newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys2 = util.objectKeys(shape);
      this._cached = { shape, keys: keys2 };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key2 in ctx.data) {
          if (!shapeKeys.includes(key2)) {
            extraKeys.push(key2);
          }
        }
      }
      const pairs = [];
      for (const key2 of shapeKeys) {
        const keyValidator = shape[key2];
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
          alwaysSet: key2 in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key2 of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key2 },
              value: { status: "valid", value: ctx.data[key2] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key2 of extraKeys) {
          const value = ctx.data[key2];
          pairs.push({
            key: { status: "valid", value: key2 },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key2)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key2 in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key2 = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key: key2,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key2, schema) {
      return this.augment({ [key2]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index2) {
      return new ZodObject({
        ...this._def,
        catchall: index2
      });
    }
    pick(mask) {
      const shape = {};
      for (const key2 of util.objectKeys(mask)) {
        if (mask[key2] && this.shape[key2]) {
          shape[key2] = this.shape[key2];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key2 of util.objectKeys(this.shape)) {
        if (!mask[key2]) {
          shape[key2] = this.shape[key2];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key2 of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key2];
        if (mask && !mask[key2]) {
          newShape[key2] = fieldSchema;
        } else {
          newShape[key2] = fieldSchema.optional();
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key2 of util.objectKeys(this.shape)) {
        if (mask && !mask[key2]) {
          newShape[key2] = this.shape[key2];
        } else {
          const fieldSchema = this.shape[key2];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key2] = newField;
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  }
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  ZodUnion.create = (types2, params) => {
    return new ZodUnion({
      options: types2,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  }
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key2) => bKeys.indexOf(key2) !== -1);
      const newObj = { ...a, ...b };
      for (const key2 of sharedKeys) {
        const sharedValue = mergeValues(a[key2], b[key2]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key2] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index2 = 0; index2 < a.length; index2++) {
        const itemA = a[index2];
        const itemB = b[index2];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items2 = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items2).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items2);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key2 in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2)),
          alwaysSet: key2 in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key2, value], index2) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index2, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key2 = await pair.key;
            const value = await pair.value;
            if (key2.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key2.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key2.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key2 = pair.key;
          const value = pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element2 of elements2) {
          if (element2.status === "aborted")
            return INVALID;
          if (element2.status === "dirty")
            status.dirty();
          parsedSet.add(element2.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  }
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data2) => {
        return this._def.type.parseAsync(data2, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return INVALID;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  }
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data2 = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data2 = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data: data2,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data2 = ctx.data;
      return this._def.type._parse({
        data: data2,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data2) => {
        if (isValid(data2)) {
          data2.value = Object.freeze(data2.value);
        }
        return data2;
      };
      return isAsync(result) ? result.then((data2) => freeze(data2)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function cleanParams(params, data2) {
    const p = typeof params === "function" ? params(data2) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
  }
  function custom(check, _params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data2, ctx) => {
        const r = check(data2);
        if (r instanceof Promise) {
          return r.then((r2) => {
            if (!r2) {
              const params = cleanParams(_params, data2);
              const _fatal = params.fatal ?? fatal ?? true;
              ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
          });
        }
        if (!r) {
          const params = cleanParams(_params, data2);
          const _fatal = params.fatal ?? fatal ?? true;
          ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
        }
        return;
      });
    return ZodAny.create();
  }
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  const stringType = ZodString.create;
  const numberType = ZodNumber.create;
  const booleanType = ZodBoolean.create;
  const symbolType = ZodSymbol.create;
  const undefinedType = ZodUndefined.create;
  const nullType = ZodNull.create;
  const anyType = ZodAny.create;
  ZodNever.create;
  const arrayType = ZodArray.create;
  const objectType = ZodObject.create;
  const strictObjectType = ZodObject.strictCreate;
  const unionType = ZodUnion.create;
  const discriminatedUnionType = ZodDiscriminatedUnion.create;
  ZodIntersection.create;
  const tupleType = ZodTuple.create;
  const recordType = ZodRecord.create;
  const lazyType = ZodLazy.create;
  const literalType = ZodLiteral.create;
  const enumType = ZodEnum.create;
  ZodPromise.create;
  ZodOptional.create;
  ZodNullable.create;
  const NEVER = INVALID;
  var objectTag$1 = "[object Object]";
  var funcProto = Function.prototype, objectProto$2 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  function isElement(value) {
    return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
  }
  const Literal = unionType([stringType(), numberType(), booleanType(), nullType(), undefinedType()]);
  const Defined = anyType().refine((v) => v !== void 0, { message: "Must be defined" });
  const ArrayOrSingleSchema = (value) => unionType([arrayType(value), value]);
  const formatValuesList = (arr, separator = ", ") => arr.map((i) => `'${i}'`).join(separator);
  const FunctionSchema = custom((v) => typeof v === "function", "Input is not a function");
  const DOMElementSchema = custom(isElement, "Input is not an Element");
  const lazyInjectSymbol = Symbol("lazyInject");
  const generatedLazyInjectSymbol = Symbol("generatedLazyInject");
  const LazyInjectSchema = objectType({
    symbol: literalType(lazyInjectSymbol),
    name: stringType(),
    generator: FunctionSchema
  });
  function wrapLazyInject(name2, generator) {
    return {
      symbol: lazyInjectSymbol,
      name: name2,
      generator
    };
  }
  function isLazyInject(value) {
    return value?.symbol === lazyInjectSymbol;
  }
  function baseStopPropagation(value) {
    return isElement(value) || isSourceMap(value) || isLazyInject(value);
  }
  function deepMap(obj, callback, { stopPropagation: stopPropagation2 = baseStopPropagation, path: path2 = [] } = {}) {
    if (typeof obj === "object" && obj !== null && !stopPropagation2(obj)) {
      obj = Array.isArray(obj) ? [...obj] : { ...obj };
      for (const key2 in obj) {
        obj[key2] = deepMap(obj[key2], callback, {
          stopPropagation: stopPropagation2,
          path: path2.concat(key2)
        });
      }
    }
    const issues = [];
    const addIssue = ({ code = "custom", path: issuePath = [], message, params }) => issues.push({
      code,
      path: path2.concat(issuePath),
      message,
      params
    });
    const ctx = { path: path2, addIssue };
    const value = callback(obj, ctx);
    if (issues.length) throw new ZodError(issues);
    return value;
  }
  const SOURCE_MAP_KEY = "__sourceMap";
  const IS_SOURCE_MAP_KEY = "__isSourceMap";
  const SELF_KEY = "__self";
  const reservedKeys$1 = [SOURCE_MAP_KEY, IS_SOURCE_MAP_KEY, SELF_KEY];
  const sourceMapSymbol = Symbol("sourceMap");
  const SourceMapSchema = objectType({
    [IS_SOURCE_MAP_KEY]: literalType(sourceMapSymbol)
  }).passthrough();
  const SourceMappedObjectSchema = objectType({
    [SOURCE_MAP_KEY]: SourceMapSchema.optional()
  });
  function buildSourceMap(target = {}, path2 = void 0) {
    return Object.fromEntries([
      [IS_SOURCE_MAP_KEY, sourceMapSymbol],
      [SELF_KEY, path2],
      ...Object.keys(target).map((key2) => [key2, (path2 ?? []).concat(key2)])
    ]);
  }
  function storeSourceMap(target, path2 = void 0) {
    target[SOURCE_MAP_KEY] = buildSourceMap(target, path2);
    return target;
  }
  function isSourceMap(value) {
    return value?.[IS_SOURCE_MAP_KEY] === sourceMapSymbol;
  }
  function hasSourceMap(value) {
    return typeof value === "object" && value !== null && isSourceMap(value[SOURCE_MAP_KEY]);
  }
  function getSourceMap(value) {
    return hasSourceMap(value) ? value[SOURCE_MAP_KEY] : void 0;
  }
  function getSourcePath(target, key2) {
    return getSourceMap(target)?.[key2];
  }
  function toSourcePath(data2, path2 = [], options = {}) {
    const { useSelf = false } = options;
    return getSourcePath(
      getPath$2(data2, path2.slice(0, -1)),
      path2[path2.length - 1] ?? (useSelf ? SELF_KEY : void 0)
    );
  }
  function clearSourceMap(value) {
    if (hasSourceMap(value)) delete value[SOURCE_MAP_KEY];
    return value;
  }
  function clearSourceMapDeep(value) {
    return deepMap(value, (value2) => {
      if (isSourceMap(value2)) return value2;
      clearSourceMap(value2);
      return value2;
    });
  }
  function sourceMappedObjectEntries(value) {
    return Object.entries(value).filter(([key2]) => key2 !== SOURCE_MAP_KEY);
  }
  function sourceMappedObjectAssign(target, ...source) {
    if (!hasSourceMap(target)) target[SOURCE_MAP_KEY] = buildSourceMap();
    source.forEach((source2) => {
      const sourceMap = getSourceMap(source2);
      sourceMappedObjectEntries(source2).forEach(([key2, value]) => {
        target[key2] = value;
        const sourcePath = sourceMap?.[key2];
        if (sourcePath === void 0) delete target[SOURCE_MAP_KEY][key2];
        else target[SOURCE_MAP_KEY][key2] = sourcePath;
      });
    });
    return target;
  }
  function sourceMappedPick(obj, keys2 = []) {
    const value = pick(obj, [SOURCE_MAP_KEY].concat(keys2));
    if (hasSourceMap(value))
      value[SOURCE_MAP_KEY] = pick(
        getSourceMap(value),
        [IS_SOURCE_MAP_KEY, SELF_KEY].concat(keys2)
      );
    return value;
  }
  function sourceMappedOmit(obj, keys2 = []) {
    const value = omit(obj, keys2.filter((key2) => key2 !== SOURCE_MAP_KEY));
    if (hasSourceMap(value))
      value[SOURCE_MAP_KEY] = omit(
        getSourceMap(value),
        keys2.filter((key2) => ![IS_SOURCE_MAP_KEY, SELF_KEY].includes(key2))
      );
    return value;
  }
  function getKey(key2) {
    const intKey = parseInt(key2);
    return intKey.toString() === key2 ? intKey : key2;
  }
  function parsePath(path2) {
    if (!path2.startsWith("/")) throw new Error("JSON Pointer must begin with `/`");
    return path2.split("/").slice(1).map(
      (k) => k.replaceAll("~0", "~").replaceAll("~1", "/")
    );
  }
  function getPath$1(obj, path2) {
    if (typeof path2 === "string") return getPath$1(obj, parsePath(path2));
    if (!path2.length) return obj;
    if (typeof obj !== "object" || obj === null) return void 0;
    const [key2, ...rest] = path2;
    return getPath$1(
      obj[getKey(key2)],
      rest
    );
  }
  function toPath(path2) {
    if (!path2?.length) return "";
    return "/" + path2.map(
      (k) => String(k).replaceAll("~", "~0").replaceAll("/", "~1")
    ).join("/");
  }
  function positionToLineColumn(content, position2) {
    let lineBreaks = 0, lastLineBreakPosition = -1;
    for (let i = 0; i < position2; i++) {
      if (content.charAt(i) !== "\n") continue;
      lineBreaks += 1;
      lastLineBreakPosition = i;
    }
    return {
      line: lineBreaks,
      column: position2 - lastLineBreakPosition - 1
    };
  }
  function visualizePosition(content, start, end = void 0, options = {}) {
    const { lineClamp = 2 } = options;
    const { line, column } = start;
    const lineCounterLength = String(line + lineClamp + 1).length;
    const startLine = Math.max(line - lineClamp, 0);
    const lines = content.slice(startLine, line + lineClamp + 1).map((l, i) => `${startLine + i + 1}`.padStart(lineCounterLength) + "│" + l);
    lines.splice(
      line - startLine + 1,
      0,
      " ".repeat(lineCounterLength) + "│" + " ".repeat(column) + "^".repeat(line === end?.line ? end.column - column : 1)
    );
    const viewWidth = Math.max(...lines.map((l) => l.length));
    const border = (cornerLeft, center, cornerRight) => cornerLeft + "─".repeat(lineCounterLength) + center + "─".repeat(viewWidth - lineCounterLength) + cornerRight;
    return [
      border("┌", "┬", "┐"),
      ...lines.map((l) => "│" + l.padEnd(viewWidth) + " │"),
      border("└", "┴", "┘")
    ].join("\n");
  }
  function visualizeAddonPath(addon, path2, options = {}) {
    const { pointAt = "value" } = options;
    if (Array.isArray(path2)) path2 = toPath(path2);
    const pointer = addon.pointers?.[path2] ?? {};
    const start = pointer[pointAt];
    const end = pointer[pointAt + "End"];
    if (!start) return;
    return visualizePosition(addon.fileContent, start, end, options);
  }
  function visualizeAddonParseError(addon, error2, rawContent, options = {}) {
    const [, position2] = error2.message.match(/at position (\d+)/) ?? [];
    if (typeof position2 !== "string") return;
    const { line, column } = positionToLineColumn(rawContent, +position2) ?? {};
    if (typeof line !== "number") return;
    return visualizePosition(addon.fileContent, { line, column }, void 0, options);
  }
  function formatAddonParseError(addon, error2, rawContent) {
    let message = "\n• " + error2.message;
    const visualized = visualizeAddonParseError(addon, error2, rawContent);
    if (visualized) message += indent("\n" + visualized + "\n");
    return message;
  }
  function stripInject(path2) {
    return path2[path2.length - 1] === "inject" ? path2.slice(0, -1) : path2;
  }
  function visualizeAddonZodIssue(addon, issue, options = {}) {
    const { path: path2 = issue.path, maxCodeBlocks = 2 } = options;
    switch (issue.code) {
      case ZodIssueCode.unrecognized_keys:
        return issue.keys.map((key2) => visualizeAddonPath(addon, path2.concat(key2), { pointAt: "key" })).filter(Boolean).slice(0, maxCodeBlocks).concat(issue.keys.length > maxCodeBlocks ? `... ${issue.keys.length - maxCodeBlocks} more` : []).join("\n");
      default:
        return visualizeAddonPath(addon, path2, issue.params);
    }
  }
  function formatZodError(error2, options = {}) {
    const {
      pack,
      data: data2 = pack,
      context,
      path: path2 = context?.path ?? [],
      received = !!data2,
      sourceMap = {},
      docs = null
    } = options;
    let message = "\n" + error2.issues.map((issue) => {
      const relativePath = issue.path.slice(path2.length);
      const sourcePath = toSourcePath(data2, relativePath, sourceMap) ?? issue.path;
      let message2 = `• ${issue.message} at "${toPath(sourcePath)}"`;
      if (received && !("received" in (issue.params ?? {}))) {
        issue.params ??= {};
        issue.params.received = getPath$2(data2, stripInject(relativePath));
      }
      if (issue.unionErrors)
        message2 += indent(
          issue.unionErrors.map((e) => formatZodError(e, { ...options, received: false })).join(`
OR`)
        );
      if (!issue.unionErrors && pack) {
        const visualized = visualizeAddonZodIssue(pack, issue, { path: sourcePath });
        if (visualized) message2 += indent("\n" + visualized);
      }
      if ("args" in (issue.params ?? {}))
        message2 += indent(
          `
↪ Received arguments: ` + indent(
            "(" + objectInspect(
              sanitizeInjectable(issue.params.args),
              { indent: 2 }
            ).slice(1, -1) + ")"
          ).trim()
        );
      else if ("received" in (issue.params ?? {}))
        message2 += indent(
          `
↪ Received: ` + indent(
            objectInspect(
              sanitizeInjectable(issue.params.received),
              { indent: 2 }
            )
          ).trim()
        );
      if (issue.params?.error)
        message2 += indent(
          `
↪ Original error: ` + issue.params.error.stack
        );
      return message2;
    }).join("\n");
    if (docs)
      message += indent(
        `
↪ See documentation: ` + docs
      );
    return message;
  }
  function zodTransformErrorBoundary(transformFn) {
    return (value, ctx) => {
      try {
        return transformFn(value, ctx);
      } catch (error2) {
        ctx.addIssue({
          code: ZodIssueCode.custom,
          message: error2.message,
          params: { error: error2, received: value }
        });
        return NEVER;
      }
    };
  }
  const trustedFunctionSymbol = Symbol("trustedFunction");
  function trust(fn) {
    fn[trustedFunctionSymbol] = true;
    return fn;
  }
  const TrustedFunctionSchema = FunctionSchema.superRefine((value, ctx) => {
    if (!value[trustedFunctionSymbol]) ctx.addIssue({
      code: ZodIssueCode.custom,
      message: "Untrusted function",
      params: { received: value }
    });
  });
  function buildStyles(styles) {
    return Object.entries(styles).reduce(
      (str, [name2, value]) => str + `    ${name2.trim()}: ${String(value).trim()};
`,
      ""
    );
  }
  function buildCSS(data2, transformSelector = (s) => s) {
    return Object.entries(data2).reduce(
      (css2, [selector, styles], index2) => css2 + `${transformSelector(selector.trim(), index2)} {
${buildStyles(styles)}}
`,
      "\n"
    );
  }
  function executeWithZod(value, fn, context, options = {}) {
    const { path: path2 = [] } = options;
    try {
      return anyType().transform(fn).parse(value, { path: path2 });
    } catch (error2) {
      context.onError(
        new AnimationError(
          context.animation,
          formatZodError(error2, { pack: context.pack, data: value, context, path: path2 }),
          { module: context.module, pack: context.pack, type: context.type, context }
        )
      );
      context.instance.cancel(true);
    }
  }
  const zodErrorBoundarySymbol = Symbol("zodErrorBoundary");
  function zodErrorBoundary(fn, context, options = {}) {
    const { name: name2 = "untitled", ...opts } = options;
    const boundary = (...args) => executeWithZod(args, (args2, ctx) => {
      try {
        return fn(...args2);
      } catch (error2) {
        ctx.addIssue({
          code: ZodIssueCode.custom,
          message: `An error occurred while executing ${name2 ? `'${name2}'` : "an external function"}`,
          params: { error: error2, args: args2 }
        });
        return NEVER;
      }
    }, context, opts);
    boundary[zodErrorBoundarySymbol] = name2;
    return trust(boundary);
  }
  /**
   * anime.js - ESM
   * @version v4.1.3
   * @author Julian Garnier
   * @license MIT
   * @copyright (c) 2025 Julian Garnier
   * @see https://animejs.com
   */
  const isBrowser = typeof window !== "undefined";
  const doc = isBrowser ? document : null;
  const tweenTypes = {
    OBJECT: 0,
    ATTRIBUTE: 1,
    CSS: 2,
    TRANSFORM: 3,
    CSS_VAR: 4
  };
  const valueTypes = {
    NUMBER: 0,
    UNIT: 1,
    COLOR: 2,
    COMPLEX: 3
  };
  const tickModes = {
    NONE: 0,
    AUTO: 1,
    FORCE: 2
  };
  const compositionTypes = {
    replace: 0,
    none: 1,
    blend: 2
  };
  const isRegisteredTargetSymbol = Symbol();
  const isDomSymbol = Symbol();
  const isSvgSymbol = Symbol();
  const transformsSymbol = Symbol();
  const morphPointsSymbol = Symbol();
  const proxyTargetSymbol = Symbol();
  const minValue = 1e-11;
  const maxValue = 1e12;
  const K = 1e3;
  const maxFps = 120;
  const emptyString = "";
  const shortTransforms = /* @__PURE__ */ (() => {
    const map = /* @__PURE__ */ new Map();
    map.set("x", "translateX");
    map.set("y", "translateY");
    map.set("z", "translateZ");
    return map;
  })();
  const validTransforms = [
    "translateX",
    "translateY",
    "translateZ",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "scale",
    "scaleX",
    "scaleY",
    "scaleZ",
    "skew",
    "skewX",
    "skewY",
    "perspective",
    "matrix",
    "matrix3d"
  ];
  const transformsFragmentStrings = /* @__PURE__ */ validTransforms.reduce((a, v) => ({ ...a, [v]: v + "(" }), {});
  const noop = () => {
  };
  const hexTestRgx = /(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i;
  const rgbExecRgx = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i;
  const rgbaExecRgx = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
  const hslExecRgx = /hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i;
  const hslaExecRgx = /hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
  const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:e[-+]?\d)?/gi;
  const unitsExecRgx = /^([-+]?\d*\.?\d+(?:e[-+]?\d+)?)([a-z]+|%)$/i;
  const lowerCaseRgx = /([a-z])([A-Z])/g;
  const transformsExecRgx = /(\w+)(\([^)]+\)+)/g;
  const relativeValuesExecRgx = /(\*=|\+=|-=)/;
  const defaults = {
    id: null,
    keyframes: null,
    playbackEase: null,
    playbackRate: 1,
    frameRate: maxFps,
    loop: 0,
    reversed: false,
    alternate: false,
    autoplay: true,
    duration: K,
    delay: 0,
    loopDelay: 0,
    ease: "out(2)",
    composition: compositionTypes.replace,
    modifier: (v) => v,
    onBegin: noop,
    onBeforeUpdate: noop,
    onUpdate: noop,
    onLoop: noop,
    onPause: noop,
    onComplete: noop,
    onRender: noop
  };
  const scope = {
    /** @type {Document|DOMTarget} */
    root: doc
  };
  const globals = {
    /** @type {DefaultsParams} */
    defaults,
    /** @type {Number} */
    precision: 4,
    /** @type {Number} equals 1 in ms mode, 0.001 in s mode */
    timeScale: 1,
    /** @type {Number} */
    tickThreshold: 200
  };
  const toLowerCase = (str) => str.replace(lowerCaseRgx, "$1-$2").toLowerCase();
  const stringStartsWith = (str, sub) => str.indexOf(sub) === 0;
  const now = Date.now;
  const isArr = Array.isArray;
  const isObj = (a) => a && a.constructor === Object;
  const isNum = (a) => typeof a === "number" && !isNaN(a);
  const isStr = (a) => typeof a === "string";
  const isFnc = (a) => typeof a === "function";
  const isUnd = (a) => typeof a === "undefined";
  const isNil = (a) => isUnd(a) || a === null;
  const isSvg = (a) => isBrowser && a instanceof SVGElement;
  const isHex = (a) => hexTestRgx.test(a);
  const isRgb = (a) => stringStartsWith(a, "rgb");
  const isHsl = (a) => stringStartsWith(a, "hsl");
  const isCol = (a) => isHex(a) || isRgb(a) || isHsl(a);
  const isKey = (a) => !globals.defaults.hasOwnProperty(a);
  const parseNumber = (str) => isStr(str) ? parseFloat(
    /** @type {String} */
    str
  ) : (
    /** @type {Number} */
    str
  );
  const pow = Math.pow;
  const sqrt = Math.sqrt;
  const sin = Math.sin;
  const cos = Math.cos;
  const abs = Math.abs;
  const ceil = Math.ceil;
  const floor = Math.floor;
  const asin = Math.asin;
  const max = Math.max;
  const atan2 = Math.atan2;
  const PI = Math.PI;
  const _round = Math.round;
  const clamp = (v, min, max2) => v < min ? min : v > max2 ? max2 : v;
  const powCache = {};
  const round = (v, decimalLength) => {
    if (decimalLength < 0) return v;
    if (!decimalLength) return _round(v);
    let p = powCache[decimalLength];
    if (!p) p = powCache[decimalLength] = 10 ** decimalLength;
    return _round(v * p) / p;
  };
  const snap = (v, increment2) => isArr(increment2) ? increment2.reduce((closest, cv) => abs(cv - v) < abs(closest - v) ? cv : closest) : increment2 ? _round(v / increment2) * increment2 : v;
  const interpolate = (start, end, progress) => start + (end - start) * progress;
  const random = (min, max2, decimalLength) => {
    const m = 10 ** (decimalLength || 0);
    return floor((Math.random() * (max2 - min + 1 / m) + min) * m) / m;
  };
  const shuffle = (items2) => {
    let m = items2.length, t, i;
    while (m) {
      i = random(0, --m);
      t = items2[m];
      items2[m] = items2[i];
      items2[i] = t;
    }
    return items2;
  };
  const clampInfinity = (v) => v === Infinity ? maxValue : v === -Infinity ? -1e12 : v;
  const normalizeTime = (v) => v <= minValue ? minValue : clampInfinity(round(v, 11));
  const cloneArray = (a) => isArr(a) ? [...a] : a;
  const mergeObjects = (o1, o2) => {
    const merged = (
      /** @type {T & U} */
      { ...o1 }
    );
    for (let p in o2) {
      const o1p = (
        /** @type {T & U} */
        o1[p]
      );
      merged[p] = isUnd(o1p) ? (
        /** @type {T & U} */
        o2[p]
      ) : o1p;
    }
    return merged;
  };
  const forEachChildren = (parent, callback, reverse, prevProp = "_prev", nextProp = "_next") => {
    let next = parent._head;
    let adjustedNextProp = nextProp;
    if (reverse) {
      next = parent._tail;
      adjustedNextProp = prevProp;
    }
    while (next) {
      const currentNext = next[adjustedNextProp];
      callback(next);
      next = currentNext;
    }
  };
  const removeChild = (parent, child, prevProp = "_prev", nextProp = "_next") => {
    const prev = child[prevProp];
    const next = child[nextProp];
    prev ? prev[nextProp] = next : parent._head = next;
    next ? next[prevProp] = prev : parent._tail = prev;
    child[prevProp] = null;
    child[nextProp] = null;
  };
  const addChild = (parent, child, sortMethod, prevProp = "_prev", nextProp = "_next") => {
    let prev = parent._tail;
    while (prev && sortMethod && sortMethod(prev, child)) prev = prev[prevProp];
    const next = prev ? prev[nextProp] : parent._head;
    prev ? prev[nextProp] = child : parent._head = child;
    next ? next[prevProp] = child : parent._tail = child;
    child[prevProp] = prev;
    child[nextProp] = next;
  };
  const createRefreshable = (constructor) => {
    let tracked;
    return (...args) => {
      let currentIteration, currentIterationProgress, reversed, alternate;
      if (tracked) {
        currentIteration = tracked.currentIteration;
        currentIterationProgress = tracked.iterationProgress;
        reversed = tracked.reversed;
        alternate = tracked._alternate;
        tracked.revert();
      }
      const cleanup = constructor(...args);
      if (cleanup && !isFnc(cleanup) && cleanup.revert) tracked = cleanup;
      if (!isUnd(currentIterationProgress)) {
        tracked.currentIteration = currentIteration;
        tracked.iterationProgress = (alternate ? !(currentIteration % 2) ? reversed : !reversed : reversed) ? 1 - currentIterationProgress : currentIterationProgress;
      }
      return cleanup || noop;
    };
  };
  class Clock {
    /** @param {Number} [initTime] */
    constructor(initTime = 0) {
      this.deltaTime = 0;
      this._currentTime = initTime;
      this._elapsedTime = initTime;
      this._startTime = initTime;
      this._lastTime = initTime;
      this._scheduledTime = 0;
      this._frameDuration = round(K / maxFps, 0);
      this._fps = maxFps;
      this._speed = 1;
      this._hasChildren = false;
      this._head = null;
      this._tail = null;
    }
    get fps() {
      return this._fps;
    }
    set fps(frameRate) {
      const previousFrameDuration = this._frameDuration;
      const fr = +frameRate;
      const fps = fr < minValue ? minValue : fr;
      const frameDuration = round(K / fps, 0);
      this._fps = fps;
      this._frameDuration = frameDuration;
      this._scheduledTime += frameDuration - previousFrameDuration;
    }
    get speed() {
      return this._speed;
    }
    set speed(playbackRate) {
      const pbr = +playbackRate;
      this._speed = pbr < minValue ? minValue : pbr;
    }
    /**
     * @param  {Number} time
     * @return {tickModes}
     */
    requestTick(time) {
      const scheduledTime = this._scheduledTime;
      const elapsedTime = this._elapsedTime;
      this._elapsedTime += time - elapsedTime;
      if (elapsedTime < scheduledTime) return tickModes.NONE;
      const frameDuration = this._frameDuration;
      const frameDelta = elapsedTime - scheduledTime;
      this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;
      return tickModes.AUTO;
    }
    /**
     * @param  {Number} time
     * @return {Number}
     */
    computeDeltaTime(time) {
      const delta = time - this._lastTime;
      this.deltaTime = delta;
      this._lastTime = time;
      return delta;
    }
  }
  const render = (tickable, time, muteCallbacks, internalRender, tickMode) => {
    const parent = tickable.parent;
    const duration = tickable.duration;
    const completed = tickable.completed;
    const iterationDuration = tickable.iterationDuration;
    const iterationCount = tickable.iterationCount;
    const _currentIteration = tickable._currentIteration;
    const _loopDelay = tickable._loopDelay;
    const _reversed = tickable._reversed;
    const _alternate = tickable._alternate;
    const _hasChildren = tickable._hasChildren;
    const tickableDelay = tickable._delay;
    const tickablePrevAbsoluteTime = tickable._currentTime;
    const tickableEndTime = tickableDelay + iterationDuration;
    const tickableAbsoluteTime = time - tickableDelay;
    const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);
    const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);
    const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;
    const isCurrentTimeAboveZero = tickableCurrentTime > 0;
    const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;
    const isSetter = duration <= minValue;
    const forcedTick = tickMode === tickModes.FORCE;
    let isOdd = 0;
    let iterationElapsedTime = tickableAbsoluteTime;
    let hasRendered = 0;
    if (iterationCount > 1) {
      const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));
      tickable._currentIteration = clamp(currentIteration, 0, iterationCount);
      if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;
      isOdd = tickable._currentIteration % 2;
      iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;
    }
    const isReversed = _reversed ^ (_alternate && isOdd);
    const _ease = (
      /** @type {Renderable} */
      tickable._ease
    );
    let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;
    if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;
    const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;
    tickable._currentTime = tickableAbsoluteTime;
    tickable._iterationTime = iterationTime;
    tickable.backwards = isRunningBackwards;
    if (isCurrentTimeAboveZero && !tickable.began) {
      tickable.began = true;
      if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
        tickable.onBegin(
          /** @type {CallbackArgument} */
          tickable
        );
      }
    } else if (tickableAbsoluteTime <= 0) {
      tickable.began = false;
    }
    if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {
      tickable.onLoop(
        /** @type {CallbackArgument} */
        tickable
      );
    }
    if (forcedTick || tickMode === tickModes.AUTO && (time >= tickableDelay && time <= tickableEndTime || // Normal render
    time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state
    time >= tickableEndTime && tickablePrevTime !== duration) || iterationTime >= tickableEndTime && tickablePrevTime !== duration || iterationTime <= tickableDelay && tickablePrevTime > 0 || time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation
    isCurrentTimeEqualOrAboveDuration && !completed && isSetter) {
      if (isCurrentTimeAboveZero) {
        tickable.computeDeltaTime(tickablePrevTime);
        if (!muteCallbacks) tickable.onBeforeUpdate(
          /** @type {CallbackArgument} */
          tickable
        );
      }
      if (!_hasChildren) {
        const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;
        const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;
        let tween = (
          /** @type {Tween} */
          /** @type {JSAnimation} */
          tickable._head
        );
        let tweenTarget;
        let tweenStyle;
        let tweenTargetTransforms;
        let tweenTargetTransformsProperties;
        let tweenTransformsNeedUpdate = 0;
        while (tween) {
          const tweenComposition = tween._composition;
          const tweenCurrentTime = tween._currentTime;
          const tweenChangeDuration = tween._changeDuration;
          const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;
          const tweenNextRep = tween._nextRep;
          const tweenPrevRep = tween._prevRep;
          const tweenHasComposition = tweenComposition !== compositionTypes.none;
          if ((forcedRender || (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) && (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)) && (!tweenHasComposition || !tween._isOverridden && (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) && (!tweenNextRep || (tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime)) && (!tweenPrevRep || (tweenPrevRep._isOverridden || absoluteTime >= tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration + tween._delay)))) {
            const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);
            const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);
            const tweenModifier = tween._modifier;
            const tweenValueType = tween._valueType;
            const tweenType = tween._tweenType;
            const tweenIsObject = tweenType === tweenTypes.OBJECT;
            const tweenIsNumber = tweenValueType === valueTypes.NUMBER;
            const tweenPrecision = tweenIsNumber && tweenIsObject || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;
            let value;
            let number2;
            if (tweenIsNumber) {
              value = number2 = /** @type {Number} */
              tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));
            } else if (tweenValueType === valueTypes.UNIT) {
              number2 = /** @type {Number} */
              tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));
              value = `${number2}${tween._unit}`;
            } else if (tweenValueType === valueTypes.COLOR) {
              const fn = tween._fromNumbers;
              const tn = tween._toNumbers;
              const r = round(clamp(
                /** @type {Number} */
                tweenModifier(interpolate(fn[0], tn[0], tweenProgress)),
                0,
                255
              ), 0);
              const g = round(clamp(
                /** @type {Number} */
                tweenModifier(interpolate(fn[1], tn[1], tweenProgress)),
                0,
                255
              ), 0);
              const b = round(clamp(
                /** @type {Number} */
                tweenModifier(interpolate(fn[2], tn[2], tweenProgress)),
                0,
                255
              ), 0);
              const a = clamp(
                /** @type {Number} */
                tweenModifier(round(interpolate(fn[3], tn[3], tweenProgress), tweenPrecision)),
                0,
                1
              );
              value = `rgba(${r},${g},${b},${a})`;
              if (tweenHasComposition) {
                const ns = tween._numbers;
                ns[0] = r;
                ns[1] = g;
                ns[2] = b;
                ns[3] = a;
              }
            } else if (tweenValueType === valueTypes.COMPLEX) {
              value = tween._strings[0];
              for (let j = 0, l = tween._toNumbers.length; j < l; j++) {
                const n = (
                  /** @type {Number} */
                  tweenModifier(round(interpolate(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision))
                );
                const s = tween._strings[j + 1];
                value += `${s ? n + s : n}`;
                if (tweenHasComposition) {
                  tween._numbers[j] = n;
                }
              }
            }
            if (tweenHasComposition) {
              tween._number = number2;
            }
            if (!internalRender && tweenComposition !== compositionTypes.blend) {
              const tweenProperty = tween.property;
              tweenTarget = tween.target;
              if (tweenIsObject) {
                tweenTarget[tweenProperty] = value;
              } else if (tweenType === tweenTypes.ATTRIBUTE) {
                tweenTarget.setAttribute(
                  tweenProperty,
                  /** @type {String} */
                  value
                );
              } else {
                tweenStyle = /** @type {DOMTarget} */
                tweenTarget.style;
                if (tweenType === tweenTypes.TRANSFORM) {
                  if (tweenTarget !== tweenTargetTransforms) {
                    tweenTargetTransforms = tweenTarget;
                    tweenTargetTransformsProperties = tweenTarget[transformsSymbol];
                  }
                  tweenTargetTransformsProperties[tweenProperty] = value;
                  tweenTransformsNeedUpdate = 1;
                } else if (tweenType === tweenTypes.CSS) {
                  tweenStyle[tweenProperty] = value;
                } else if (tweenType === tweenTypes.CSS_VAR) {
                  tweenStyle.setProperty(
                    tweenProperty,
                    /** @type {String} */
                    value
                  );
                }
              }
              if (isCurrentTimeAboveZero) hasRendered = 1;
            } else {
              tween._value = value;
            }
          }
          if (tweenTransformsNeedUpdate && tween._renderTransforms) {
            let str = emptyString;
            for (let key2 in tweenTargetTransformsProperties) {
              str += `${transformsFragmentStrings[key2]}${tweenTargetTransformsProperties[key2]}) `;
            }
            tweenStyle.transform = str;
            tweenTransformsNeedUpdate = 0;
          }
          tween = tween._next;
        }
        if (!muteCallbacks && hasRendered) {
          tickable.onRender(
            /** @type {JSAnimation} */
            tickable
          );
        }
      }
      if (!muteCallbacks && isCurrentTimeAboveZero) {
        tickable.onUpdate(
          /** @type {CallbackArgument} */
          tickable
        );
      }
    }
    if (parent && isSetter) {
      if (!muteCallbacks && (parent.began && !isRunningBackwards && tickableAbsoluteTime >= duration && !completed || isRunningBackwards && tickableAbsoluteTime <= minValue && completed)) {
        tickable.onComplete(
          /** @type {CallbackArgument} */
          tickable
        );
        tickable.completed = !isRunningBackwards;
      }
    } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {
      if (iterationCount === Infinity) {
        tickable._startTime += tickable.duration;
      } else if (tickable._currentIteration >= iterationCount - 1) {
        tickable.paused = true;
        if (!completed && !_hasChildren) {
          tickable.completed = true;
          if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
            tickable.onComplete(
              /** @type {CallbackArgument} */
              tickable
            );
            tickable._resolve(
              /** @type {CallbackArgument} */
              tickable
            );
          }
        }
      }
    } else {
      tickable.completed = false;
    }
    return hasRendered;
  };
  const tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {
    const _currentIteration = tickable._currentIteration;
    render(tickable, time, muteCallbacks, internalRender, tickMode);
    if (tickable._hasChildren) {
      const tl = (
        /** @type {Timeline} */
        tickable
      );
      const tlIsRunningBackwards = tl.backwards;
      const tlChildrenTime = internalRender ? time : tl._iterationTime;
      const tlCildrenTickTime = now();
      let tlChildrenHasRendered = 0;
      let tlChildrenHaveCompleted = true;
      if (!internalRender && tl._currentIteration !== _currentIteration) {
        const tlIterationDuration = tl.iterationDuration;
        forEachChildren(tl, (child) => {
          if (!tlIsRunningBackwards) {
            if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {
              render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);
            }
            child.began = false;
            child.completed = false;
          } else {
            const childDuration = child.duration;
            const childStartTime = child._offset + child._delay;
            const childEndTime = childStartTime + childDuration;
            if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {
              child.onComplete(child);
            }
          }
        });
        if (!muteCallbacks) tl.onLoop(
          /** @type {CallbackArgument} */
          tl
        );
      }
      forEachChildren(tl, (child) => {
        const childTime = round((tlChildrenTime - child._offset) * child._speed, 12);
        const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;
        tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);
        if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;
      }, tlIsRunningBackwards);
      if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(
        /** @type {CallbackArgument} */
        tl
      );
      if ((tlChildrenHaveCompleted || tlIsRunningBackwards) && tl._currentTime >= tl.duration) {
        tl.paused = true;
        if (!tl.completed) {
          tl.completed = true;
          if (!muteCallbacks) {
            tl.onComplete(
              /** @type {CallbackArgument} */
              tl
            );
            tl._resolve(
              /** @type {CallbackArgument} */
              tl
            );
          }
        }
      }
    }
  };
  const additive = {
    animation: null,
    update: noop
  };
  const addAdditiveAnimation = (lookups2) => {
    let animation = additive.animation;
    if (!animation) {
      animation = {
        duration: minValue,
        computeDeltaTime: noop,
        _offset: 0,
        _delay: 0,
        _head: null,
        _tail: null
      };
      additive.animation = animation;
      additive.update = () => {
        lookups2.forEach((propertyAnimation) => {
          for (let propertyName in propertyAnimation) {
            const tweens = propertyAnimation[propertyName];
            const lookupTween = tweens._head;
            if (lookupTween) {
              const valueType = lookupTween._valueType;
              const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;
              let additiveValue = lookupTween._fromNumber;
              let tween = tweens._tail;
              while (tween && tween !== lookupTween) {
                if (additiveValues) {
                  for (let i = 0, l = tween._numbers.length; i < l; i++) additiveValues[i] += tween._numbers[i];
                } else {
                  additiveValue += tween._number;
                }
                tween = tween._prevAdd;
              }
              lookupTween._toNumber = additiveValue;
              lookupTween._toNumbers = additiveValues;
            }
          }
        });
        render(animation, 1, 1, 0, tickModes.FORCE);
      };
    }
    return animation;
  };
  const engineTickMethod = /* @__PURE__ */ (() => isBrowser ? requestAnimationFrame : setImmediate)();
  const engineCancelMethod = /* @__PURE__ */ (() => isBrowser ? cancelAnimationFrame : clearImmediate)();
  class Engine extends Clock {
    /** @param {Number} [initTime] */
    constructor(initTime) {
      super(initTime);
      this.useDefaultMainLoop = true;
      this.pauseOnDocumentHidden = true;
      this.defaults = defaults;
      this.paused = true;
      this.reqId = 0;
    }
    update() {
      const time = this._currentTime = now();
      if (this.requestTick(time)) {
        this.computeDeltaTime(time);
        const engineSpeed = this._speed;
        const engineFps = this._fps;
        let activeTickable = (
          /** @type {Tickable} */
          this._head
        );
        while (activeTickable) {
          const nextTickable = activeTickable._next;
          if (!activeTickable.paused) {
            tick(
              activeTickable,
              (time - activeTickable._startTime) * activeTickable._speed * engineSpeed,
              0,
              // !muteCallbacks
              0,
              // !internalRender
              activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO
            );
          } else {
            removeChild(this, activeTickable);
            this._hasChildren = !!this._tail;
            activeTickable._running = false;
            if (activeTickable.completed && !activeTickable._cancelled) {
              activeTickable.cancel();
            }
          }
          activeTickable = nextTickable;
        }
        additive.update();
      }
    }
    wake() {
      if (this.useDefaultMainLoop && !this.reqId) {
        this.requestTick(now());
        this.reqId = engineTickMethod(tickEngine);
      }
      return this;
    }
    pause() {
      if (!this.reqId) return;
      this.paused = true;
      return killEngine();
    }
    resume() {
      if (!this.paused) return;
      this.paused = false;
      forEachChildren(this, (child) => child.resetTime());
      return this.wake();
    }
    // Getter and setter for speed
    get speed() {
      return this._speed * (globals.timeScale === 1 ? 1 : K);
    }
    set speed(playbackRate) {
      this._speed = playbackRate * globals.timeScale;
      forEachChildren(this, (child) => child.speed = child._speed);
    }
    // Getter and setter for timeUnit
    get timeUnit() {
      return globals.timeScale === 1 ? "ms" : "s";
    }
    set timeUnit(unit) {
      const secondsScale = 1e-3;
      const isSecond = unit === "s";
      const newScale = isSecond ? secondsScale : 1;
      if (globals.timeScale !== newScale) {
        globals.timeScale = newScale;
        globals.tickThreshold = 200 * newScale;
        const scaleFactor = isSecond ? secondsScale : K;
        this.defaults.duration *= scaleFactor;
        this._speed *= scaleFactor;
      }
    }
    // Getter and setter for precision
    get precision() {
      return globals.precision;
    }
    set precision(precision) {
      globals.precision = precision;
    }
  }
  const engine = /* @__PURE__ */ (() => {
    const engine2 = new Engine(now());
    return engine2;
  })();
  const tickEngine = () => {
    if (engine._head) {
      engine.reqId = engineTickMethod(tickEngine);
      engine.update();
    } else {
      engine.reqId = 0;
    }
  };
  const killEngine = () => {
    engineCancelMethod(
      /** @type {NodeJS.Immediate & Number} */
      engine.reqId
    );
    engine.reqId = 0;
    return engine;
  };
  const parseInlineTransforms = (target, propName, animationInlineStyles) => {
    const inlineTransforms = target.style.transform;
    let inlinedStylesPropertyValue;
    if (inlineTransforms) {
      const cachedTransforms = target[transformsSymbol];
      let t;
      while (t = transformsExecRgx.exec(inlineTransforms)) {
        const inlinePropertyName = t[1];
        const inlinePropertyValue = t[2].slice(1, -1);
        cachedTransforms[inlinePropertyName] = inlinePropertyValue;
        if (inlinePropertyName === propName) {
          inlinedStylesPropertyValue = inlinePropertyValue;
          if (animationInlineStyles) {
            animationInlineStyles[propName] = inlinePropertyValue;
          }
        }
      }
    }
    return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue : stringStartsWith(propName, "scale") ? "1" : stringStartsWith(propName, "rotate") || stringStartsWith(propName, "skew") ? "0deg" : "0px";
  };
  function getNodeList(v) {
    const n = isStr(v) ? scope.root.querySelectorAll(v) : v;
    if (n instanceof NodeList || n instanceof HTMLCollection) return n;
  }
  function parseTargets(targets) {
    if (isNil(targets)) return (
      /** @type {TargetsArray} */
      []
    );
    if (!isBrowser) return (
      /** @type {JSTargetsArray} */
      isArr(targets) && targets.flat(Infinity) || [targets]
    );
    if (isArr(targets)) {
      const flattened = targets.flat(Infinity);
      const parsed = [];
      for (let i = 0, l = flattened.length; i < l; i++) {
        const item = flattened[i];
        if (!isNil(item)) {
          const nodeList2 = getNodeList(item);
          if (nodeList2) {
            for (let j = 0, jl = nodeList2.length; j < jl; j++) {
              const subItem = nodeList2[j];
              if (!isNil(subItem)) {
                let isDuplicate = false;
                for (let k = 0, kl = parsed.length; k < kl; k++) {
                  if (parsed[k] === subItem) {
                    isDuplicate = true;
                    break;
                  }
                }
                if (!isDuplicate) {
                  parsed.push(subItem);
                }
              }
            }
          } else {
            let isDuplicate = false;
            for (let j = 0, jl = parsed.length; j < jl; j++) {
              if (parsed[j] === item) {
                isDuplicate = true;
                break;
              }
            }
            if (!isDuplicate) {
              parsed.push(item);
            }
          }
        }
      }
      return parsed;
    }
    const nodeList = getNodeList(targets);
    if (nodeList) return (
      /** @type {DOMTargetsArray} */
      Array.from(nodeList)
    );
    return (
      /** @type {TargetsArray} */
      [targets]
    );
  }
  function registerTargets(targets) {
    const parsedTargetsArray = parseTargets(targets);
    const parsedTargetsLength = parsedTargetsArray.length;
    if (parsedTargetsLength) {
      for (let i = 0; i < parsedTargetsLength; i++) {
        const target = parsedTargetsArray[i];
        if (!target[isRegisteredTargetSymbol]) {
          target[isRegisteredTargetSymbol] = true;
          const isSvgType = isSvg(target);
          const isDom = (
            /** @type {DOMTarget} */
            target.nodeType || isSvgType
          );
          if (isDom) {
            target[isDomSymbol] = true;
            target[isSvgSymbol] = isSvgType;
            target[transformsSymbol] = {};
          }
        }
      }
    }
    return parsedTargetsArray;
  }
  const getPath = (path2) => {
    const parsedTargets = parseTargets(path2);
    const $parsedSvg = (
      /** @type {SVGGeometryElement} */
      parsedTargets[0]
    );
    if (!$parsedSvg || !isSvg($parsedSvg)) return;
    return $parsedSvg;
  };
  const morphTo = (path2, precision = 0.33) => ($path1) => {
    const $path2 = (
      /** @type {SVGGeometryElement} */
      getPath(path2)
    );
    if (!$path2) return;
    const isPath = $path1.tagName === "path";
    const separator = isPath ? " " : ",";
    const previousPoints = $path1[morphPointsSymbol];
    if (previousPoints) $path1.setAttribute(isPath ? "d" : "points", previousPoints);
    let v1 = "", v2 = "";
    if (!precision) {
      v1 = $path1.getAttribute(isPath ? "d" : "points");
      v2 = $path2.getAttribute(isPath ? "d" : "points");
    } else {
      const length1 = (
        /** @type {SVGGeometryElement} */
        $path1.getTotalLength()
      );
      const length2 = $path2.getTotalLength();
      const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));
      for (let i = 0; i < maxPoints; i++) {
        const t = i / (maxPoints - 1);
        const pointOnPath1 = (
          /** @type {SVGGeometryElement} */
          $path1.getPointAtLength(length1 * t)
        );
        const pointOnPath2 = $path2.getPointAtLength(length2 * t);
        const prefix = isPath ? i === 0 ? "M" : "L" : "";
        v1 += prefix + round(pointOnPath1.x, 3) + separator + pointOnPath1.y + " ";
        v2 += prefix + round(pointOnPath2.x, 3) + separator + pointOnPath2.y + " ";
      }
    }
    $path1[morphPointsSymbol] = v2;
    return [v1, v2];
  };
  const getScaleFactor = ($el) => {
    let scaleFactor = 1;
    if ($el && $el.getCTM) {
      const ctm = $el.getCTM();
      if (ctm) {
        const scaleX = sqrt(ctm.a * ctm.a + ctm.b * ctm.b);
        const scaleY = sqrt(ctm.c * ctm.c + ctm.d * ctm.d);
        scaleFactor = (scaleX + scaleY) / 2;
      }
    }
    return scaleFactor;
  };
  const createDrawableProxy = ($el, start, end) => {
    const pathLength = K;
    const computedStyles = getComputedStyle($el);
    const strokeLineCap = computedStyles.strokeLinecap;
    const $scalled = computedStyles.vectorEffect === "non-scaling-stroke" ? $el : null;
    let currentCap = strokeLineCap;
    const proxy = new Proxy($el, {
      get(target, property) {
        const value = target[property];
        if (property === proxyTargetSymbol) return target;
        if (property === "setAttribute") {
          return (...args) => {
            if (args[0] === "draw") {
              const value2 = args[1];
              const values = value2.split(" ");
              const v1 = +values[0];
              const v2 = +values[1];
              const scaleFactor = getScaleFactor($scalled);
              const os = v1 * -1e3 * scaleFactor;
              const d1 = v2 * pathLength * scaleFactor + os;
              const d2 = pathLength * scaleFactor + (v1 === 0 && v2 === 1 || v1 === 1 && v2 === 0 ? 0 : 10 * scaleFactor) - d1;
              if (strokeLineCap !== "butt") {
                const newCap = v1 === v2 ? "butt" : strokeLineCap;
                if (currentCap !== newCap) {
                  target.style.strokeLinecap = `${newCap}`;
                  currentCap = newCap;
                }
              }
              target.setAttribute("stroke-dashoffset", `${os}`);
              target.setAttribute("stroke-dasharray", `${d1} ${d2}`);
            }
            return Reflect.apply(value, target, args);
          };
        }
        if (isFnc(value)) {
          return (...args) => Reflect.apply(value, target, args);
        } else {
          return value;
        }
      }
    });
    if ($el.getAttribute("pathLength") !== `${pathLength}`) {
      $el.setAttribute("pathLength", `${pathLength}`);
      proxy.setAttribute("draw", `${start} ${end}`);
    }
    return (
      /** @type {DrawableSVGGeometry} */
      proxy
    );
  };
  const createDrawable = (selector, start = 0, end = 0) => {
    const els = parseTargets(selector);
    return els.map(($el) => createDrawableProxy(
      /** @type {SVGGeometryElement} */
      $el,
      start,
      end
    ));
  };
  const getPathPoint = ($path, progress, lookup = 0) => {
    return $path.getPointAtLength(progress + lookup >= 1 ? progress + lookup : 0);
  };
  const getPathProgess = ($path, pathProperty) => {
    return ($el) => {
      const totalLength = +$path.getTotalLength();
      const inSvg = $el[isSvgSymbol];
      const ctm = $path.getCTM();
      return {
        from: 0,
        to: totalLength,
        /** @type {TweenModifier} */
        modifier: (progress) => {
          if (pathProperty === "a") {
            const p0 = getPathPoint($path, progress, -1);
            const p1 = getPathPoint($path, progress, 1);
            return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;
          } else {
            const p = getPathPoint($path, progress, 0);
            return pathProperty === "x" ? inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e : inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f;
          }
        }
      };
    };
  };
  const createMotionPath = (path2) => {
    const $path = getPath(path2);
    if (!$path) return;
    return {
      translateX: getPathProgess($path, "x"),
      translateY: getPathProgess($path, "y"),
      rotate: getPathProgess($path, "a")
    };
  };
  const cssReservedProperties = ["opacity", "rotate", "overflow", "color"];
  const isValidSVGAttribute = (el, propertyName) => {
    if (cssReservedProperties.includes(propertyName)) return false;
    if (el.getAttribute(propertyName) || propertyName in el) {
      if (propertyName === "scale") {
        const elParentNode = (
          /** @type {SVGGeometryElement} */
          /** @type {DOMTarget} */
          el.parentNode
        );
        return elParentNode && elParentNode.tagName === "filter";
      }
      return true;
    }
  };
  const svg$2 = {
    morphTo,
    createMotionPath,
    createDrawable
  };
  const rgbToRgba = (rgbValue) => {
    const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);
    const a = !isUnd(rgba[4]) ? +rgba[4] : 1;
    return [
      +rgba[1],
      +rgba[2],
      +rgba[3],
      a
    ];
  };
  const hexToRgba = (hexValue) => {
    const hexLength = hexValue.length;
    const isShort = hexLength === 4 || hexLength === 5;
    return [
      +("0x" + hexValue[1] + hexValue[isShort ? 1 : 2]),
      +("0x" + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),
      +("0x" + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),
      hexLength === 5 || hexLength === 9 ? +(+("0x" + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1
    ];
  };
  const hue2rgb = (p, q, t) => {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    return t < 1 / 6 ? p + (q - p) * 6 * t : t < 1 / 2 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;
  };
  const hslToRgba = (hslValue) => {
    const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);
    const h = +hsla[1] / 360;
    const s = +hsla[2] / 100;
    const l = +hsla[3] / 100;
    const a = !isUnd(hsla[4]) ? +hsla[4] : 1;
    let r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = round(hue2rgb(p, q, h + 1 / 3) * 255, 0);
      g = round(hue2rgb(p, q, h) * 255, 0);
      b = round(hue2rgb(p, q, h - 1 / 3) * 255, 0);
    }
    return [r, g, b, a];
  };
  const convertColorStringValuesToRgbaArray = (colorString) => {
    return isRgb(colorString) ? rgbToRgba(colorString) : isHex(colorString) ? hexToRgba(colorString) : isHsl(colorString) ? hslToRgba(colorString) : [0, 0, 0, 1];
  };
  const setValue = (targetValue, defaultValue) => {
    return isUnd(targetValue) ? defaultValue : targetValue;
  };
  const getFunctionValue = (value, target, index2, total, store) => {
    if (isFnc(value)) {
      const func = () => {
        const computed = (
          /** @type {Function} */
          value(target, index2, total)
        );
        return !isNaN(+computed) ? +computed : computed || 0;
      };
      if (store) {
        store.func = func;
      }
      return func();
    } else {
      return value;
    }
  };
  const getTweenType = (target, prop) => {
    return !target[isDomSymbol] ? tweenTypes.OBJECT : (
      // Handle SVG attributes
      target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE : (
        // Handle CSS Transform properties differently than CSS to allow individual animations
        validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM : (
          // CSS variables
          stringStartsWith(prop, "--") ? tweenTypes.CSS_VAR : (
            // All other CSS properties
            prop in /** @type {DOMTarget} */
            target.style ? tweenTypes.CSS : (
              // Handle other DOM Attributes
              prop in target ? tweenTypes.OBJECT : tweenTypes.ATTRIBUTE
            )
          )
        )
      )
    );
  };
  const getCSSValue = (target, propName, animationInlineStyles) => {
    const inlineStyles = target.style[propName];
    if (inlineStyles && animationInlineStyles) {
      animationInlineStyles[propName] = inlineStyles;
    }
    const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);
    return value === "auto" ? "0" : value;
  };
  const getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {
    const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);
    return type === tweenTypes.OBJECT ? target[propName] || 0 : type === tweenTypes.ATTRIBUTE ? (
      /** @type {DOMTarget} */
      target.getAttribute(propName)
    ) : type === tweenTypes.TRANSFORM ? parseInlineTransforms(
      /** @type {DOMTarget} */
      target,
      propName,
      animationInlineStyles
    ) : type === tweenTypes.CSS_VAR ? getCSSValue(
      /** @type {DOMTarget} */
      target,
      propName,
      animationInlineStyles
    ).trimStart() : getCSSValue(
      /** @type {DOMTarget} */
      target,
      propName,
      animationInlineStyles
    );
  };
  const getRelativeValue = (x, y, operator) => {
    return operator === "-" ? x - y : operator === "+" ? x + y : x * y;
  };
  const createDecomposedValueTargetObject = () => {
    return {
      /** @type {valueTypes} */
      t: valueTypes.NUMBER,
      n: 0,
      u: null,
      o: null,
      d: null,
      s: null
    };
  };
  const decomposeRawValue = (rawValue, targetObject) => {
    targetObject.t = valueTypes.NUMBER;
    targetObject.n = 0;
    targetObject.u = null;
    targetObject.o = null;
    targetObject.d = null;
    targetObject.s = null;
    if (!rawValue) return targetObject;
    const num = +rawValue;
    if (!isNaN(num)) {
      targetObject.n = num;
      return targetObject;
    } else {
      let str = (
        /** @type {String} */
        rawValue
      );
      if (str[1] === "=") {
        targetObject.o = str[0];
        str = str.slice(2);
      }
      const unitMatch = str.includes(" ") ? false : unitsExecRgx.exec(str);
      if (unitMatch) {
        targetObject.t = valueTypes.UNIT;
        targetObject.n = +unitMatch[1];
        targetObject.u = unitMatch[2];
        return targetObject;
      } else if (targetObject.o) {
        targetObject.n = +str;
        return targetObject;
      } else if (isCol(str)) {
        targetObject.t = valueTypes.COLOR;
        targetObject.d = convertColorStringValuesToRgbaArray(str);
        return targetObject;
      } else {
        const matchedNumbers = str.match(digitWithExponentRgx);
        targetObject.t = valueTypes.COMPLEX;
        targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];
        targetObject.s = str.split(digitWithExponentRgx) || [];
        return targetObject;
      }
    }
  };
  const decomposeTweenValue = (tween, targetObject) => {
    targetObject.t = tween._valueType;
    targetObject.n = tween._toNumber;
    targetObject.u = tween._unit;
    targetObject.o = null;
    targetObject.d = cloneArray(tween._toNumbers);
    targetObject.s = cloneArray(tween._strings);
    return targetObject;
  };
  const decomposedOriginalValue = createDecomposedValueTargetObject();
  const lookups = {
    /** @type {TweenReplaceLookups} */
    _rep: /* @__PURE__ */ new WeakMap(),
    /** @type {TweenAdditiveLookups} */
    _add: /* @__PURE__ */ new Map()
  };
  const getTweenSiblings = (target, property, lookup = "_rep") => {
    const lookupMap = lookups[lookup];
    let targetLookup = lookupMap.get(target);
    if (!targetLookup) {
      targetLookup = {};
      lookupMap.set(target, targetLookup);
    }
    return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {
      _head: null,
      _tail: null
    };
  };
  const addTweenSortMethod = (p, c) => {
    return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;
  };
  const overrideTween = (tween) => {
    tween._isOverlapped = 1;
    tween._isOverridden = 1;
    tween._changeDuration = minValue;
    tween._currentTime = minValue;
  };
  const composeTween = (tween, siblings) => {
    const tweenCompositionType = tween._composition;
    if (tweenCompositionType === compositionTypes.replace) {
      const tweenAbsStartTime = tween._absoluteStartTime;
      addChild(siblings, tween, addTweenSortMethod, "_prevRep", "_nextRep");
      const prevSibling = tween._prevRep;
      if (prevSibling) {
        const prevParent = prevSibling.parent;
        const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;
        if (
          // Check if the previous tween is from a different animation
          tween.parent.id !== prevParent.id && // Check if the animation has loops
          prevParent.iterationCount > 1 && // Check if _absoluteChangeEndTime of last loop overlaps the current tween
          prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime
        ) {
          overrideTween(prevSibling);
          let prevPrevSibling = prevSibling._prevRep;
          while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {
            overrideTween(prevPrevSibling);
            prevPrevSibling = prevPrevSibling._prevRep;
          }
        }
        const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;
        if (prevAbsEndTime > absoluteUpdateStartTime) {
          const prevChangeStartTime = prevSibling._startTime;
          const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);
          const updatedPrevChangeDuration = round(absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime, 12);
          prevSibling._changeDuration = updatedPrevChangeDuration;
          prevSibling._currentTime = updatedPrevChangeDuration;
          prevSibling._isOverlapped = 1;
          if (updatedPrevChangeDuration < minValue) {
            overrideTween(prevSibling);
          }
        }
        let pausePrevParentAnimation = true;
        forEachChildren(prevParent, (t) => {
          if (!t._isOverlapped) pausePrevParentAnimation = false;
        });
        if (pausePrevParentAnimation) {
          const prevParentTL = prevParent.parent;
          if (prevParentTL) {
            let pausePrevParentTL = true;
            forEachChildren(prevParentTL, (a) => {
              if (a !== prevParent) {
                forEachChildren(a, (t) => {
                  if (!t._isOverlapped) pausePrevParentTL = false;
                });
              }
            });
            if (pausePrevParentTL) {
              prevParentTL.cancel();
            }
          } else {
            prevParent.cancel();
          }
        }
      }
    } else if (tweenCompositionType === compositionTypes.blend) {
      const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, "_add");
      const additiveAnimation = addAdditiveAnimation(lookups._add);
      let lookupTween = additiveTweenSiblings._head;
      if (!lookupTween) {
        lookupTween = { ...tween };
        lookupTween._composition = compositionTypes.replace;
        lookupTween._updateDuration = minValue;
        lookupTween._startTime = 0;
        lookupTween._numbers = cloneArray(tween._fromNumbers);
        lookupTween._number = 0;
        lookupTween._next = null;
        lookupTween._prev = null;
        addChild(additiveTweenSiblings, lookupTween);
        addChild(additiveAnimation, lookupTween);
      }
      const toNumber = tween._toNumber;
      tween._fromNumber = lookupTween._fromNumber - toNumber;
      tween._toNumber = 0;
      tween._numbers = cloneArray(tween._fromNumbers);
      tween._number = 0;
      lookupTween._fromNumber = toNumber;
      if (tween._toNumbers) {
        const toNumbers = cloneArray(tween._toNumbers);
        if (toNumbers) {
          toNumbers.forEach((value, i) => {
            tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;
            tween._toNumbers[i] = 0;
          });
        }
        lookupTween._fromNumbers = toNumbers;
      }
      addChild(additiveTweenSiblings, tween, null, "_prevAdd", "_nextAdd");
    }
    return tween;
  };
  const removeTweenSliblings = (tween) => {
    const tweenComposition = tween._composition;
    if (tweenComposition !== compositionTypes.none) {
      const tweenTarget = tween.target;
      const tweenProperty = tween.property;
      const replaceTweensLookup = lookups._rep;
      const replaceTargetProps = replaceTweensLookup.get(tweenTarget);
      const tweenReplaceSiblings = replaceTargetProps[tweenProperty];
      removeChild(tweenReplaceSiblings, tween, "_prevRep", "_nextRep");
      if (tweenComposition === compositionTypes.blend) {
        const addTweensLookup = lookups._add;
        const addTargetProps = addTweensLookup.get(tweenTarget);
        if (!addTargetProps) return;
        const additiveTweenSiblings = addTargetProps[tweenProperty];
        const additiveAnimation = additive.animation;
        removeChild(additiveTweenSiblings, tween, "_prevAdd", "_nextAdd");
        const lookupTween = additiveTweenSiblings._head;
        if (lookupTween && lookupTween === additiveTweenSiblings._tail) {
          removeChild(additiveTweenSiblings, lookupTween, "_prevAdd", "_nextAdd");
          removeChild(additiveAnimation, lookupTween);
          let shouldClean = true;
          for (let prop in addTargetProps) {
            if (addTargetProps[prop]._head) {
              shouldClean = false;
              break;
            }
          }
          if (shouldClean) {
            addTweensLookup.delete(tweenTarget);
          }
        }
      }
    }
    return tween;
  };
  const resetTimerProperties = (timer) => {
    timer.paused = true;
    timer.began = false;
    timer.completed = false;
    return timer;
  };
  const reviveTimer = (timer) => {
    if (!timer._cancelled) return timer;
    if (timer._hasChildren) {
      forEachChildren(timer, reviveTimer);
    } else {
      forEachChildren(timer, (tween) => {
        if (tween._composition !== compositionTypes.none) {
          composeTween(tween, getTweenSiblings(tween.target, tween.property));
        }
      });
    }
    timer._cancelled = 0;
    return timer;
  };
  let timerId = 0;
  class Timer extends Clock {
    /**
     * @param {TimerParams} [parameters]
     * @param {Timeline} [parent]
     * @param {Number} [parentPosition]
     */
    constructor(parameters = {}, parent = null, parentPosition = 0) {
      super(0);
      const {
        id,
        delay,
        duration,
        reversed,
        alternate,
        loop,
        loopDelay,
        autoplay,
        frameRate,
        playbackRate,
        onComplete,
        onLoop,
        onPause,
        onBegin,
        onBeforeUpdate,
        onUpdate
      } = parameters;
      const timerInitTime = parent ? 0 : engine._elapsedTime;
      const timerDefaults = parent ? parent.defaults : globals.defaults;
      const timerDelay = (
        /** @type {Number} */
        isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay
      );
      const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;
      const timerLoop = setValue(loop, timerDefaults.loop);
      const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);
      const timerIterationCount = timerLoop === true || timerLoop === Infinity || /** @type {Number} */
      timerLoop < 0 ? Infinity : (
        /** @type {Number} */
        timerLoop + 1
      );
      let offsetPosition = 0;
      if (parent) {
        offsetPosition = parentPosition;
      } else {
        if (!engine.reqId) engine.requestTick(now());
        offsetPosition = (engine._elapsedTime - engine._startTime) * globals.timeScale;
      }
      this.id = !isUnd(id) ? id : ++timerId;
      this.parent = parent;
      this.duration = clampInfinity((timerDuration + timerLoopDelay) * timerIterationCount - timerLoopDelay) || minValue;
      this.backwards = false;
      this.paused = true;
      this.began = false;
      this.completed = false;
      this.onBegin = onBegin || timerDefaults.onBegin;
      this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;
      this.onUpdate = onUpdate || timerDefaults.onUpdate;
      this.onLoop = onLoop || timerDefaults.onLoop;
      this.onPause = onPause || timerDefaults.onPause;
      this.onComplete = onComplete || timerDefaults.onComplete;
      this.iterationDuration = timerDuration;
      this.iterationCount = timerIterationCount;
      this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);
      this._offset = offsetPosition;
      this._delay = timerDelay;
      this._loopDelay = timerLoopDelay;
      this._iterationTime = 0;
      this._currentIteration = 0;
      this._resolve = noop;
      this._running = false;
      this._reversed = +setValue(reversed, timerDefaults.reversed);
      this._reverse = this._reversed;
      this._cancelled = 0;
      this._alternate = setValue(alternate, timerDefaults.alternate);
      this._prev = null;
      this._next = null;
      this._elapsedTime = timerInitTime;
      this._startTime = timerInitTime;
      this._lastTime = timerInitTime;
      this._fps = setValue(frameRate, timerDefaults.frameRate);
      this._speed = setValue(playbackRate, timerDefaults.playbackRate);
    }
    get cancelled() {
      return !!this._cancelled;
    }
    /** @param {Boolean} cancelled  */
    set cancelled(cancelled) {
      cancelled ? this.cancel() : this.reset(1).play();
    }
    get currentTime() {
      return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);
    }
    /** @param {Number} time  */
    set currentTime(time) {
      const paused = this.paused;
      this.pause().seek(+time);
      if (!paused) this.resume();
    }
    get iterationCurrentTime() {
      return round(this._iterationTime, globals.precision);
    }
    /** @param {Number} time  */
    set iterationCurrentTime(time) {
      this.currentTime = this.iterationDuration * this._currentIteration + time;
    }
    get progress() {
      return clamp(round(this._currentTime / this.duration, 10), 0, 1);
    }
    /** @param {Number} progress  */
    set progress(progress) {
      this.currentTime = this.duration * progress;
    }
    get iterationProgress() {
      return clamp(round(this._iterationTime / this.iterationDuration, 10), 0, 1);
    }
    /** @param {Number} progress  */
    set iterationProgress(progress) {
      const iterationDuration = this.iterationDuration;
      this.currentTime = iterationDuration * this._currentIteration + iterationDuration * progress;
    }
    get currentIteration() {
      return this._currentIteration;
    }
    /** @param {Number} iterationCount  */
    set currentIteration(iterationCount) {
      this.currentTime = this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1);
    }
    get reversed() {
      return !!this._reversed;
    }
    /** @param {Boolean} reverse  */
    set reversed(reverse) {
      reverse ? this.reverse() : this.play();
    }
    get speed() {
      return super.speed;
    }
    /** @param {Number} playbackRate  */
    set speed(playbackRate) {
      super.speed = playbackRate;
      this.resetTime();
    }
    /**
     * @param  {Number} internalRender
     * @return {this}
     */
    reset(internalRender = 0) {
      reviveTimer(this);
      if (this._reversed && !this._reverse) this.reversed = false;
      this._iterationTime = this.iterationDuration;
      tick(this, 0, 1, internalRender, tickModes.FORCE);
      resetTimerProperties(this);
      if (this._hasChildren) {
        forEachChildren(this, resetTimerProperties);
      }
      return this;
    }
    /**
     * @param  {Number} internalRender
     * @return {this}
     */
    init(internalRender = 0) {
      this.fps = this._fps;
      this.speed = this._speed;
      if (!internalRender && this._hasChildren) {
        tick(this, this.duration, 1, internalRender, tickModes.FORCE);
      }
      this.reset(internalRender);
      const autoplay = this._autoplay;
      if (autoplay === true) {
        this.resume();
      } else if (autoplay && !isUnd(
        /** @type {ScrollObserver} */
        autoplay.linked
      )) {
        autoplay.link(this);
      }
      return this;
    }
    /** @return {this} */
    resetTime() {
      const timeScale = 1 / (this._speed * engine._speed);
      this._startTime = now() - (this._currentTime + this._delay) * timeScale;
      return this;
    }
    /** @return {this} */
    pause() {
      if (this.paused) return this;
      this.paused = true;
      this.onPause(this);
      return this;
    }
    /** @return {this} */
    resume() {
      if (!this.paused) return this;
      this.paused = false;
      if (this.duration <= minValue && !this._hasChildren) {
        tick(this, minValue, 0, 0, tickModes.FORCE);
      } else {
        if (!this._running) {
          addChild(engine, this);
          engine._hasChildren = true;
          this._running = true;
        }
        this.resetTime();
        this._startTime -= 12;
        engine.wake();
      }
      return this;
    }
    /** @return {this} */
    restart() {
      return this.reset(0).resume();
    }
    /**
     * @param  {Number} time
     * @param  {Boolean|Number} [muteCallbacks]
     * @param  {Boolean|Number} [internalRender]
     * @return {this}
     */
    seek(time, muteCallbacks = 0, internalRender = 0) {
      reviveTimer(this);
      this.completed = false;
      const isPaused = this.paused;
      this.paused = true;
      tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);
      return isPaused ? this : this.resume();
    }
    /** @return {this} */
    alternate() {
      const reversed = this._reversed;
      const count = this.iterationCount;
      const duration = this.iterationDuration;
      const iterations = count === Infinity ? floor(maxValue / duration) : count;
      this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);
      if (count === Infinity) {
        this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;
      } else {
        this.seek(duration * iterations - this._currentTime);
      }
      this.resetTime();
      return this;
    }
    /** @return {this} */
    play() {
      if (this._reversed) this.alternate();
      return this.resume();
    }
    /** @return {this} */
    reverse() {
      if (!this._reversed) this.alternate();
      return this.resume();
    }
    // TODO: Move all the animation / tweens / children related code to Animation / Timeline
    /** @return {this} */
    cancel() {
      if (this._hasChildren) {
        forEachChildren(this, (child) => child.cancel(), true);
      } else {
        forEachChildren(this, removeTweenSliblings);
      }
      this._cancelled = 1;
      return this.pause();
    }
    /**
     * @param  {Number} newDuration
     * @return {this}
     */
    stretch(newDuration) {
      const currentDuration = this.duration;
      const normlizedDuration = normalizeTime(newDuration);
      if (currentDuration === normlizedDuration) return this;
      const timeScale = newDuration / currentDuration;
      const isSetter = newDuration <= minValue;
      this.duration = isSetter ? minValue : normlizedDuration;
      this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);
      this._offset *= timeScale;
      this._delay *= timeScale;
      this._loopDelay *= timeScale;
      return this;
    }
    /**
      * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary
      * @return {this}
      */
    revert() {
      tick(this, 0, 1, 0, tickModes.AUTO);
      const ap = (
        /** @type {ScrollObserver} */
        this._autoplay
      );
      if (ap && ap.linked && ap.linked === this) ap.revert();
      return this.cancel();
    }
    /**
      * Imediatly completes the timer, cancels it and triggers the onComplete callback
      * @return {this}
      */
    complete() {
      return this.seek(this.duration).cancel();
    }
    /**
     * @param  {Callback<this>} [callback]
     * @return {Promise}
     */
    then(callback = noop) {
      const then = this.then;
      const onResolve = () => {
        this.then = null;
        callback(this);
        this.then = then;
        this._resolve = noop;
      };
      return new Promise((r) => {
        this._resolve = () => r(onResolve());
        if (this.completed) this._resolve();
        return this;
      });
    }
  }
  const createTimer = (parameters) => new Timer(parameters, null, 0).init();
  const none = (t) => t;
  const calcBezier = (aT, aA1, aA2) => (((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + 3 * aA1) * aT;
  const binarySubdivide = (aX, mX1, mX2) => {
    let aA = 0, aB = 1, currentX, currentT, i = 0;
    do {
      currentT = aA + (aB - aA) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (abs(currentX) > 1e-7 && ++i < 100);
    return currentT;
  };
  const cubicBezier = (mX1 = 0.5, mY1 = 0, mX2 = 0.5, mY2 = 1) => mX1 === mY1 && mX2 === mY2 ? none : (t) => t === 0 || t === 1 ? t : calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);
  const steps = (steps2 = 10, fromStart) => {
    const roundMethod = fromStart ? ceil : floor;
    return (t) => roundMethod(clamp(t, 0, 1) * steps2) * (1 / steps2);
  };
  const linear = (...args) => {
    const argsLength = args.length;
    if (!argsLength) return none;
    const totalPoints = argsLength - 1;
    const firstArg = args[0];
    const lastArg = args[totalPoints];
    const xPoints = [0];
    const yPoints = [parseNumber(firstArg)];
    for (let i = 1; i < totalPoints; i++) {
      const arg = args[i];
      const splitValue = isStr(arg) ? (
        /** @type {String} */
        arg.trim().split(" ")
      ) : [arg];
      const value = splitValue[0];
      const percent = splitValue[1];
      xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);
      yPoints.push(parseNumber(value));
    }
    yPoints.push(parseNumber(lastArg));
    xPoints.push(1);
    return function easeLinear(t) {
      for (let i = 1, l = xPoints.length; i < l; i++) {
        const currentX = xPoints[i];
        if (t <= currentX) {
          const prevX = xPoints[i - 1];
          const prevY = yPoints[i - 1];
          return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);
        }
      }
      return yPoints[yPoints.length - 1];
    };
  };
  const irregular = (length = 10, randomness = 1) => {
    const values = [0];
    const total = length - 1;
    for (let i = 1; i < total; i++) {
      const previousValue = values[i - 1];
      const spacing = i / total;
      const segmentEnd = (i + 1) / total;
      const randomVariation = spacing + (segmentEnd - spacing) * Math.random();
      const randomValue = spacing * (1 - randomness) + randomVariation * randomness;
      values.push(clamp(randomValue, previousValue, 1));
    }
    values.push(1);
    return linear(...values);
  };
  const halfPI = PI / 2;
  const doublePI = PI * 2;
  const easeInPower = (p = 1.68) => (t) => pow(t, +p);
  const easeInFunctions = {
    [emptyString]: easeInPower,
    Quad: easeInPower(2),
    Cubic: easeInPower(3),
    Quart: easeInPower(4),
    Quint: easeInPower(5),
    /** @type {EasingFunction} */
    Sine: (t) => 1 - cos(t * halfPI),
    /** @type {EasingFunction} */
    Circ: (t) => 1 - sqrt(1 - t * t),
    /** @type {EasingFunction} */
    Expo: (t) => t ? pow(2, 10 * t - 10) : 0,
    /** @type {EasingFunction} */
    Bounce: (t) => {
      let pow2, b = 4;
      while (t < ((pow2 = pow(2, --b)) - 1) / 11) ;
      return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);
    },
    /** @type {BackEasing} */
    Back: (overshoot = 1.70158) => (t) => (+overshoot + 1) * t * t * t - +overshoot * t * t,
    /** @type {ElasticEasing} */
    Elastic: (amplitude = 1, period = 0.3) => {
      const a = clamp(+amplitude, 1, 10);
      const p = clamp(+period, minValue, 2);
      const s = p / doublePI * asin(1 / a);
      const e = doublePI / p;
      return (t) => t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin((1 - t - s) * e);
    }
  };
  const easeTypes = {
    in: (easeIn) => (t) => easeIn(t),
    out: (easeIn) => (t) => 1 - easeIn(1 - t),
    inOut: (easeIn) => (t) => t < 0.5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,
    outIn: (easeIn) => (t) => t < 0.5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2
  };
  const parseEaseString = (string, easesFunctions, easesLookups) => {
    if (easesLookups[string]) return easesLookups[string];
    if (string.indexOf("(") <= -1) {
      const hasParams = easeTypes[string] || string.includes("Back") || string.includes("Elastic");
      const parsedFn = (
        /** @type {EasingFunction} */
        hasParams ? (
          /** @type {EasesFactory} */
          easesFunctions[string]()
        ) : easesFunctions[string]
      );
      return parsedFn ? easesLookups[string] = parsedFn : none;
    } else {
      const split = string.slice(0, -1).split("(");
      const parsedFn = (
        /** @type {EasesFactory} */
        easesFunctions[split[0]]
      );
      return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(",")) : none;
    }
  };
  const eases = /* @__PURE__ */ (() => {
    const list = { linear, irregular, steps, cubicBezier };
    for (let type in easeTypes) {
      for (let name2 in easeInFunctions) {
        const easeIn = easeInFunctions[name2];
        const easeType = easeTypes[type];
        list[type + name2] = /** @type {EasesFactory|EasingFunction} */
        name2 === emptyString || name2 === "Back" || name2 === "Elastic" ? (a, b) => easeType(
          /** @type {EasesFactory} */
          easeIn(a, b)
        ) : easeType(
          /** @type {EasingFunction} */
          easeIn
        );
      }
    }
    return (
      /** @type {EasesFunctions} */
      list
    );
  })();
  const JSEasesLookups = { linear: none };
  const parseEasings = (ease) => isFnc(ease) ? ease : isStr(ease) ? parseEaseString(
    /** @type {String} */
    ease,
    eases,
    JSEasesLookups
  ) : none;
  const propertyNamesCache = {};
  const sanitizePropertyName = (propertyName, target, tweenType) => {
    if (tweenType === tweenTypes.TRANSFORM) {
      const t = shortTransforms.get(propertyName);
      return t ? t : propertyName;
    } else if (tweenType === tweenTypes.CSS || // Handle special cases where properties like "strokeDashoffset" needs to be set as "stroke-dashoffset"
    // but properties like "baseFrequency" should stay in lowerCamelCase
    tweenType === tweenTypes.ATTRIBUTE && (isSvg(target) && propertyName in /** @type {DOMTarget} */
    target.style)) {
      const cachedPropertyName = propertyNamesCache[propertyName];
      if (cachedPropertyName) {
        return cachedPropertyName;
      } else {
        const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;
        propertyNamesCache[propertyName] = lowerCaseName;
        return lowerCaseName;
      }
    } else {
      return propertyName;
    }
  };
  const angleUnitsMap = { "deg": 1, "rad": 180 / PI, "turn": 360 };
  const convertedValuesCache = {};
  const convertValueUnit = (el, decomposedValue, unit, force = false) => {
    const currentUnit = decomposedValue.u;
    const currentNumber = decomposedValue.n;
    if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) {
      return decomposedValue;
    }
    const cachedKey = currentNumber + currentUnit + unit;
    const cached = convertedValuesCache[cachedKey];
    if (!isUnd(cached) && !force) {
      decomposedValue.n = cached;
    } else {
      let convertedValue;
      if (currentUnit in angleUnitsMap) {
        convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];
      } else {
        const baseline = 100;
        const tempEl = (
          /** @type {DOMTarget} */
          el.cloneNode()
        );
        const parentNode = el.parentNode;
        const parentEl = parentNode && parentNode !== doc ? parentNode : doc.body;
        parentEl.appendChild(tempEl);
        const elStyle = tempEl.style;
        elStyle.width = baseline + currentUnit;
        const currentUnitWidth = (
          /** @type {HTMLElement} */
          tempEl.offsetWidth || baseline
        );
        elStyle.width = baseline + unit;
        const newUnitWidth = (
          /** @type {HTMLElement} */
          tempEl.offsetWidth || baseline
        );
        const factor = currentUnitWidth / newUnitWidth;
        parentEl.removeChild(tempEl);
        convertedValue = factor * currentNumber;
      }
      decomposedValue.n = convertedValue;
      convertedValuesCache[cachedKey] = convertedValue;
    }
    decomposedValue.t === valueTypes.UNIT;
    decomposedValue.u = unit;
    return decomposedValue;
  };
  const cleanInlineStyles = (renderable) => {
    if (renderable._hasChildren) {
      forEachChildren(renderable, cleanInlineStyles, true);
    } else {
      const animation = (
        /** @type {JSAnimation} */
        renderable
      );
      animation.pause();
      forEachChildren(animation, (tween) => {
        const tweenProperty = tween.property;
        const tweenTarget = tween.target;
        if (tweenTarget[isDomSymbol]) {
          const targetStyle = (
            /** @type {DOMTarget} */
            tweenTarget.style
          );
          const originalInlinedValue = animation._inlineStyles[tweenProperty];
          if (tween._tweenType === tweenTypes.TRANSFORM) {
            const cachedTransforms = tweenTarget[transformsSymbol];
            if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {
              delete cachedTransforms[tweenProperty];
            } else {
              cachedTransforms[tweenProperty] = originalInlinedValue;
            }
            if (tween._renderTransforms) {
              if (!Object.keys(cachedTransforms).length) {
                targetStyle.removeProperty("transform");
              } else {
                let str = emptyString;
                for (let key2 in cachedTransforms) {
                  str += transformsFragmentStrings[key2] + cachedTransforms[key2] + ") ";
                }
                targetStyle.transform = str;
              }
            }
          } else {
            if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {
              targetStyle.removeProperty(tweenProperty);
            } else {
              targetStyle[tweenProperty] = originalInlinedValue;
            }
          }
          if (animation._tail === tween) {
            animation.targets.forEach((t) => {
              if (t.getAttribute && t.getAttribute("style") === emptyString) {
                t.removeAttribute("style");
              }
            });
          }
        }
      });
    }
    return renderable;
  };
  const fromTargetObject = createDecomposedValueTargetObject();
  const toTargetObject = createDecomposedValueTargetObject();
  const toFunctionStore = { func: null };
  const keyframesTargetArray = [null];
  const fastSetValuesArray = [null, null];
  const keyObjectTarget = { to: null };
  let tweenId = 0;
  let keyframes;
  let key;
  const generateKeyframes = (keyframes2, parameters) => {
    const properties2 = {};
    if (isArr(keyframes2)) {
      const propertyNames = [].concat(.../** @type {DurationKeyframes} */
      keyframes2.map((key2) => Object.keys(key2))).filter(isKey);
      for (let i = 0, l = propertyNames.length; i < l; i++) {
        const propName = propertyNames[i];
        const propArray = (
          /** @type {DurationKeyframes} */
          keyframes2.map((key2) => {
            const newKey = {};
            for (let p in key2) {
              const keyValue = (
                /** @type {TweenPropValue} */
                key2[p]
              );
              if (isKey(p)) {
                if (p === propName) {
                  newKey.to = keyValue;
                }
              } else {
                newKey[p] = keyValue;
              }
            }
            return newKey;
          })
        );
        properties2[propName] = /** @type {ArraySyntaxValue} */
        propArray;
      }
    } else {
      const totalDuration = (
        /** @type {Number} */
        setValue(parameters.duration, globals.defaults.duration)
      );
      const keys2 = Object.keys(keyframes2).map((key2) => {
        return { o: parseFloat(key2) / 100, p: keyframes2[key2] };
      }).sort((a, b) => a.o - b.o);
      keys2.forEach((key2) => {
        const offset = key2.o;
        const prop = key2.p;
        for (let name2 in prop) {
          if (isKey(name2)) {
            let propArray = (
              /** @type {Array} */
              properties2[name2]
            );
            if (!propArray) propArray = properties2[name2] = [];
            const duration = offset * totalDuration;
            let length = propArray.length;
            let prevKey = propArray[length - 1];
            const keyObj = { to: prop[name2] };
            let durProgress = 0;
            for (let i = 0; i < length; i++) {
              durProgress += propArray[i].duration;
            }
            if (length === 1) {
              keyObj.from = prevKey.to;
            }
            if (prop.ease) {
              keyObj.ease = prop.ease;
            }
            keyObj.duration = duration - (length ? durProgress : 0);
            propArray.push(keyObj);
          }
        }
        return key2;
      });
      for (let name2 in properties2) {
        const propArray = (
          /** @type {Array} */
          properties2[name2]
        );
        let prevEase;
        for (let i = 0, l = propArray.length; i < l; i++) {
          const prop = propArray[i];
          const currentEase = prop.ease;
          prop.ease = prevEase ? prevEase : void 0;
          prevEase = currentEase;
        }
        if (!propArray[0].duration) {
          propArray.shift();
        }
      }
    }
    return properties2;
  };
  class JSAnimation extends Timer {
    /**
     * @param {TargetsParam} targets
     * @param {AnimationParams} parameters
     * @param {Timeline} [parent]
     * @param {Number} [parentPosition]
     * @param {Boolean} [fastSet=false]
     * @param {Number} [index=0]
     * @param {Number} [length=0]
     */
    constructor(targets, parameters, parent, parentPosition, fastSet = false, index2 = 0, length = 0) {
      super(
        /** @type {TimerParams&AnimationParams} */
        parameters,
        parent,
        parentPosition
      );
      const parsedTargets = registerTargets(targets);
      const targetsLength = parsedTargets.length;
      const kfParams = (
        /** @type {AnimationParams} */
        parameters.keyframes
      );
      const params = (
        /** @type {AnimationParams} */
        kfParams ? mergeObjects(generateKeyframes(
          /** @type {DurationKeyframes} */
          kfParams,
          parameters
        ), parameters) : parameters
      );
      const {
        delay,
        duration,
        ease,
        playbackEase,
        modifier,
        composition,
        onRender
      } = params;
      const animDefaults = parent ? parent.defaults : globals.defaults;
      const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);
      const animEase = animaPlaybackEase ? parseEasings(animaPlaybackEase) : null;
      const hasSpring = !isUnd(ease) && !isUnd(
        /** @type {Spring} */
        ease.ease
      );
      const tEasing = hasSpring ? (
        /** @type {Spring} */
        ease.ease
      ) : setValue(ease, animEase ? "linear" : animDefaults.ease);
      const tDuration = hasSpring ? (
        /** @type {Spring} */
        ease.duration
      ) : setValue(duration, animDefaults.duration);
      const tDelay = setValue(delay, animDefaults.delay);
      const tModifier = modifier || animDefaults.modifier;
      const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;
      const animInlineStyles = {};
      const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);
      let iterationDuration = NaN;
      let iterationDelay = NaN;
      let animationAnimationLength = 0;
      let shouldTriggerRender = 0;
      for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {
        const target = parsedTargets[targetIndex];
        const ti = index2 || targetIndex;
        const tl = length || targetsLength;
        let lastTransformGroupIndex = NaN;
        let lastTransformGroupLength = NaN;
        for (let p in params) {
          if (isKey(p)) {
            const tweenType = getTweenType(target, p);
            const propName = sanitizePropertyName(p, target, tweenType);
            let propValue = params[p];
            const isPropValueArray = isArr(propValue);
            if (fastSet && !isPropValueArray) {
              fastSetValuesArray[0] = propValue;
              fastSetValuesArray[1] = propValue;
              propValue = fastSetValuesArray;
            }
            if (isPropValueArray) {
              const arrayLength = (
                /** @type {Array} */
                propValue.length
              );
              const isNotObjectValue = !isObj(propValue[0]);
              if (arrayLength === 2 && isNotObjectValue) {
                keyObjectTarget.to = /** @type {TweenParamValue} */
                /** @type {unknown} */
                propValue;
                keyframesTargetArray[0] = keyObjectTarget;
                keyframes = keyframesTargetArray;
              } else if (arrayLength > 2 && isNotObjectValue) {
                keyframes = [];
                propValue.forEach((v, i) => {
                  if (!i) {
                    fastSetValuesArray[0] = v;
                  } else if (i === 1) {
                    fastSetValuesArray[1] = v;
                    keyframes.push(fastSetValuesArray);
                  } else {
                    keyframes.push(v);
                  }
                });
              } else {
                keyframes = /** @type {Array.<TweenKeyValue>} */
                propValue;
              }
            } else {
              keyframesTargetArray[0] = propValue;
              keyframes = keyframesTargetArray;
            }
            let siblings = null;
            let prevTween = null;
            let firstTweenChangeStartTime = NaN;
            let lastTweenChangeEndTime = 0;
            let tweenIndex = 0;
            for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {
              const keyframe = keyframes[tweenIndex];
              if (isObj(keyframe)) {
                key = keyframe;
              } else {
                keyObjectTarget.to = /** @type {TweenParamValue} */
                keyframe;
                key = keyObjectTarget;
              }
              toFunctionStore.func = null;
              const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);
              let tweenToValue;
              if (isObj(computedToValue) && !isUnd(computedToValue.to)) {
                key = computedToValue;
                tweenToValue = computedToValue.to;
              } else {
                tweenToValue = computedToValue;
              }
              const tweenFromValue = getFunctionValue(key.from, target, ti, tl);
              const keyEasing = key.ease;
              const hasSpring2 = !isUnd(keyEasing) && !isUnd(
                /** @type {Spring} */
                keyEasing.ease
              );
              const tweenEasing = hasSpring2 ? (
                /** @type {Spring} */
                keyEasing.ease
              ) : keyEasing || tEasing;
              const tweenDuration = hasSpring2 ? (
                /** @type {Spring} */
                keyEasing.duration
              ) : getFunctionValue(setValue(key.duration, l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration), target, ti, tl);
              const tweenDelay = getFunctionValue(setValue(key.delay, !tweenIndex ? tDelay : 0), target, ti, tl);
              const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);
              const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];
              const tweenModifier = key.modifier || tModifier;
              const hasFromvalue = !isUnd(tweenFromValue);
              const hasToValue = !isUnd(tweenToValue);
              const isFromToArray = isArr(tweenToValue);
              const isFromToValue = isFromToArray || hasFromvalue && hasToValue;
              const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;
              const absoluteStartTime = round(absoluteOffsetTime + tweenStartTime, 12);
              if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;
              let prevSibling = prevTween;
              if (tweenComposition !== compositionTypes.none) {
                if (!siblings) siblings = getTweenSiblings(target, propName);
                let nextSibling = siblings._head;
                while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {
                  prevSibling = nextSibling;
                  nextSibling = nextSibling._nextRep;
                  if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {
                    while (nextSibling) {
                      overrideTween(nextSibling);
                      nextSibling = nextSibling._nextRep;
                    }
                  }
                }
              }
              if (isFromToValue) {
                decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);
                decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);
                if (fromTargetObject.t === valueTypes.NUMBER) {
                  if (prevSibling) {
                    if (prevSibling._valueType === valueTypes.UNIT) {
                      fromTargetObject.t = valueTypes.UNIT;
                      fromTargetObject.u = prevSibling._unit;
                    }
                  } else {
                    decomposeRawValue(
                      getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles),
                      decomposedOriginalValue
                    );
                    if (decomposedOriginalValue.t === valueTypes.UNIT) {
                      fromTargetObject.t = valueTypes.UNIT;
                      fromTargetObject.u = decomposedOriginalValue.u;
                    }
                  }
                }
              } else {
                if (hasToValue) {
                  decomposeRawValue(tweenToValue, toTargetObject);
                } else {
                  if (prevTween) {
                    decomposeTweenValue(prevTween, toTargetObject);
                  } else {
                    decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value : getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), toTargetObject);
                  }
                }
                if (hasFromvalue) {
                  decomposeRawValue(tweenFromValue, fromTargetObject);
                } else {
                  if (prevTween) {
                    decomposeTweenValue(prevTween, fromTargetObject);
                  } else {
                    decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value : (
                      // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                      getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles)
                    ), fromTargetObject);
                  }
                }
              }
              if (fromTargetObject.o) {
                fromTargetObject.n = getRelativeValue(
                  !prevSibling ? decomposeRawValue(
                    getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles),
                    decomposedOriginalValue
                  ).n : prevSibling._toNumber,
                  fromTargetObject.n,
                  fromTargetObject.o
                );
              }
              if (toTargetObject.o) {
                toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);
              }
              if (fromTargetObject.t !== toTargetObject.t) {
                if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {
                  const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;
                  const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;
                  notComplexValue.t = valueTypes.COMPLEX;
                  notComplexValue.s = cloneArray(complexValue.s);
                  notComplexValue.d = complexValue.d.map(() => notComplexValue.n);
                } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {
                  const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;
                  const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;
                  notUnitValue.t = valueTypes.UNIT;
                  notUnitValue.u = unitValue.u;
                } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {
                  const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;
                  const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;
                  notColorValue.t = valueTypes.COLOR;
                  notColorValue.s = colorValue.s;
                  notColorValue.d = [0, 0, 0, 1];
                }
              }
              if (fromTargetObject.u !== toTargetObject.u) {
                let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;
                valueToConvert = convertValueUnit(
                  /** @type {DOMTarget} */
                  target,
                  valueToConvert,
                  toTargetObject.u ? toTargetObject.u : fromTargetObject.u,
                  false
                );
              }
              if (toTargetObject.d && fromTargetObject.d && toTargetObject.d.length !== fromTargetObject.d.length) {
                const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;
                const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;
                shortestValue.d = longestValue.d.map((_, i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);
                shortestValue.s = cloneArray(longestValue.s);
              }
              const tweenUpdateDuration = round(+tweenDuration || minValue, 12);
              const tween = {
                parent: this,
                id: tweenId++,
                property: propName,
                target,
                _value: null,
                _func: toFunctionStore.func,
                _ease: parseEasings(tweenEasing),
                _fromNumbers: cloneArray(fromTargetObject.d),
                _toNumbers: cloneArray(toTargetObject.d),
                _strings: cloneArray(toTargetObject.s),
                _fromNumber: fromTargetObject.n,
                _toNumber: toTargetObject.n,
                _numbers: cloneArray(fromTargetObject.d),
                // For additive tween and animatables
                _number: fromTargetObject.n,
                // For additive tween and animatables
                _unit: toTargetObject.u,
                _modifier: tweenModifier,
                _currentTime: 0,
                _startTime: tweenStartTime,
                _delay: +tweenDelay,
                _updateDuration: tweenUpdateDuration,
                _changeDuration: tweenUpdateDuration,
                _absoluteStartTime: absoluteStartTime,
                // NOTE: Investigate bit packing to stores ENUM / BOOL
                _tweenType: tweenType,
                _valueType: toTargetObject.t,
                _composition: tweenComposition,
                _isOverlapped: 0,
                _isOverridden: 0,
                _renderTransforms: 0,
                _prevRep: null,
                // For replaced tween
                _nextRep: null,
                // For replaced tween
                _prevAdd: null,
                // For additive tween
                _nextAdd: null,
                // For additive tween
                _prev: null,
                _next: null
              };
              if (tweenComposition !== compositionTypes.none) {
                composeTween(tween, siblings);
              }
              if (isNaN(firstTweenChangeStartTime)) {
                firstTweenChangeStartTime = tween._startTime;
              }
              lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);
              prevTween = tween;
              animationAnimationLength++;
              addChild(this, tween);
            }
            if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {
              iterationDelay = firstTweenChangeStartTime;
            }
            if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {
              iterationDuration = lastTweenChangeEndTime;
            }
            if (tweenType === tweenTypes.TRANSFORM) {
              lastTransformGroupIndex = animationAnimationLength - tweenIndex;
              lastTransformGroupLength = animationAnimationLength;
            }
          }
        }
        if (!isNaN(lastTransformGroupIndex)) {
          let i = 0;
          forEachChildren(this, (tween) => {
            if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {
              tween._renderTransforms = 1;
              if (tween._composition === compositionTypes.blend) {
                forEachChildren(additive.animation, (additiveTween) => {
                  if (additiveTween.id === tween.id) {
                    additiveTween._renderTransforms = 1;
                  }
                });
              }
            }
            i++;
          });
        }
      }
      if (!targetsLength) {
        console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
      }
      if (iterationDelay) {
        forEachChildren(this, (tween) => {
          if (!(tween._startTime - tween._delay)) {
            tween._delay -= iterationDelay;
          }
          tween._startTime -= iterationDelay;
        });
        iterationDuration -= iterationDelay;
      } else {
        iterationDelay = 0;
      }
      if (!iterationDuration) {
        iterationDuration = minValue;
        this.iterationCount = 0;
      }
      this.targets = parsedTargets;
      this.duration = iterationDuration === minValue ? minValue : clampInfinity((iterationDuration + this._loopDelay) * this.iterationCount - this._loopDelay) || minValue;
      this.onRender = onRender || animDefaults.onRender;
      this._ease = animEase;
      this._delay = iterationDelay;
      this.iterationDuration = iterationDuration;
      this._inlineStyles = animInlineStyles;
      if (!this._autoplay && shouldTriggerRender) this.onRender(this);
    }
    /**
     * @param  {Number} newDuration
     * @return {this}
     */
    stretch(newDuration) {
      const currentDuration = this.duration;
      if (currentDuration === normalizeTime(newDuration)) return this;
      const timeScale = newDuration / currentDuration;
      forEachChildren(this, (tween) => {
        tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);
        tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);
        tween._currentTime *= timeScale;
        tween._startTime *= timeScale;
        tween._absoluteStartTime *= timeScale;
      });
      return super.stretch(newDuration);
    }
    /**
     * @return {this}
     */
    refresh() {
      forEachChildren(this, (tween) => {
        const tweenFunc = tween._func;
        if (tweenFunc) {
          const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);
          decomposeRawValue(ogValue, decomposedOriginalValue);
          decomposeRawValue(tweenFunc(), toTargetObject);
          tween._fromNumbers = cloneArray(decomposedOriginalValue.d);
          tween._fromNumber = decomposedOriginalValue.n;
          tween._toNumbers = cloneArray(toTargetObject.d);
          tween._strings = cloneArray(toTargetObject.s);
          tween._toNumber = toTargetObject.o ? getRelativeValue(decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;
        }
      });
      return this;
    }
    /**
     * Cancel the animation and revert all the values affected by this animation to their original state
     * @return {this}
     */
    revert() {
      super.revert();
      return cleanInlineStyles(this);
    }
    /**
     * @param  {Callback<this>} [callback]
     * @return {Promise}
     */
    then(callback) {
      return super.then(callback);
    }
  }
  const animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();
  const easingToLinear = (fn, samples = 100) => {
    const points = [];
    for (let i = 0; i <= samples; i++) points.push(fn(i / samples));
    return `linear(${points.join(", ")})`;
  };
  const WAAPIEasesLookups = {
    in: "ease-in",
    out: "ease-out",
    inOut: "ease-in-out"
  };
  const WAAPIeases = /* @__PURE__ */ (() => {
    const list = {};
    for (let type in easeTypes) list[type] = (p) => easeTypes[type](easeInPower(p));
    return (
      /** @type {Record<String, EasingFunction>} */
      list
    );
  })();
  const parseWAAPIEasing = (ease) => {
    let parsedEase = WAAPIEasesLookups[ease];
    if (parsedEase) return parsedEase;
    parsedEase = "linear";
    if (isStr(ease)) {
      if (stringStartsWith(ease, "linear") || stringStartsWith(ease, "cubic-") || stringStartsWith(ease, "steps") || stringStartsWith(ease, "ease")) {
        parsedEase = ease;
      } else if (stringStartsWith(ease, "cubicB")) {
        parsedEase = toLowerCase(ease);
      } else {
        const parsed = parseEaseString(ease, WAAPIeases, WAAPIEasesLookups);
        if (isFnc(parsed)) parsedEase = parsed === none ? "linear" : easingToLinear(parsed);
      }
      WAAPIEasesLookups[ease] = parsedEase;
    } else if (isFnc(ease)) {
      const easing = easingToLinear(ease);
      if (easing) parsedEase = easing;
    } else if (
      /** @type {Spring} */
      ease.ease
    ) {
      parsedEase = easingToLinear(
        /** @type {Spring} */
        ease.ease
      );
    }
    return parsedEase;
  };
  const transformsShorthands = ["x", "y", "z"];
  const commonDefaultPXProperties = [
    "perspective",
    "width",
    "height",
    "margin",
    "padding",
    "top",
    "right",
    "bottom",
    "left",
    "borderWidth",
    "fontSize",
    "borderRadius",
    ...transformsShorthands
  ];
  const validIndividualTransforms = /* @__PURE__ */ (() => [...transformsShorthands, ...validTransforms.filter((t) => ["X", "Y", "Z"].some((axis) => t.endsWith(axis)))])();
  let transformsPropertiesRegistered = null;
  const WAAPIAnimationsLookups = {
    _head: null,
    _tail: null
  };
  const removeWAAPIAnimation = ($el, property, parent) => {
    let nextLookup = WAAPIAnimationsLookups._head;
    while (nextLookup) {
      const next = nextLookup._next;
      const matchTarget = nextLookup.$el === $el;
      const matchProperty = !property || nextLookup.property === property;
      const matchParent = !parent || nextLookup.parent === parent;
      if (matchTarget && matchProperty && matchParent) {
        const anim = nextLookup.animation;
        try {
          anim.commitStyles();
        } catch {
        }
        anim.cancel();
        removeChild(WAAPIAnimationsLookups, nextLookup);
        const lookupParent = nextLookup.parent;
        if (lookupParent) {
          lookupParent._completed++;
          if (lookupParent.animations.length === lookupParent._completed) {
            lookupParent.completed = true;
            if (!lookupParent.muteCallbacks) {
              lookupParent.paused = true;
              lookupParent.onComplete(lookupParent);
              lookupParent._resolve(lookupParent);
            }
          }
        }
      }
      nextLookup = next;
    }
  };
  const addWAAPIAnimation = (parent, $el, property, keyframes2, params) => {
    const animation = $el.animate(keyframes2, params);
    const animTotalDuration = params.delay + +params.duration * params.iterations;
    animation.playbackRate = parent._speed;
    if (parent.paused) animation.pause();
    if (parent.duration < animTotalDuration) {
      parent.duration = animTotalDuration;
      parent.controlAnimation = animation;
    }
    parent.animations.push(animation);
    removeWAAPIAnimation($el, property);
    addChild(WAAPIAnimationsLookups, { parent, animation, $el, property, _next: null, _prev: null });
    const handleRemove = () => {
      removeWAAPIAnimation($el, property, parent);
    };
    animation.onremove = handleRemove;
    animation.onfinish = handleRemove;
    return animation;
  };
  const normalizeTweenValue = (propName, value, $el, i, targetsLength) => {
    let v = getFunctionValue(
      /** @type {any} */
      value,
      $el,
      i,
      targetsLength
    );
    if (!isNum(v)) return v;
    if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, "translate")) return `${v}px`;
    if (stringStartsWith(propName, "rotate") || stringStartsWith(propName, "skew")) return `${v}deg`;
    return `${v}`;
  };
  const parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength) => {
    let tweenValue = "0";
    const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];
    if (!isUnd(from)) {
      const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);
      tweenValue = [computedFrom, computedTo];
    } else {
      tweenValue = isArr(to) ? to.map((v) => normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;
    }
    return tweenValue;
  };
  class WAAPIAnimation {
    /**
     * @param {DOMTargetsParam} targets
     * @param {WAAPIAnimationParams} params
     */
    constructor(targets, params) {
      if (isNil(transformsPropertiesRegistered)) {
        if (isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, "registerProperty"))) {
          transformsPropertiesRegistered = false;
        } else {
          validTransforms.forEach((t) => {
            const isSkew = stringStartsWith(t, "skew");
            const isScale = stringStartsWith(t, "scale");
            const isRotate = stringStartsWith(t, "rotate");
            const isTranslate = stringStartsWith(t, "translate");
            const isAngle = isRotate || isSkew;
            const syntax = isAngle ? "<angle>" : isScale ? "<number>" : isTranslate ? "<length-percentage>" : "*";
            try {
              CSS.registerProperty({
                name: "--" + t,
                syntax,
                inherits: false,
                initialValue: isTranslate ? "0px" : isAngle ? "0deg" : isScale ? "1" : "0"
              });
            } catch {
            }
          });
          transformsPropertiesRegistered = true;
        }
      }
      const parsedTargets = registerTargets(targets);
      const targetsLength = parsedTargets.length;
      if (!targetsLength) {
        console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
      }
      const ease = setValue(params.ease, parseWAAPIEasing(globals.defaults.ease));
      const spring = (
        /** @type {Spring} */
        ease.ease && ease
      );
      const autoplay = setValue(params.autoplay, globals.defaults.autoplay);
      const scroll = autoplay && /** @type {ScrollObserver} */
      autoplay.link ? autoplay : false;
      const alternate = params.alternate && /** @type {Boolean} */
      params.alternate === true;
      const reversed = params.reversed && /** @type {Boolean} */
      params.reversed === true;
      const loop = setValue(params.loop, globals.defaults.loop);
      const iterations = (
        /** @type {Number} */
        loop === true || loop === Infinity ? Infinity : isNum(loop) ? loop + 1 : 1
      );
      const direction = alternate ? reversed ? "alternate-reverse" : "alternate" : reversed ? "reverse" : "normal";
      const fill = "forwards";
      const easing = parseWAAPIEasing(ease);
      const timeScale = globals.timeScale === 1 ? 1 : K;
      this.targets = parsedTargets;
      this.animations = [];
      this.controlAnimation = null;
      this.onComplete = params.onComplete || noop;
      this.duration = 0;
      this.muteCallbacks = false;
      this.completed = false;
      this.paused = !autoplay || scroll !== false;
      this.reversed = reversed;
      this.autoplay = autoplay;
      this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);
      this._resolve = noop;
      this._completed = 0;
      this._inlineStyles = parsedTargets.map(($el) => $el.getAttribute("style"));
      parsedTargets.forEach(($el, i) => {
        const cachedTransforms = $el[transformsSymbol];
        const hasIndividualTransforms = validIndividualTransforms.some((t) => params.hasOwnProperty(t));
        const duration = (spring ? (
          /** @type {Spring} */
          spring.duration
        ) : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;
        const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;
        const composite = (
          /** @type {CompositeOperation} */
          setValue(params.composition, "replace")
        );
        for (let name2 in params) {
          if (!isKey(name2)) continue;
          const keyframes2 = {};
          const tweenParams = { iterations, direction, fill, easing, duration, delay, composite };
          const propertyValue2 = params[name2];
          const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name2) ? name2 : shortTransforms.get(name2) : false;
          let parsedPropertyValue;
          if (isObj(propertyValue2)) {
            const tweenOptions = (
              /** @type {WAAPITweenOptions} */
              propertyValue2
            );
            const tweenOptionsEase = setValue(tweenOptions.ease, ease);
            const tweenOptionsSpring = (
              /** @type {Spring} */
              tweenOptionsEase.ease && tweenOptionsEase
            );
            const to = (
              /** @type {WAAPITweenOptions} */
              tweenOptions.to
            );
            const from = (
              /** @type {WAAPITweenOptions} */
              tweenOptions.from
            );
            tweenParams.duration = (tweenOptionsSpring ? (
              /** @type {Spring} */
              tweenOptionsSpring.duration
            ) : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;
            tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;
            tweenParams.composite = /** @type {CompositeOperation} */
            setValue(tweenOptions.composition, composite);
            tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);
            parsedPropertyValue = parseIndividualTweenValue($el, name2, from, to, i, targetsLength);
            if (individualTransformProperty) {
              keyframes2[`--${individualTransformProperty}`] = parsedPropertyValue;
              cachedTransforms[individualTransformProperty] = parsedPropertyValue;
            } else {
              keyframes2[name2] = parseIndividualTweenValue($el, name2, from, to, i, targetsLength);
            }
            addWAAPIAnimation(this, $el, name2, keyframes2, tweenParams);
            if (!isUnd(from)) {
              if (!individualTransformProperty) {
                $el.style[name2] = keyframes2[name2][0];
              } else {
                const key2 = `--${individualTransformProperty}`;
                $el.style.setProperty(key2, keyframes2[key2][0]);
              }
            }
          } else {
            parsedPropertyValue = isArr(propertyValue2) ? propertyValue2.map((v) => normalizeTweenValue(name2, v, $el, i, targetsLength)) : normalizeTweenValue(
              name2,
              /** @type {any} */
              propertyValue2,
              $el,
              i,
              targetsLength
            );
            if (individualTransformProperty) {
              keyframes2[`--${individualTransformProperty}`] = parsedPropertyValue;
              cachedTransforms[individualTransformProperty] = parsedPropertyValue;
            } else {
              keyframes2[name2] = parsedPropertyValue;
            }
            addWAAPIAnimation(this, $el, name2, keyframes2, tweenParams);
          }
        }
        if (hasIndividualTransforms) {
          let transforms = emptyString;
          for (let t in cachedTransforms) {
            transforms += `${transformsFragmentStrings[t]}var(--${t})) `;
          }
          $el.style.transform = transforms;
        }
      });
      if (scroll) {
        this.autoplay.link(this);
      }
    }
    /**
     * @callback forEachCallback
     * @param {globalThis.Animation} animation
     */
    /**
     * @param  {forEachCallback|String} callback
     * @return {this}
     */
    forEach(callback) {
      const cb = isStr(callback) ? (a) => a[callback]() : callback;
      this.animations.forEach(cb);
      return this;
    }
    get speed() {
      return this._speed;
    }
    /** @param {Number} speed */
    set speed(speed) {
      this._speed = +speed;
      this.forEach((anim) => anim.playbackRate = speed);
    }
    get currentTime() {
      const controlAnimation = this.controlAnimation;
      const timeScale = globals.timeScale;
      return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;
    }
    /** @param {Number} time */
    set currentTime(time) {
      const t = time * (globals.timeScale === 1 ? 1 : K);
      this.forEach((anim) => {
        if (t >= this.duration) anim.play();
        anim.currentTime = t;
      });
    }
    get progress() {
      return this.currentTime / this.duration;
    }
    /** @param {Number} progress */
    set progress(progress) {
      this.forEach((anim) => anim.currentTime = progress * this.duration || 0);
    }
    resume() {
      if (!this.paused) return this;
      this.paused = false;
      return this.forEach("play");
    }
    pause() {
      if (this.paused) return this;
      this.paused = true;
      return this.forEach("pause");
    }
    alternate() {
      this.reversed = !this.reversed;
      this.forEach("reverse");
      if (this.paused) this.forEach("pause");
      return this;
    }
    play() {
      if (this.reversed) this.alternate();
      return this.resume();
    }
    reverse() {
      if (!this.reversed) this.alternate();
      return this.resume();
    }
    /**
     * @param {Number} time
     * @param {Boolean} muteCallbacks
     */
    seek(time, muteCallbacks = false) {
      if (muteCallbacks) this.muteCallbacks = true;
      if (time < this.duration) this.completed = false;
      this.currentTime = time;
      this.muteCallbacks = false;
      if (this.paused) this.pause();
      return this;
    }
    restart() {
      this.completed = false;
      return this.seek(0, true).resume();
    }
    commitStyles() {
      return this.forEach("commitStyles");
    }
    complete() {
      return this.seek(this.duration);
    }
    cancel() {
      this.forEach("cancel");
      return this.pause();
    }
    revert() {
      this.cancel();
      this.targets.forEach(($el, i) => $el.setAttribute("style", this._inlineStyles[i]));
      return this;
    }
    /**
     * @param  {WAAPICallback} [callback]
     * @return {Promise}
     */
    then(callback = noop) {
      const then = this.then;
      const onResolve = () => {
        this.then = null;
        callback(this);
        this.then = then;
        this._resolve = noop;
      };
      return new Promise((r) => {
        this._resolve = () => r(onResolve());
        if (this.completed) this._resolve();
        return this;
      });
    }
  }
  const waapi = {
    /**
     * @param {DOMTargetsParam} targets
     * @param {WAAPIAnimationParams} params
     * @return {WAAPIAnimation}
     */
    animate: (targets, params) => new WAAPIAnimation(targets, params),
    convertEase: easingToLinear
  };
  const sync = (callback = noop) => {
    return new Timer({ duration: 1 * globals.timeScale, onComplete: callback }, null, 0).resume();
  };
  function getTargetValue(targetSelector, propName, unit) {
    const targets = registerTargets(targetSelector);
    if (!targets.length) return;
    const [target] = targets;
    const tweenType = getTweenType(target, propName);
    const normalizePropName = sanitizePropertyName(propName, target, tweenType);
    let originalValue = getOriginalAnimatableValue(target, normalizePropName);
    if (isUnd(unit)) {
      return originalValue;
    } else {
      decomposeRawValue(originalValue, decomposedOriginalValue);
      if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) {
        if (unit === false) {
          return decomposedOriginalValue.n;
        } else {
          const convertedValue = convertValueUnit(
            /** @type {DOMTarget} */
            target,
            decomposedOriginalValue,
            /** @type {String} */
            unit,
            false
          );
          return `${round(convertedValue.n, globals.precision)}${convertedValue.u}`;
        }
      }
    }
  }
  const setTargetValues = (targets, parameters) => {
    if (isUnd(parameters)) return;
    parameters.duration = minValue;
    parameters.composition = setValue(parameters.composition, compositionTypes.none);
    return new JSAnimation(targets, parameters, null, 0, true).resume();
  };
  const removeTargetsFromAnimation = (targetsArray, animation, propertyName) => {
    let tweensMatchesTargets = false;
    forEachChildren(animation, (tween) => {
      const tweenTarget = tween.target;
      if (targetsArray.includes(tweenTarget)) {
        const tweenName = tween.property;
        const tweenType = tween._tweenType;
        const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);
        if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {
          if (tween.parent._tail === tween && tween._tweenType === tweenTypes.TRANSFORM && tween._prev && tween._prev._tweenType === tweenTypes.TRANSFORM) {
            tween._prev._renderTransforms = 1;
          }
          removeChild(animation, tween);
          removeTweenSliblings(tween);
          tweensMatchesTargets = true;
        }
      }
    }, true);
    return tweensMatchesTargets;
  };
  const remove = (targets, renderable, propertyName) => {
    const targetsArray = parseTargets(targets);
    const parent = (
      /** @type {Renderable|typeof engine} **/
      renderable ? renderable : engine
    );
    const waapiAnimation = renderable && /** @type {WAAPIAnimation} */
    renderable.controlAnimation && /** @type {WAAPIAnimation} */
    renderable;
    for (let i = 0, l = targetsArray.length; i < l; i++) {
      const $el = (
        /** @type {DOMTarget}  */
        targetsArray[i]
      );
      removeWAAPIAnimation($el, propertyName, waapiAnimation);
    }
    let removeMatches;
    if (parent._hasChildren) {
      let iterationDuration = 0;
      forEachChildren(parent, (child) => {
        if (!child._hasChildren) {
          removeMatches = removeTargetsFromAnimation(
            targetsArray,
            /** @type {JSAnimation} */
            child,
            propertyName
          );
          if (removeMatches && !child._head) {
            child.cancel();
            removeChild(parent, child);
          } else {
            const childTLOffset = child._offset + child._delay;
            const childDur = childTLOffset + child.duration;
            if (childDur > iterationDuration) {
              iterationDuration = childDur;
            }
          }
        }
        if (child._head) {
          remove(targets, child, propertyName);
        } else {
          child._hasChildren = false;
        }
      }, true);
      if (!isUnd(
        /** @type {Renderable} */
        parent.iterationDuration
      )) {
        parent.iterationDuration = iterationDuration;
      }
    } else {
      removeMatches = removeTargetsFromAnimation(
        targetsArray,
        /** @type {JSAnimation} */
        parent,
        propertyName
      );
    }
    if (removeMatches && !parent._head) {
      parent._hasChildren = false;
      if (
        /** @type {Renderable} */
        parent.cancel
      ) parent.cancel();
    }
    return targetsArray;
  };
  const keepTime = createRefreshable;
  const randomPick = (items2) => items2[random(0, items2.length - 1)];
  const roundPad = (v, decimalLength) => (+v).toFixed(decimalLength);
  const padStart = (v, totalLength, padString) => `${v}`.padStart(totalLength, padString);
  const padEnd = (v, totalLength, padString) => `${v}`.padEnd(totalLength, padString);
  const wrap = (v, min, max2) => ((v - min) % (max2 - min) + (max2 - min)) % (max2 - min) + min;
  const mapRange = (value, inLow, inHigh, outLow, outHigh) => outLow + (value - inLow) / (inHigh - inLow) * (outHigh - outLow);
  const degToRad = (degrees) => degrees * PI / 180;
  const radToDeg = (radians) => radians * 180 / PI;
  const lerp = (start, end, amount, renderable) => {
    let dt = K / globals.defaults.frameRate;
    if (renderable !== false) {
      const ticker = (
        /** @type Renderable */
        renderable || engine._hasChildren && engine
      );
      if (ticker && ticker.deltaTime) {
        dt = ticker.deltaTime;
      }
    }
    const t = 1 - Math.exp(-amount * dt * 0.1);
    return !amount ? start : amount === 1 ? end : (1 - t) * start + t * end;
  };
  const curry = (fn, last = 0) => (...args) => last ? (v) => fn(...args, v) : (v) => fn(v, ...args);
  const chain = (fn) => {
    return (...args) => {
      const result = fn(...args);
      return new Proxy(noop, {
        apply: (_, __, [v]) => result(v),
        get: (_, prop) => chain(
          /**@param {...Number|String} nextArgs */
          (...nextArgs) => {
            const nextResult = utils[prop](...nextArgs);
            return (v) => nextResult(result(v));
          }
        )
      });
    };
  };
  const makeChainable = (fn, right = 0) => (...args) => (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);
  const utils = {
    $: registerTargets,
    get: getTargetValue,
    set: setTargetValues,
    remove,
    cleanInlineStyles,
    random,
    randomPick,
    shuffle,
    lerp,
    sync,
    keepTime,
    clamp: (
      /** @type {typeof clamp & ChainedClamp} */
      makeChainable(clamp)
    ),
    round: (
      /** @type {typeof round & ChainedRound} */
      makeChainable(round)
    ),
    snap: (
      /** @type {typeof snap & ChainedSnap} */
      makeChainable(snap)
    ),
    wrap: (
      /** @type {typeof wrap & ChainedWrap} */
      makeChainable(wrap)
    ),
    interpolate: (
      /** @type {typeof interpolate & ChainedInterpolate} */
      makeChainable(interpolate, 1)
    ),
    mapRange: (
      /** @type {typeof mapRange & ChainedMapRange} */
      makeChainable(mapRange)
    ),
    roundPad: (
      /** @type {typeof roundPad & ChainedRoundPad} */
      makeChainable(roundPad)
    ),
    padStart: (
      /** @type {typeof padStart & ChainedPadStart} */
      makeChainable(padStart)
    ),
    padEnd: (
      /** @type {typeof padEnd & ChainedPadEnd} */
      makeChainable(padEnd)
    ),
    degToRad: (
      /** @type {typeof degToRad & ChainedDegToRad} */
      makeChainable(degToRad)
    ),
    radToDeg: (
      /** @type {typeof radToDeg & ChainedRadToDeg} */
      makeChainable(radToDeg)
    )
  };
  const getPrevChildOffset = (timeline, timePosition) => {
    if (stringStartsWith(timePosition, "<")) {
      const goToPrevAnimationOffset = timePosition[1] === "<";
      const prevAnimation = (
        /** @type {Tickable} */
        timeline._tail
      );
      const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;
      return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;
    }
  };
  const parseTimelinePosition = (timeline, timePosition) => {
    let tlDuration = timeline.iterationDuration;
    if (tlDuration === minValue) tlDuration = 0;
    if (isUnd(timePosition)) return tlDuration;
    if (isNum(+timePosition)) return +timePosition;
    const timePosStr = (
      /** @type {String} */
      timePosition
    );
    const tlLabels = timeline ? timeline.labels : null;
    const hasLabels = !isNil(tlLabels);
    const prevOffset = getPrevChildOffset(timeline, timePosStr);
    const hasSibling = !isUnd(prevOffset);
    const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);
    if (matchedRelativeOperator) {
      const fullOperator = matchedRelativeOperator[0];
      const split = timePosStr.split(fullOperator);
      const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;
      const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;
      const parsedNumericalOffset = +split[1];
      return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);
    } else {
      return hasSibling ? prevOffset : hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] : tlDuration : tlDuration;
    }
  };
  function getTimelineTotalDuration(tl) {
    return clampInfinity((tl.iterationDuration + tl._loopDelay) * tl.iterationCount - tl._loopDelay) || minValue;
  }
  function addTlChild(childParams, tl, timePosition, targets, index2, length) {
    const isSetter = isNum(childParams.duration) && /** @type {Number} */
    childParams.duration <= minValue;
    const adjustedPosition = isSetter ? timePosition - minValue : timePosition;
    tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);
    const tlChild = targets ? new JSAnimation(
      targets,
      /** @type {AnimationParams} */
      childParams,
      tl,
      adjustedPosition,
      false,
      index2,
      length
    ) : new Timer(
      /** @type {TimerParams} */
      childParams,
      tl,
      adjustedPosition
    );
    tlChild.init(1);
    addChild(tl, tlChild);
    forEachChildren(tl, (child) => {
      const childTLOffset = child._offset + child._delay;
      const childDur = childTLOffset + child.duration;
      if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;
    });
    tl.duration = getTimelineTotalDuration(tl);
    return tl;
  }
  class Timeline extends Timer {
    /**
     * @param {TimelineParams} [parameters]
     */
    constructor(parameters = {}) {
      super(
        /** @type {TimerParams&TimelineParams} */
        parameters,
        null,
        0
      );
      this.duration = 0;
      this.labels = {};
      const defaultsParams = parameters.defaults;
      const globalDefaults = globals.defaults;
      this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;
      this.onRender = parameters.onRender || globalDefaults.onRender;
      const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);
      this._ease = tlPlaybackEase ? parseEasings(tlPlaybackEase) : null;
      this.iterationDuration = 0;
    }
    /**
     * @overload
     * @param {TargetsParam} a1
     * @param {AnimationParams} a2
     * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]
     * @return {this}
     *
     * @overload
     * @param {TimerParams} a1
     * @param {TimelinePosition} [a2]
     * @return {this}
     *
     * @param {TargetsParam|TimerParams} a1
     * @param {TimelinePosition|AnimationParams} a2
     * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]
     */
    add(a1, a2, a3) {
      const isAnim = isObj(a2);
      const isTimer = isObj(a1);
      if (isAnim || isTimer) {
        this._hasChildren = true;
        if (isAnim) {
          const childParams = (
            /** @type {AnimationParams} */
            a2
          );
          if (isFnc(a3)) {
            const staggeredPosition = a3;
            const parsedTargetsArray = parseTargets(
              /** @type {TargetsParam} */
              a1
            );
            const tlDuration = this.duration;
            const tlIterationDuration = this.iterationDuration;
            const id = childParams.id;
            let i = 0;
            const parsedLength = parsedTargetsArray.length;
            parsedTargetsArray.forEach((target) => {
              const staggeredChildParams = { ...childParams };
              this.duration = tlDuration;
              this.iterationDuration = tlIterationDuration;
              if (!isUnd(id)) staggeredChildParams.id = id + "-" + i;
              addTlChild(
                staggeredChildParams,
                this,
                parseTimelinePosition(this, staggeredPosition(target, i, parsedLength, this)),
                target,
                i,
                parsedLength
              );
              i++;
            });
          } else {
            addTlChild(
              childParams,
              this,
              parseTimelinePosition(this, a3),
              /** @type {TargetsParam} */
              a1
            );
          }
        } else {
          addTlChild(
            /** @type TimerParams */
            a1,
            this,
            parseTimelinePosition(this, a2)
          );
        }
        return this.init(1);
      }
    }
    /**
     * @overload
     * @param {Tickable} [synced]
     * @param {TimelinePosition} [position]
     * @return {this}
     *
     * @overload
     * @param {globalThis.Animation} [synced]
     * @param {TimelinePosition} [position]
     * @return {this}
     *
     * @overload
     * @param {WAAPIAnimation} [synced]
     * @param {TimelinePosition} [position]
     * @return {this}
     *
     * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]
     * @param {TimelinePosition} [position]
     */
    sync(synced, position2) {
      if (isUnd(synced) || synced && isUnd(synced.pause)) return this;
      synced.pause();
      const duration = +/** @type {globalThis.Animation} */
      (synced.effect ? (
        /** @type {globalThis.Animation} */
        synced.effect.getTiming().duration
      ) : (
        /** @type {Tickable} */
        synced.duration
      ));
      return this.add(synced, { currentTime: [0, duration], duration, ease: "linear" }, position2);
    }
    /**
     * @param  {TargetsParam} targets
     * @param  {AnimationParams} parameters
     * @param  {TimelinePosition} [position]
     * @return {this}
     */
    set(targets, parameters, position2) {
      if (isUnd(parameters)) return this;
      parameters.duration = minValue;
      parameters.composition = compositionTypes.replace;
      return this.add(targets, parameters, position2);
    }
    /**
     * @param {Callback<Timer>} callback
     * @param {TimelinePosition} [position]
     * @return {this}
     */
    call(callback, position2) {
      if (isUnd(callback) || callback && !isFnc(callback)) return this;
      return this.add({ duration: 0, onComplete: () => callback(this) }, position2);
    }
    /**
     * @param {String} labelName
     * @param {TimelinePosition} [position]
     * @return {this}
     *
     */
    label(labelName, position2) {
      if (isUnd(labelName) || labelName && !isStr(labelName)) return this;
      this.labels[labelName] = parseTimelinePosition(this, position2);
      return this;
    }
    /**
     * @param  {TargetsParam} targets
     * @param  {String} [propertyName]
     * @return {this}
     */
    remove(targets, propertyName) {
      remove(targets, this, propertyName);
      return this;
    }
    /**
     * @param  {Number} newDuration
     * @return {this}
     */
    stretch(newDuration) {
      const currentDuration = this.duration;
      if (currentDuration === normalizeTime(newDuration)) return this;
      const timeScale = newDuration / currentDuration;
      const labels = this.labels;
      forEachChildren(this, (child) => child.stretch(child.duration * timeScale));
      for (let labelName in labels) labels[labelName] *= timeScale;
      return super.stretch(newDuration);
    }
    /**
     * @return {this}
     */
    refresh() {
      forEachChildren(this, (child) => {
        if (child.refresh) child.refresh();
      });
      return this;
    }
    /**
     * @return {this}
     */
    revert() {
      super.revert();
      forEachChildren(this, (child) => child.revert, true);
      return cleanInlineStyles(this);
    }
    /**
     * @param  {Callback<this>} [callback]
     * @return {Promise}
     */
    then(callback) {
      return super.then(callback);
    }
  }
  const createTimeline = (parameters) => new Timeline(parameters).init();
  const stagger = (val, params = {}) => {
    let values = [];
    let maxValue2 = 0;
    const from = params.from;
    const reversed = params.reversed;
    const ease = params.ease;
    const hasEasing = !isUnd(ease);
    const hasSpring = hasEasing && !isUnd(
      /** @type {Spring} */
      ease.ease
    );
    const staggerEase = hasSpring ? (
      /** @type {Spring} */
      ease.ease
    ) : hasEasing ? parseEasings(ease) : null;
    const grid = params.grid;
    const axis = params.axis;
    const customTotal = params.total;
    const fromFirst = isUnd(from) || from === 0 || from === "first";
    const fromCenter = from === "center";
    const fromLast = from === "last";
    const fromRandom = from === "random";
    const isRange = isArr(val);
    const useProp = params.use;
    const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);
    const val2 = isRange ? parseNumber(val[1]) : 0;
    const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);
    const start = params.start || 0 + (isRange ? val1 : 0);
    let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;
    return (target, i, t, tl) => {
      const [registeredTarget] = registerTargets(target);
      const total = isUnd(customTotal) ? t : customTotal;
      const customIndex = !isUnd(useProp) ? isFnc(useProp) ? useProp(registeredTarget, i, total) : getOriginalAnimatableValue(registeredTarget, useProp) : false;
      const staggerIndex = isNum(customIndex) || isStr(customIndex) && isNum(+customIndex) ? +customIndex : i;
      if (fromCenter) fromIndex = (total - 1) / 2;
      if (fromLast) fromIndex = total - 1;
      if (!values.length) {
        for (let index2 = 0; index2 < total; index2++) {
          if (!grid) {
            values.push(abs(fromIndex - index2));
          } else {
            const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
            const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
            const toX = index2 % grid[0];
            const toY = floor(index2 / grid[0]);
            const distanceX = fromX - toX;
            const distanceY = fromY - toY;
            let value = sqrt(distanceX * distanceX + distanceY * distanceY);
            if (axis === "x") value = -distanceX;
            if (axis === "y") value = -distanceY;
            values.push(value);
          }
          maxValue2 = max(...values);
        }
        if (staggerEase) values = values.map((val3) => staggerEase(val3 / maxValue2) * maxValue2);
        if (reversed) values = values.map((val3) => axis ? val3 < 0 ? val3 * -1 : -val3 : abs(maxValue2 - val3));
        if (fromRandom) values = shuffle(values);
      }
      const spacing = isRange ? (val2 - val1) / maxValue2 : val1;
      const offset = tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : (
        /** @type {Number} */
        start
      );
      let output = offset + (spacing * round(values[staggerIndex], 2) || 0);
      if (params.modifier) output = params.modifier(output);
      if (unitMatch) output = `${output}${unitMatch[2]}`;
      return output;
    };
  };
  const injectableSymbol = Symbol("injectable");
  function storeInjectable(value, data2) {
    value[injectableSymbol] = data2;
    return value;
  }
  function createFunctionPlaceholder(name2, readme) {
    const fn = function() {
    };
    Object.defineProperty(fn, "name", { value: name2, writable: false });
    if (readme) fn.README = readme;
    return fn;
  }
  const stopPropagation$1 = (value) => baseStopPropagation(value) || value instanceof Timer || value instanceof JSAnimation || value instanceof WAAPIAnimation || value instanceof Timeline;
  function sanitizeInjectable(injectable) {
    try {
      return deepMap(injectable, (value) => {
        if (isSourceMap(value)) return value;
        clearSourceMap(value);
        if (isLazyInject(value) || typeof value === "function" && value[generatedLazyInjectSymbol]) {
          const name2 = value[generatedLazyInjectSymbol] ?? value.name;
          return createFunctionPlaceholder(
            name2,
            `Omitted lazy inject '${name2}' (contents are parsed only when called)`
          );
        }
        if (["function", "object"].includes(typeof value) && value !== null && injectableSymbol in value)
          return sanitizeInjectable(value[injectableSymbol]);
        if (typeof value === "function" && value[zodErrorBoundarySymbol])
          return createFunctionPlaceholder(
            value[zodErrorBoundarySymbol]
          );
        return value;
      }, { stopPropagation: stopPropagation$1 });
    } catch (error2) {
      return injectable;
    }
  }
  function sanitizeContext(context) {
    const ctx = omit(context, [
      "pack",
      "animation",
      "module",
      "meta",
      "settings",
      "instance",
      "intersectWith",
      "window",
      "document",
      "mouse",
      "onError"
    ]);
    if (context.module) ctx.module = pick(context.module, ["id", "name"]);
    if ("vars" in context) ctx.vars = sanitizeInjectable(context.vars);
    return ctx;
  }
  function snapshotContext(context) {
    return cloneDeep(sanitizeContext(context));
  }
  class AnimationError extends BaseError {
    constructor(animation, message, { type, context, stage, ...options } = {}) {
      const meta2 = [
        `Animation: ${animation.name} (${animation.key})`,
        `Type: ${type}`
      ];
      if (context)
        meta2.push(
          "Context: " + objectInspect(
            sanitizeContext(context),
            { indent: 2 }
          )
        );
      super(message, options, meta2);
      this.animation = animation;
      this.animationType = type;
      this.context = context;
    }
    get name() {
      return "AnimationError";
    }
  }
  const ModuleType = Enum({
    Switch: "switch",
    Reveal: "reveal"
  });
  const ParseStage = Enum({
    Initialize: "Initialize",
    BeforeExtend: "BeforeExtend",
    Extend: "Extend",
    BeforeLayout: "BeforeLayout",
    Layout: "Layout",
    BeforeCreate: "BeforeCreate",
    Anime: "Anime",
    Created: "Created",
    BeforeBegin: "BeforeBegin",
    Completed: "Completed",
    BeforeDestroy: "BeforeDestroy",
    Destroyed: "Destroyed",
    Lazy: "Lazy"
  });
  const VOID = -1;
  const PRIMITIVE = 0;
  const ARRAY = 1;
  const OBJECT = 2;
  const DATE = 3;
  const REGEXP = 4;
  const MAP = 5;
  const SET = 6;
  const ERROR = 7;
  const BIGINT = 8;
  const env = typeof self === "object" ? self : globalThis;
  const deserializer = ($, _) => {
    const as = (out, index2) => {
      $.set(index2, out);
      return out;
    };
    const unpair = (index2) => {
      if ($.has(index2))
        return $.get(index2);
      const [type, value] = _[index2];
      switch (type) {
        case PRIMITIVE:
        case VOID:
          return as(value, index2);
        case ARRAY: {
          const arr = as([], index2);
          for (const index3 of value)
            arr.push(unpair(index3));
          return arr;
        }
        case OBJECT: {
          const object = as({}, index2);
          for (const [key2, index3] of value)
            object[unpair(key2)] = unpair(index3);
          return object;
        }
        case DATE:
          return as(new Date(value), index2);
        case REGEXP: {
          const { source, flags } = value;
          return as(new RegExp(source, flags), index2);
        }
        case MAP: {
          const map = as(/* @__PURE__ */ new Map(), index2);
          for (const [key2, index3] of value)
            map.set(unpair(key2), unpair(index3));
          return map;
        }
        case SET: {
          const set = as(/* @__PURE__ */ new Set(), index2);
          for (const index3 of value)
            set.add(unpair(index3));
          return set;
        }
        case ERROR: {
          const { name: name2, message } = value;
          return as(new env[name2](message), index2);
        }
        case BIGINT:
          return as(BigInt(value), index2);
        case "BigInt":
          return as(Object(BigInt(value)), index2);
        case "ArrayBuffer":
          return as(new Uint8Array(value).buffer, value);
        case "DataView": {
          const { buffer } = new Uint8Array(value);
          return as(new DataView(buffer), value);
        }
      }
      return as(new env[type](value), index2);
    };
    return unpair;
  };
  const deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);
  const EMPTY = "";
  const { toString } = {};
  const { keys } = Object;
  const typeOf = (value) => {
    const type = typeof value;
    if (type !== "object" || !value)
      return [PRIMITIVE, type];
    const asString = toString.call(value).slice(8, -1);
    switch (asString) {
      case "Array":
        return [ARRAY, EMPTY];
      case "Object":
        return [OBJECT, EMPTY];
      case "Date":
        return [DATE, EMPTY];
      case "RegExp":
        return [REGEXP, EMPTY];
      case "Map":
        return [MAP, EMPTY];
      case "Set":
        return [SET, EMPTY];
      case "DataView":
        return [ARRAY, asString];
    }
    if (asString.includes("Array"))
      return [ARRAY, asString];
    if (asString.includes("Error"))
      return [ERROR, asString];
    return [OBJECT, asString];
  };
  const shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
  const serializer = (strict, json, $, _) => {
    const as = (out, value) => {
      const index2 = _.push(out) - 1;
      $.set(value, index2);
      return index2;
    };
    const pair = (value) => {
      if ($.has(value))
        return $.get(value);
      let [TYPE, type] = typeOf(value);
      switch (TYPE) {
        case PRIMITIVE: {
          let entry = value;
          switch (type) {
            case "bigint":
              TYPE = BIGINT;
              entry = value.toString();
              break;
            case "function":
            case "symbol":
              if (strict)
                throw new TypeError("unable to serialize " + type);
              entry = null;
              break;
            case "undefined":
              return as([VOID], value);
          }
          return as([TYPE, entry], value);
        }
        case ARRAY: {
          if (type) {
            let spread = value;
            if (type === "DataView") {
              spread = new Uint8Array(value.buffer);
            } else if (type === "ArrayBuffer") {
              spread = new Uint8Array(value);
            }
            return as([type, [...spread]], value);
          }
          const arr = [];
          const index2 = as([TYPE, arr], value);
          for (const entry of value)
            arr.push(pair(entry));
          return index2;
        }
        case OBJECT: {
          if (type) {
            switch (type) {
              case "BigInt":
                return as([type, value.toString()], value);
              case "Boolean":
              case "Number":
              case "String":
                return as([type, value.valueOf()], value);
            }
          }
          if (json && "toJSON" in value)
            return pair(value.toJSON());
          const entries = [];
          const index2 = as([TYPE, entries], value);
          for (const key2 of keys(value)) {
            if (strict || !shouldSkip(typeOf(value[key2])))
              entries.push([pair(key2), pair(value[key2])]);
          }
          return index2;
        }
        case DATE:
          return as([TYPE, value.toISOString()], value);
        case REGEXP: {
          const { source, flags } = value;
          return as([TYPE, { source, flags }], value);
        }
        case MAP: {
          const entries = [];
          const index2 = as([TYPE, entries], value);
          for (const [key2, entry] of value) {
            if (strict || !(shouldSkip(typeOf(key2)) || shouldSkip(typeOf(entry))))
              entries.push([pair(key2), pair(entry)]);
          }
          return index2;
        }
        case SET: {
          const entries = [];
          const index2 = as([TYPE, entries], value);
          for (const entry of value) {
            if (strict || !shouldSkip(typeOf(entry)))
              entries.push(pair(entry));
          }
          return index2;
        }
      }
      const { message } = value;
      return as([TYPE, { name: type, message }], value);
    };
    return pair;
  };
  const serialize = (value, { json, lossy } = {}) => {
    const _ = [];
    return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
  };
  const structuredClone$1 = typeof structuredClone === "function" ? (
    /* c8 ignore start */
    (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize(any, options)) : structuredClone(any)
  ) : (any, options) => deserialize(serialize(any, options));
  const pointEnd = point("end");
  const pointStart = point("start");
  function point(type) {
    return point2;
    function point2(node) {
      const point3 = node && node.position && node.position[type] || {};
      if (typeof point3.line === "number" && point3.line > 0 && typeof point3.column === "number" && point3.column > 0) {
        return {
          line: point3.line,
          column: point3.column,
          offset: typeof point3.offset === "number" && point3.offset > -1 ? point3.offset : void 0
        };
      }
    }
  }
  function position(node) {
    const start = pointStart(node);
    const end = pointEnd(node);
    if (start && end) {
      return { start, end };
    }
  }
  const aria$1 = ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy"];
  const defaultSchema = {
    ancestors: {
      tbody: ["table"],
      td: ["table"],
      th: ["table"],
      thead: ["table"],
      tfoot: ["table"],
      tr: ["table"]
    },
    attributes: {
      a: [
        ...aria$1,
        // Note: these 3 are used by GFM footnotes, they do work on all links.
        "dataFootnoteBackref",
        "dataFootnoteRef",
        ["className", "data-footnote-backref"],
        "href"
      ],
      blockquote: ["cite"],
      // Note: this class is not normally allowed by GH, when manually writing
      // `code` as HTML in markdown, they adds it some other way.
      // We can’t do that, so we have to allow it.
      code: [["className", /^language-./]],
      del: ["cite"],
      div: ["itemScope", "itemType"],
      dl: [...aria$1],
      // Note: this is used by GFM footnotes.
      h2: [["className", "sr-only"]],
      img: [...aria$1, "longDesc", "src"],
      // Note: `input` is not normally allowed by GH, when manually writing
      // it in markdown, they add it from tasklists some other way.
      // We can’t do that, so we have to allow it.
      input: [
        ["disabled", true],
        ["type", "checkbox"]
      ],
      ins: ["cite"],
      // Note: this class is not normally allowed by GH, when manually writing
      // `li` as HTML in markdown, they adds it some other way.
      // We can’t do that, so we have to allow it.
      li: [["className", "task-list-item"]],
      // Note: this class is not normally allowed by GH, when manually writing
      // `ol` as HTML in markdown, they adds it some other way.
      // We can’t do that, so we have to allow it.
      ol: [...aria$1, ["className", "contains-task-list"]],
      q: ["cite"],
      section: ["dataFootnotes", ["className", "footnotes"]],
      source: ["srcSet"],
      summary: [...aria$1],
      table: [...aria$1],
      // Note: this class is not normally allowed by GH, when manually writing
      // `ol` as HTML in markdown, they adds it some other way.
      // We can’t do that, so we have to allow it.
      ul: [...aria$1, ["className", "contains-task-list"]],
      "*": [
        "abbr",
        "accept",
        "acceptCharset",
        "accessKey",
        "action",
        "align",
        "alt",
        "axis",
        "border",
        "cellPadding",
        "cellSpacing",
        "char",
        "charOff",
        "charSet",
        "checked",
        "clear",
        "colSpan",
        "color",
        "cols",
        "compact",
        "coords",
        "dateTime",
        "dir",
        // Note: `disabled` is technically allowed on all elements by GH.
        // But it is useless on everything except `input`.
        // Because `input`s are normally not allowed, but we allow them for
        // checkboxes due to tasklists, we allow `disabled` only there.
        "encType",
        "frame",
        "hSpace",
        "headers",
        "height",
        "hrefLang",
        "htmlFor",
        "id",
        "isMap",
        "itemProp",
        "label",
        "lang",
        "maxLength",
        "media",
        "method",
        "multiple",
        "name",
        "noHref",
        "noShade",
        "noWrap",
        "open",
        "prompt",
        "readOnly",
        "rev",
        "rowSpan",
        "rows",
        "rules",
        "scope",
        "selected",
        "shape",
        "size",
        "span",
        "start",
        "summary",
        "tabIndex",
        "title",
        "useMap",
        "vAlign",
        "value",
        "width"
      ]
    },
    clobber: ["ariaDescribedBy", "ariaLabelledBy", "id", "name"],
    clobberPrefix: "user-content-",
    protocols: {
      cite: ["http", "https"],
      href: ["http", "https", "irc", "ircs", "mailto", "xmpp"],
      longDesc: ["http", "https"],
      src: ["http", "https"]
    },
    required: {
      input: { disabled: true, type: "checkbox" }
    },
    strip: ["script"],
    tagNames: [
      "a",
      "b",
      "blockquote",
      "br",
      "code",
      "dd",
      "del",
      "details",
      "div",
      "dl",
      "dt",
      "em",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "hr",
      "i",
      "img",
      // Note: `input` is not normally allowed by GH, when manually writing
      // it in markdown, they add it from tasklists some other way.
      // We can’t do that, so we have to allow it.
      "input",
      "ins",
      "kbd",
      "li",
      "ol",
      "p",
      "picture",
      "pre",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "section",
      "source",
      "span",
      "strike",
      "strong",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "tr",
      "tt",
      "ul",
      "var"
    ]
  };
  const own$1 = {}.hasOwnProperty;
  function sanitize(node, options) {
    let result = { type: "root", children: [] };
    const state = {
      schema: options ? { ...defaultSchema, ...options } : defaultSchema,
      stack: []
    };
    const replace = transform$1(state, node);
    if (replace) {
      if (Array.isArray(replace)) {
        if (replace.length === 1) {
          result = replace[0];
        } else {
          result.children = replace;
        }
      } else {
        result = replace;
      }
    }
    return result;
  }
  function transform$1(state, node) {
    if (node && typeof node === "object") {
      const unsafe = (
        /** @type {Record<string, Readonly<unknown>>} */
        node
      );
      const type = typeof unsafe.type === "string" ? unsafe.type : "";
      switch (type) {
        case "comment": {
          return comment$1(state, unsafe);
        }
        case "doctype": {
          return doctype$1(state, unsafe);
        }
        case "element": {
          return element$1(state, unsafe);
        }
        case "root": {
          return root$1(state, unsafe);
        }
        case "text": {
          return text$1(state, unsafe);
        }
      }
    }
  }
  function comment$1(state, unsafe) {
    if (state.schema.allowComments) {
      const result = typeof unsafe.value === "string" ? unsafe.value : "";
      const index2 = result.indexOf("-->");
      const value = index2 < 0 ? result : result.slice(0, index2);
      const node = { type: "comment", value };
      patch(node, unsafe);
      return node;
    }
  }
  function doctype$1(state, unsafe) {
    if (state.schema.allowDoctypes) {
      const node = { type: "doctype" };
      patch(node, unsafe);
      return node;
    }
  }
  function element$1(state, unsafe) {
    const name2 = typeof unsafe.tagName === "string" ? unsafe.tagName : "";
    state.stack.push(name2);
    const content = (
      /** @type {Array<ElementContent>} */
      children(state, unsafe.children)
    );
    const properties_ = properties(state, unsafe.properties);
    state.stack.pop();
    let safeElement = false;
    if (name2 && name2 !== "*" && (!state.schema.tagNames || state.schema.tagNames.includes(name2))) {
      safeElement = true;
      if (state.schema.ancestors && own$1.call(state.schema.ancestors, name2)) {
        const ancestors = state.schema.ancestors[name2];
        let index2 = -1;
        safeElement = false;
        while (++index2 < ancestors.length) {
          if (state.stack.includes(ancestors[index2])) {
            safeElement = true;
          }
        }
      }
    }
    if (!safeElement) {
      return state.schema.strip && !state.schema.strip.includes(name2) ? content : void 0;
    }
    const node = {
      type: "element",
      tagName: name2,
      properties: properties_,
      children: content
    };
    patch(node, unsafe);
    return node;
  }
  function root$1(state, unsafe) {
    const content = (
      /** @type {Array<RootContent>} */
      children(state, unsafe.children)
    );
    const node = { type: "root", children: content };
    patch(node, unsafe);
    return node;
  }
  function text$1(_, unsafe) {
    const value = typeof unsafe.value === "string" ? unsafe.value : "";
    const node = { type: "text", value };
    patch(node, unsafe);
    return node;
  }
  function children(state, children2) {
    const results = [];
    if (Array.isArray(children2)) {
      const childrenUnknown = (
        /** @type {Array<Readonly<unknown>>} */
        children2
      );
      let index2 = -1;
      while (++index2 < childrenUnknown.length) {
        const value = transform$1(state, childrenUnknown[index2]);
        if (value) {
          if (Array.isArray(value)) {
            results.push(...value);
          } else {
            results.push(value);
          }
        }
      }
    }
    return results;
  }
  function properties(state, properties2) {
    const tagName = state.stack[state.stack.length - 1];
    const attributes = state.schema.attributes;
    const required = state.schema.required;
    const specific = attributes && own$1.call(attributes, tagName) ? attributes[tagName] : void 0;
    const defaults2 = attributes && own$1.call(attributes, "*") ? attributes["*"] : void 0;
    const properties_ = (
      /** @type {Readonly<Record<string, Readonly<unknown>>>} */
      properties2 && typeof properties2 === "object" ? properties2 : {}
    );
    const result = {};
    let key2;
    for (key2 in properties_) {
      if (own$1.call(properties_, key2)) {
        const unsafe = properties_[key2];
        let safe = propertyValue(
          state,
          findDefinition(specific, key2),
          key2,
          unsafe
        );
        if (safe === null || safe === void 0) {
          safe = propertyValue(state, findDefinition(defaults2, key2), key2, unsafe);
        }
        if (safe !== null && safe !== void 0) {
          result[key2] = safe;
        }
      }
    }
    if (required && own$1.call(required, tagName)) {
      const properties3 = required[tagName];
      for (key2 in properties3) {
        if (own$1.call(properties3, key2) && !own$1.call(result, key2)) {
          result[key2] = properties3[key2];
        }
      }
    }
    return result;
  }
  function propertyValue(state, definition, key2, value) {
    return definition ? Array.isArray(value) ? propertyValueMany(state, definition, key2, value) : propertyValuePrimitive(state, definition, key2, value) : void 0;
  }
  function propertyValueMany(state, definition, key2, values) {
    let index2 = -1;
    const result = [];
    while (++index2 < values.length) {
      const value = propertyValuePrimitive(state, definition, key2, values[index2]);
      if (typeof value === "number" || typeof value === "string") {
        result.push(value);
      }
    }
    return result;
  }
  function propertyValuePrimitive(state, definition, key2, value) {
    if (typeof value !== "boolean" && typeof value !== "number" && typeof value !== "string") {
      return;
    }
    if (!safeProtocol(state, key2, value)) {
      return;
    }
    if (typeof definition === "object" && definition.length > 1) {
      let ok = false;
      let index2 = 0;
      while (++index2 < definition.length) {
        const allowed = definition[index2];
        if (allowed && typeof allowed === "object" && "flags" in allowed) {
          if (allowed.test(String(value))) {
            ok = true;
            break;
          }
        } else if (allowed === value) {
          ok = true;
          break;
        }
      }
      if (!ok) return;
    }
    return state.schema.clobber && state.schema.clobberPrefix && state.schema.clobber.includes(key2) ? state.schema.clobberPrefix + value : value;
  }
  function safeProtocol(state, key2, value) {
    const protocols = state.schema.protocols && own$1.call(state.schema.protocols, key2) ? state.schema.protocols[key2] : void 0;
    if (!protocols || protocols.length === 0) {
      return true;
    }
    const url2 = String(value);
    const colon = url2.indexOf(":");
    const questionMark = url2.indexOf("?");
    const numberSign = url2.indexOf("#");
    const slash = url2.indexOf("/");
    if (colon < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign) {
      return true;
    }
    let index2 = -1;
    while (++index2 < protocols.length) {
      const protocol = protocols[index2];
      if (colon === protocol.length && url2.slice(0, protocol.length) === protocol) {
        return true;
      }
    }
    return false;
  }
  function patch(node, unsafe) {
    const cleanPosition = position(
      // @ts-expect-error: looks like a node.
      unsafe
    );
    if (unsafe.data) {
      node.data = structuredClone$1(unsafe.data);
    }
    if (cleanPosition) node.position = cleanPosition;
  }
  function findDefinition(definitions, key2) {
    let dataDefault;
    let index2 = -1;
    if (definitions) {
      while (++index2 < definitions.length) {
        const entry = definitions[index2];
        const name2 = typeof entry === "string" ? entry : entry[0];
        if (name2 === key2) {
          return entry;
        }
        if (name2 === "data*") dataDefault = entry;
      }
    }
    if (key2.length > 4 && key2.slice(0, 4).toLowerCase() === "data") {
      return dataDefault;
    }
  }
  class Schema {
    /**
     * @param {SchemaType['property']} property
     *   Property.
     * @param {SchemaType['normal']} normal
     *   Normal.
     * @param {Space | undefined} [space]
     *   Space.
     * @returns
     *   Schema.
     */
    constructor(property, normal, space) {
      this.normal = normal;
      this.property = property;
      if (space) {
        this.space = space;
      }
    }
  }
  Schema.prototype.normal = {};
  Schema.prototype.property = {};
  Schema.prototype.space = void 0;
  function merge(definitions, space) {
    const property = {};
    const normal = {};
    for (const definition of definitions) {
      Object.assign(property, definition.property);
      Object.assign(normal, definition.normal);
    }
    return new Schema(property, normal, space);
  }
  function normalize(value) {
    return value.toLowerCase();
  }
  class Info {
    /**
     * @param {string} property
     *   Property.
     * @param {string} attribute
     *   Attribute.
     * @returns
     *   Info.
     */
    constructor(property, attribute) {
      this.attribute = attribute;
      this.property = property;
    }
  }
  Info.prototype.attribute = "";
  Info.prototype.booleanish = false;
  Info.prototype.boolean = false;
  Info.prototype.commaOrSpaceSeparated = false;
  Info.prototype.commaSeparated = false;
  Info.prototype.defined = false;
  Info.prototype.mustUseProperty = false;
  Info.prototype.number = false;
  Info.prototype.overloadedBoolean = false;
  Info.prototype.property = "";
  Info.prototype.spaceSeparated = false;
  Info.prototype.space = void 0;
  let powers = 0;
  const boolean = increment();
  const booleanish = increment();
  const overloadedBoolean = increment();
  const number$1 = increment();
  const spaceSeparated = increment();
  const commaSeparated = increment();
  const commaOrSpaceSeparated = increment();
  function increment() {
    return 2 ** ++powers;
  }
  const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    boolean,
    booleanish,
    commaOrSpaceSeparated,
    commaSeparated,
    number: number$1,
    overloadedBoolean,
    spaceSeparated
  }, Symbol.toStringTag, { value: "Module" }));
  const checks = (
    /** @type {ReadonlyArray<keyof typeof types>} */
    Object.keys(types)
  );
  class DefinedInfo extends Info {
    /**
     * @constructor
     * @param {string} property
     *   Property.
     * @param {string} attribute
     *   Attribute.
     * @param {number | null | undefined} [mask]
     *   Mask.
     * @param {Space | undefined} [space]
     *   Space.
     * @returns
     *   Info.
     */
    constructor(property, attribute, mask, space) {
      let index2 = -1;
      super(property, attribute);
      mark(this, "space", space);
      if (typeof mask === "number") {
        while (++index2 < checks.length) {
          const check = checks[index2];
          mark(this, checks[index2], (mask & types[check]) === types[check]);
        }
      }
    }
  }
  DefinedInfo.prototype.defined = true;
  function mark(values, key2, value) {
    if (value) {
      values[key2] = value;
    }
  }
  function create(definition) {
    const properties2 = {};
    const normals = {};
    for (const [property, value] of Object.entries(definition.properties)) {
      const info = new DefinedInfo(
        property,
        definition.transform(definition.attributes || {}, property),
        value,
        definition.space
      );
      if (definition.mustUseProperty && definition.mustUseProperty.includes(property)) {
        info.mustUseProperty = true;
      }
      properties2[property] = info;
      normals[normalize(property)] = property;
      normals[normalize(info.attribute)] = property;
    }
    return new Schema(properties2, normals, definition.space);
  }
  const aria = create({
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: booleanish,
      ariaAutoComplete: null,
      ariaBusy: booleanish,
      ariaChecked: booleanish,
      ariaColCount: number$1,
      ariaColIndex: number$1,
      ariaColSpan: number$1,
      ariaControls: spaceSeparated,
      ariaCurrent: null,
      ariaDescribedBy: spaceSeparated,
      ariaDetails: null,
      ariaDisabled: booleanish,
      ariaDropEffect: spaceSeparated,
      ariaErrorMessage: null,
      ariaExpanded: booleanish,
      ariaFlowTo: spaceSeparated,
      ariaGrabbed: booleanish,
      ariaHasPopup: null,
      ariaHidden: booleanish,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: spaceSeparated,
      ariaLevel: number$1,
      ariaLive: null,
      ariaModal: booleanish,
      ariaMultiLine: booleanish,
      ariaMultiSelectable: booleanish,
      ariaOrientation: null,
      ariaOwns: spaceSeparated,
      ariaPlaceholder: null,
      ariaPosInSet: number$1,
      ariaPressed: booleanish,
      ariaReadOnly: booleanish,
      ariaRelevant: null,
      ariaRequired: booleanish,
      ariaRoleDescription: spaceSeparated,
      ariaRowCount: number$1,
      ariaRowIndex: number$1,
      ariaRowSpan: number$1,
      ariaSelected: booleanish,
      ariaSetSize: number$1,
      ariaSort: null,
      ariaValueMax: number$1,
      ariaValueMin: number$1,
      ariaValueNow: number$1,
      ariaValueText: null,
      role: null
    },
    transform(_, property) {
      return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
    }
  });
  function caseSensitiveTransform(attributes, attribute) {
    return attribute in attributes ? attributes[attribute] : attribute;
  }
  function caseInsensitiveTransform(attributes, property) {
    return caseSensitiveTransform(attributes, property.toLowerCase());
  }
  const html$1 = create({
    attributes: {
      acceptcharset: "accept-charset",
      classname: "class",
      htmlfor: "for",
      httpequiv: "http-equiv"
    },
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
      // Standard Properties.
      abbr: null,
      accept: commaSeparated,
      acceptCharset: spaceSeparated,
      accessKey: spaceSeparated,
      action: null,
      allow: null,
      allowFullScreen: boolean,
      allowPaymentRequest: boolean,
      allowUserMedia: boolean,
      alt: null,
      as: null,
      async: boolean,
      autoCapitalize: null,
      autoComplete: spaceSeparated,
      autoFocus: boolean,
      autoPlay: boolean,
      blocking: spaceSeparated,
      capture: null,
      charSet: null,
      checked: boolean,
      cite: null,
      className: spaceSeparated,
      cols: number$1,
      colSpan: null,
      content: null,
      contentEditable: booleanish,
      controls: boolean,
      controlsList: spaceSeparated,
      coords: number$1 | commaSeparated,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: boolean,
      defer: boolean,
      dir: null,
      dirName: null,
      disabled: boolean,
      download: overloadedBoolean,
      draggable: booleanish,
      encType: null,
      enterKeyHint: null,
      fetchPriority: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: boolean,
      formTarget: null,
      headers: spaceSeparated,
      height: number$1,
      hidden: boolean,
      high: number$1,
      href: null,
      hrefLang: null,
      htmlFor: spaceSeparated,
      httpEquiv: spaceSeparated,
      id: null,
      imageSizes: null,
      imageSrcSet: null,
      inert: boolean,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: boolean,
      itemId: null,
      itemProp: spaceSeparated,
      itemRef: spaceSeparated,
      itemScope: boolean,
      itemType: spaceSeparated,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: boolean,
      low: number$1,
      manifest: null,
      max: null,
      maxLength: number$1,
      media: null,
      method: null,
      min: null,
      minLength: number$1,
      multiple: boolean,
      muted: boolean,
      name: null,
      nonce: null,
      noModule: boolean,
      noValidate: boolean,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforeMatch: null,
      onBeforePrint: null,
      onBeforeToggle: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextLost: null,
      onContextMenu: null,
      onContextRestored: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onScrollEnd: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: boolean,
      optimum: number$1,
      pattern: null,
      ping: spaceSeparated,
      placeholder: null,
      playsInline: boolean,
      popover: null,
      popoverTarget: null,
      popoverTargetAction: null,
      poster: null,
      preload: null,
      readOnly: boolean,
      referrerPolicy: null,
      rel: spaceSeparated,
      required: boolean,
      reversed: boolean,
      rows: number$1,
      rowSpan: number$1,
      sandbox: spaceSeparated,
      scope: null,
      scoped: boolean,
      seamless: boolean,
      selected: boolean,
      shadowRootClonable: boolean,
      shadowRootDelegatesFocus: boolean,
      shadowRootMode: null,
      shape: null,
      size: number$1,
      sizes: null,
      slot: null,
      span: number$1,
      spellCheck: booleanish,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: null,
      start: number$1,
      step: null,
      style: null,
      tabIndex: number$1,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: boolean,
      useMap: null,
      value: booleanish,
      width: number$1,
      wrap: null,
      writingSuggestions: null,
      // Legacy.
      // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
      align: null,
      // Several. Use CSS `text-align` instead,
      aLink: null,
      // `<body>`. Use CSS `a:active {color}` instead
      archive: spaceSeparated,
      // `<object>`. List of URIs to archives
      axis: null,
      // `<td>` and `<th>`. Use `scope` on `<th>`
      background: null,
      // `<body>`. Use CSS `background-image` instead
      bgColor: null,
      // `<body>` and table elements. Use CSS `background-color` instead
      border: number$1,
      // `<table>`. Use CSS `border-width` instead,
      borderColor: null,
      // `<table>`. Use CSS `border-color` instead,
      bottomMargin: number$1,
      // `<body>`
      cellPadding: null,
      // `<table>`
      cellSpacing: null,
      // `<table>`
      char: null,
      // Several table elements. When `align=char`, sets the character to align on
      charOff: null,
      // Several table elements. When `char`, offsets the alignment
      classId: null,
      // `<object>`
      clear: null,
      // `<br>`. Use CSS `clear` instead
      code: null,
      // `<object>`
      codeBase: null,
      // `<object>`
      codeType: null,
      // `<object>`
      color: null,
      // `<font>` and `<hr>`. Use CSS instead
      compact: boolean,
      // Lists. Use CSS to reduce space between items instead
      declare: boolean,
      // `<object>`
      event: null,
      // `<script>`
      face: null,
      // `<font>`. Use CSS instead
      frame: null,
      // `<table>`
      frameBorder: null,
      // `<iframe>`. Use CSS `border` instead
      hSpace: number$1,
      // `<img>` and `<object>`
      leftMargin: number$1,
      // `<body>`
      link: null,
      // `<body>`. Use CSS `a:link {color: *}` instead
      longDesc: null,
      // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
      lowSrc: null,
      // `<img>`. Use a `<picture>`
      marginHeight: number$1,
      // `<body>`
      marginWidth: number$1,
      // `<body>`
      noResize: boolean,
      // `<frame>`
      noHref: boolean,
      // `<area>`. Use no href instead of an explicit `nohref`
      noShade: boolean,
      // `<hr>`. Use background-color and height instead of borders
      noWrap: boolean,
      // `<td>` and `<th>`
      object: null,
      // `<applet>`
      profile: null,
      // `<head>`
      prompt: null,
      // `<isindex>`
      rev: null,
      // `<link>`
      rightMargin: number$1,
      // `<body>`
      rules: null,
      // `<table>`
      scheme: null,
      // `<meta>`
      scrolling: booleanish,
      // `<frame>`. Use overflow in the child context
      standby: null,
      // `<object>`
      summary: null,
      // `<table>`
      text: null,
      // `<body>`. Use CSS `color` instead
      topMargin: number$1,
      // `<body>`
      valueType: null,
      // `<param>`
      version: null,
      // `<html>`. Use a doctype.
      vAlign: null,
      // Several. Use CSS `vertical-align` instead
      vLink: null,
      // `<body>`. Use CSS `a:visited {color}` instead
      vSpace: number$1,
      // `<img>` and `<object>`
      // Non-standard Properties.
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: boolean,
      disableRemotePlayback: boolean,
      prefix: null,
      property: null,
      results: number$1,
      security: null,
      unselectable: null
    },
    space: "html",
    transform: caseInsensitiveTransform
  });
  const svg$1 = create({
    attributes: {
      accentHeight: "accent-height",
      alignmentBaseline: "alignment-baseline",
      arabicForm: "arabic-form",
      baselineShift: "baseline-shift",
      capHeight: "cap-height",
      className: "class",
      clipPath: "clip-path",
      clipRule: "clip-rule",
      colorInterpolation: "color-interpolation",
      colorInterpolationFilters: "color-interpolation-filters",
      colorProfile: "color-profile",
      colorRendering: "color-rendering",
      crossOrigin: "crossorigin",
      dataType: "datatype",
      dominantBaseline: "dominant-baseline",
      enableBackground: "enable-background",
      fillOpacity: "fill-opacity",
      fillRule: "fill-rule",
      floodColor: "flood-color",
      floodOpacity: "flood-opacity",
      fontFamily: "font-family",
      fontSize: "font-size",
      fontSizeAdjust: "font-size-adjust",
      fontStretch: "font-stretch",
      fontStyle: "font-style",
      fontVariant: "font-variant",
      fontWeight: "font-weight",
      glyphName: "glyph-name",
      glyphOrientationHorizontal: "glyph-orientation-horizontal",
      glyphOrientationVertical: "glyph-orientation-vertical",
      hrefLang: "hreflang",
      horizAdvX: "horiz-adv-x",
      horizOriginX: "horiz-origin-x",
      horizOriginY: "horiz-origin-y",
      imageRendering: "image-rendering",
      letterSpacing: "letter-spacing",
      lightingColor: "lighting-color",
      markerEnd: "marker-end",
      markerMid: "marker-mid",
      markerStart: "marker-start",
      navDown: "nav-down",
      navDownLeft: "nav-down-left",
      navDownRight: "nav-down-right",
      navLeft: "nav-left",
      navNext: "nav-next",
      navPrev: "nav-prev",
      navRight: "nav-right",
      navUp: "nav-up",
      navUpLeft: "nav-up-left",
      navUpRight: "nav-up-right",
      onAbort: "onabort",
      onActivate: "onactivate",
      onAfterPrint: "onafterprint",
      onBeforePrint: "onbeforeprint",
      onBegin: "onbegin",
      onCancel: "oncancel",
      onCanPlay: "oncanplay",
      onCanPlayThrough: "oncanplaythrough",
      onChange: "onchange",
      onClick: "onclick",
      onClose: "onclose",
      onCopy: "oncopy",
      onCueChange: "oncuechange",
      onCut: "oncut",
      onDblClick: "ondblclick",
      onDrag: "ondrag",
      onDragEnd: "ondragend",
      onDragEnter: "ondragenter",
      onDragExit: "ondragexit",
      onDragLeave: "ondragleave",
      onDragOver: "ondragover",
      onDragStart: "ondragstart",
      onDrop: "ondrop",
      onDurationChange: "ondurationchange",
      onEmptied: "onemptied",
      onEnd: "onend",
      onEnded: "onended",
      onError: "onerror",
      onFocus: "onfocus",
      onFocusIn: "onfocusin",
      onFocusOut: "onfocusout",
      onHashChange: "onhashchange",
      onInput: "oninput",
      onInvalid: "oninvalid",
      onKeyDown: "onkeydown",
      onKeyPress: "onkeypress",
      onKeyUp: "onkeyup",
      onLoad: "onload",
      onLoadedData: "onloadeddata",
      onLoadedMetadata: "onloadedmetadata",
      onLoadStart: "onloadstart",
      onMessage: "onmessage",
      onMouseDown: "onmousedown",
      onMouseEnter: "onmouseenter",
      onMouseLeave: "onmouseleave",
      onMouseMove: "onmousemove",
      onMouseOut: "onmouseout",
      onMouseOver: "onmouseover",
      onMouseUp: "onmouseup",
      onMouseWheel: "onmousewheel",
      onOffline: "onoffline",
      onOnline: "ononline",
      onPageHide: "onpagehide",
      onPageShow: "onpageshow",
      onPaste: "onpaste",
      onPause: "onpause",
      onPlay: "onplay",
      onPlaying: "onplaying",
      onPopState: "onpopstate",
      onProgress: "onprogress",
      onRateChange: "onratechange",
      onRepeat: "onrepeat",
      onReset: "onreset",
      onResize: "onresize",
      onScroll: "onscroll",
      onSeeked: "onseeked",
      onSeeking: "onseeking",
      onSelect: "onselect",
      onShow: "onshow",
      onStalled: "onstalled",
      onStorage: "onstorage",
      onSubmit: "onsubmit",
      onSuspend: "onsuspend",
      onTimeUpdate: "ontimeupdate",
      onToggle: "ontoggle",
      onUnload: "onunload",
      onVolumeChange: "onvolumechange",
      onWaiting: "onwaiting",
      onZoom: "onzoom",
      overlinePosition: "overline-position",
      overlineThickness: "overline-thickness",
      paintOrder: "paint-order",
      panose1: "panose-1",
      pointerEvents: "pointer-events",
      referrerPolicy: "referrerpolicy",
      renderingIntent: "rendering-intent",
      shapeRendering: "shape-rendering",
      stopColor: "stop-color",
      stopOpacity: "stop-opacity",
      strikethroughPosition: "strikethrough-position",
      strikethroughThickness: "strikethrough-thickness",
      strokeDashArray: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeLineCap: "stroke-linecap",
      strokeLineJoin: "stroke-linejoin",
      strokeMiterLimit: "stroke-miterlimit",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      tabIndex: "tabindex",
      textAnchor: "text-anchor",
      textDecoration: "text-decoration",
      textRendering: "text-rendering",
      transformOrigin: "transform-origin",
      typeOf: "typeof",
      underlinePosition: "underline-position",
      underlineThickness: "underline-thickness",
      unicodeBidi: "unicode-bidi",
      unicodeRange: "unicode-range",
      unitsPerEm: "units-per-em",
      vAlphabetic: "v-alphabetic",
      vHanging: "v-hanging",
      vIdeographic: "v-ideographic",
      vMathematical: "v-mathematical",
      vectorEffect: "vector-effect",
      vertAdvY: "vert-adv-y",
      vertOriginX: "vert-origin-x",
      vertOriginY: "vert-origin-y",
      wordSpacing: "word-spacing",
      writingMode: "writing-mode",
      xHeight: "x-height",
      // These were camelcased in Tiny. Now lowercased in SVG 2
      playbackOrder: "playbackorder",
      timelineBegin: "timelinebegin"
    },
    properties: {
      about: commaOrSpaceSeparated,
      accentHeight: number$1,
      accumulate: null,
      additive: null,
      alignmentBaseline: null,
      alphabetic: number$1,
      amplitude: number$1,
      arabicForm: null,
      ascent: number$1,
      attributeName: null,
      attributeType: null,
      azimuth: number$1,
      bandwidth: null,
      baselineShift: null,
      baseFrequency: null,
      baseProfile: null,
      bbox: null,
      begin: null,
      bias: number$1,
      by: null,
      calcMode: null,
      capHeight: number$1,
      className: spaceSeparated,
      clip: null,
      clipPath: null,
      clipPathUnits: null,
      clipRule: null,
      color: null,
      colorInterpolation: null,
      colorInterpolationFilters: null,
      colorProfile: null,
      colorRendering: null,
      content: null,
      contentScriptType: null,
      contentStyleType: null,
      crossOrigin: null,
      cursor: null,
      cx: null,
      cy: null,
      d: null,
      dataType: null,
      defaultAction: null,
      descent: number$1,
      diffuseConstant: number$1,
      direction: null,
      display: null,
      dur: null,
      divisor: number$1,
      dominantBaseline: null,
      download: boolean,
      dx: null,
      dy: null,
      edgeMode: null,
      editable: null,
      elevation: number$1,
      enableBackground: null,
      end: null,
      event: null,
      exponent: number$1,
      externalResourcesRequired: null,
      fill: null,
      fillOpacity: number$1,
      fillRule: null,
      filter: null,
      filterRes: null,
      filterUnits: null,
      floodColor: null,
      floodOpacity: null,
      focusable: null,
      focusHighlight: null,
      fontFamily: null,
      fontSize: null,
      fontSizeAdjust: null,
      fontStretch: null,
      fontStyle: null,
      fontVariant: null,
      fontWeight: null,
      format: null,
      fr: null,
      from: null,
      fx: null,
      fy: null,
      g1: commaSeparated,
      g2: commaSeparated,
      glyphName: commaSeparated,
      glyphOrientationHorizontal: null,
      glyphOrientationVertical: null,
      glyphRef: null,
      gradientTransform: null,
      gradientUnits: null,
      handler: null,
      hanging: number$1,
      hatchContentUnits: null,
      hatchUnits: null,
      height: null,
      href: null,
      hrefLang: null,
      horizAdvX: number$1,
      horizOriginX: number$1,
      horizOriginY: number$1,
      id: null,
      ideographic: number$1,
      imageRendering: null,
      initialVisibility: null,
      in: null,
      in2: null,
      intercept: number$1,
      k: number$1,
      k1: number$1,
      k2: number$1,
      k3: number$1,
      k4: number$1,
      kernelMatrix: commaOrSpaceSeparated,
      kernelUnitLength: null,
      keyPoints: null,
      // SEMI_COLON_SEPARATED
      keySplines: null,
      // SEMI_COLON_SEPARATED
      keyTimes: null,
      // SEMI_COLON_SEPARATED
      kerning: null,
      lang: null,
      lengthAdjust: null,
      letterSpacing: null,
      lightingColor: null,
      limitingConeAngle: number$1,
      local: null,
      markerEnd: null,
      markerMid: null,
      markerStart: null,
      markerHeight: null,
      markerUnits: null,
      markerWidth: null,
      mask: null,
      maskContentUnits: null,
      maskUnits: null,
      mathematical: null,
      max: null,
      media: null,
      mediaCharacterEncoding: null,
      mediaContentEncodings: null,
      mediaSize: number$1,
      mediaTime: null,
      method: null,
      min: null,
      mode: null,
      name: null,
      navDown: null,
      navDownLeft: null,
      navDownRight: null,
      navLeft: null,
      navNext: null,
      navPrev: null,
      navRight: null,
      navUp: null,
      navUpLeft: null,
      navUpRight: null,
      numOctaves: null,
      observer: null,
      offset: null,
      onAbort: null,
      onActivate: null,
      onAfterPrint: null,
      onBeforePrint: null,
      onBegin: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnd: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFocusIn: null,
      onFocusOut: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadStart: null,
      onMessage: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onMouseWheel: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRepeat: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onShow: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onZoom: null,
      opacity: null,
      operator: null,
      order: null,
      orient: null,
      orientation: null,
      origin: null,
      overflow: null,
      overlay: null,
      overlinePosition: number$1,
      overlineThickness: number$1,
      paintOrder: null,
      panose1: null,
      path: null,
      pathLength: number$1,
      patternContentUnits: null,
      patternTransform: null,
      patternUnits: null,
      phase: null,
      ping: spaceSeparated,
      pitch: null,
      playbackOrder: null,
      pointerEvents: null,
      points: null,
      pointsAtX: number$1,
      pointsAtY: number$1,
      pointsAtZ: number$1,
      preserveAlpha: null,
      preserveAspectRatio: null,
      primitiveUnits: null,
      propagate: null,
      property: commaOrSpaceSeparated,
      r: null,
      radius: null,
      referrerPolicy: null,
      refX: null,
      refY: null,
      rel: commaOrSpaceSeparated,
      rev: commaOrSpaceSeparated,
      renderingIntent: null,
      repeatCount: null,
      repeatDur: null,
      requiredExtensions: commaOrSpaceSeparated,
      requiredFeatures: commaOrSpaceSeparated,
      requiredFonts: commaOrSpaceSeparated,
      requiredFormats: commaOrSpaceSeparated,
      resource: null,
      restart: null,
      result: null,
      rotate: null,
      rx: null,
      ry: null,
      scale: null,
      seed: null,
      shapeRendering: null,
      side: null,
      slope: null,
      snapshotTime: null,
      specularConstant: number$1,
      specularExponent: number$1,
      spreadMethod: null,
      spacing: null,
      startOffset: null,
      stdDeviation: null,
      stemh: null,
      stemv: null,
      stitchTiles: null,
      stopColor: null,
      stopOpacity: null,
      strikethroughPosition: number$1,
      strikethroughThickness: number$1,
      string: null,
      stroke: null,
      strokeDashArray: commaOrSpaceSeparated,
      strokeDashOffset: null,
      strokeLineCap: null,
      strokeLineJoin: null,
      strokeMiterLimit: number$1,
      strokeOpacity: number$1,
      strokeWidth: null,
      style: null,
      surfaceScale: number$1,
      syncBehavior: null,
      syncBehaviorDefault: null,
      syncMaster: null,
      syncTolerance: null,
      syncToleranceDefault: null,
      systemLanguage: commaOrSpaceSeparated,
      tabIndex: number$1,
      tableValues: null,
      target: null,
      targetX: number$1,
      targetY: number$1,
      textAnchor: null,
      textDecoration: null,
      textRendering: null,
      textLength: null,
      timelineBegin: null,
      title: null,
      transformBehavior: null,
      type: null,
      typeOf: commaOrSpaceSeparated,
      to: null,
      transform: null,
      transformOrigin: null,
      u1: null,
      u2: null,
      underlinePosition: number$1,
      underlineThickness: number$1,
      unicode: null,
      unicodeBidi: null,
      unicodeRange: null,
      unitsPerEm: number$1,
      values: null,
      vAlphabetic: number$1,
      vMathematical: number$1,
      vectorEffect: null,
      vHanging: number$1,
      vIdeographic: number$1,
      version: null,
      vertAdvY: number$1,
      vertOriginX: number$1,
      vertOriginY: number$1,
      viewBox: null,
      viewTarget: null,
      visibility: null,
      width: null,
      widths: null,
      wordSpacing: null,
      writingMode: null,
      x: null,
      x1: null,
      x2: null,
      xChannelSelector: null,
      xHeight: number$1,
      y: null,
      y1: null,
      y2: null,
      yChannelSelector: null,
      z: null,
      zoomAndPan: null
    },
    space: "svg",
    transform: caseSensitiveTransform
  });
  const xlink = create({
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null
    },
    space: "xlink",
    transform(_, property) {
      return "xlink:" + property.slice(5).toLowerCase();
    }
  });
  const xmlns = create({
    attributes: { xmlnsxlink: "xmlns:xlink" },
    properties: { xmlnsXLink: null, xmlns: null },
    space: "xmlns",
    transform: caseInsensitiveTransform
  });
  const xml = create({
    properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
    space: "xml",
    transform(_, property) {
      return "xml:" + property.slice(3).toLowerCase();
    }
  });
  const cap = /[A-Z]/g;
  const dash = /-[a-z]/g;
  const valid = /^data[-\w.:]+$/i;
  function find(schema, value) {
    const normal = normalize(value);
    let property = value;
    let Type = Info;
    if (normal in schema.normal) {
      return schema.property[schema.normal[normal]];
    }
    if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
      if (value.charAt(4) === "-") {
        const rest = value.slice(5).replace(dash, camelcase);
        property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
      } else {
        const rest = value.slice(4);
        if (!dash.test(rest)) {
          let dashes = rest.replace(cap, kebab);
          if (dashes.charAt(0) !== "-") {
            dashes = "-" + dashes;
          }
          value = "data" + dashes;
        }
      }
      Type = DefinedInfo;
    }
    return new Type(property, value);
  }
  function kebab($0) {
    return "-" + $0.toLowerCase();
  }
  function camelcase($0) {
    return $0.charAt(1).toUpperCase();
  }
  const html = merge([aria, html$1, xlink, xmlns, xml], "html");
  const svg = merge([aria, svg$1, xlink, xmlns, xml], "svg");
  const webNamespaces = {
    html: "http://www.w3.org/1999/xhtml",
    svg: "http://www.w3.org/2000/svg"
  };
  const own = {}.hasOwnProperty;
  function toDom(tree, options) {
    const config2 = {};
    return transform(tree, {
      doc: config2.document || document,
      fragment: config2.fragment || false,
      namespace: config2.namespace || void 0,
      impliedNamespace: void 0,
      afterTransform: config2.afterTransform || void 0
    });
  }
  function transform(node, state) {
    const transformed = one(node, state);
    if (state.afterTransform) state.afterTransform(node, transformed);
    return transformed;
  }
  function one(node, state) {
    switch (node.type) {
      case "root": {
        return root(node, state);
      }
      case "text": {
        return text(node, state);
      }
      case "doctype": {
        return doctype(node, state);
      }
      case "comment": {
        return comment(node, state);
      }
      default: {
        return element(node, state);
      }
    }
  }
  function root(node, state) {
    const children2 = node.children || [];
    let rootIsDocument = children2.length === 0;
    let index2 = -1;
    let foundNamespace;
    while (++index2 < children2.length) {
      const child = children2[index2];
      if (child.type === "element" && child.tagName === "html") {
        rootIsDocument = true;
        foundNamespace = String(child.properties && child.properties.xmlns || "") || webNamespaces.html;
        break;
      }
    }
    const namespace = state.namespace || foundNamespace;
    let result;
    if (rootIsDocument) {
      result = state.doc.implementation.createDocument(
        // Note: `null` is different from `undefined`.
        namespace || null,
        ""
      );
    } else if (state.fragment) {
      result = state.doc.createDocumentFragment();
    } else {
      result = state.doc.createElement("html");
    }
    appendAll(result, children2, {
      ...state,
      namespace,
      impliedNamespace: namespace
    });
    return result;
  }
  function doctype(_, state) {
    return state.doc.implementation.createDocumentType("html", "", "");
  }
  function text(node, state) {
    return state.doc.createTextNode(node.value);
  }
  function comment(node, state) {
    return state.doc.createComment(node.value);
  }
  function element(node, state) {
    let impliedNamespace = state.impliedNamespace || state.namespace;
    const tagName = node.tagName || (impliedNamespace === webNamespaces.svg ? "g" : "div");
    const properties2 = node.properties || {};
    const children2 = node.children || [];
    if ((impliedNamespace === void 0 || impliedNamespace === webNamespaces.html) && tagName === "svg") {
      impliedNamespace = webNamespaces.svg;
    }
    const result = impliedNamespace ? state.doc.createElementNS(impliedNamespace, tagName) : state.doc.createElement(tagName);
    addProperties(
      result,
      properties2,
      impliedNamespace === webNamespaces.svg ? svg : html
    );
    const currentImpliedNamespace = state.impliedNamespace;
    state.impliedNamespace = impliedNamespace;
    appendAll(result, children2, state);
    state.impliedNamespace = currentImpliedNamespace;
    return result;
  }
  function addProperties(result, properties2, schema) {
    let key2;
    for (key2 in properties2) {
      if (own.call(properties2, key2)) {
        const info = find(schema, key2);
        let value = properties2[key2];
        if (Array.isArray(value)) {
          value = value.join(info.commaSeparated ? ", " : " ");
        }
        if (info.mustUseProperty) {
          result[info.property] = value;
        }
        if (info.boolean || info.overloadedBoolean && typeof value === "boolean") {
          if (value) {
            result.setAttribute(info.attribute, "");
          }
        } else if (info.booleanish) {
          result.setAttribute(info.attribute, String(value));
        } else if (value === true) {
          result.setAttribute(info.attribute, "");
        } else if (value || value === 0 || value === "") {
          result.setAttribute(info.attribute, String(value));
        }
      }
    }
  }
  function appendAll(node, children2, state) {
    let index2 = -1;
    while (++index2 < children2.length) {
      node.append(transform(children2[index2], state));
    }
  }
  var cjs;
  var hasRequiredCjs;
  function requireCjs() {
    if (hasRequiredCjs) return cjs;
    hasRequiredCjs = 1;
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element2) {
        return cloneUnlessOtherwiseSpecified(element2, options);
      });
    }
    function getMergeFunction(key2, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key2);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key2) {
      return propertyIsOnObject(target, key2) && !(Object.hasOwnProperty.call(target, key2) && Object.propertyIsEnumerable.call(target, key2));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key2) {
          destination[key2] = cloneUnlessOtherwiseSpecified(target[key2], options);
        });
      }
      getKeys(source).forEach(function(key2) {
        if (propertyIsUnsafe(target, key2)) {
          return;
        }
        if (propertyIsOnObject(target, key2) && options.isMergeableObject(source[key2])) {
          destination[key2] = getMergeFunction(key2, options)(target[key2], source[key2], options);
        } else {
          destination[key2] = cloneUnlessOtherwiseSpecified(source[key2], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge2(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    cjs = deepmerge_1;
    return cjs;
  }
  var cjsExports = requireCjs();
  const deepmerge = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports);
  const hastSanitizeSchema = deepmerge(
    defaultSchema,
    {
      attributes: {
        "*": [
          "className",
          // SVG
          "accentHeight",
          "accumulate",
          "additivive",
          "alignmentBaseline",
          "ascent",
          "attributeName",
          "attributeType",
          "azimuth",
          "baseFrequency",
          "baselineShift",
          "begin",
          "bias",
          "by",
          "clip",
          "clipPath",
          "clipRule",
          "color",
          "colorInterpolation",
          "colorInterpolationFilters",
          "colorProfile",
          "colorRendering",
          "cx",
          "cy",
          "d",
          "dx",
          "dy",
          "diffuseConstant",
          "direction",
          "display",
          "divisor",
          "dominantBaseline",
          "dur",
          "edgemode",
          "elevation",
          "end",
          "fill",
          "fillOpacity",
          "fillRule",
          "filter",
          "filterUnits",
          "floodColor",
          "floodOpacity",
          "fontFamily",
          "fontSize",
          "fontSizeAdjust",
          "fontStretch",
          "fontStyle",
          "fontVariant",
          "fontWeight",
          "fx",
          "fy",
          "g1",
          "g2",
          "glyphName",
          "glyphRef",
          "gradientUnits",
          "gradientTransform",
          "height",
          "href",
          "id",
          "imageRendering",
          "in",
          "in2",
          "k",
          "k1",
          "k2",
          "k3",
          "k4",
          "kerning",
          "keyPoints",
          "keySplines",
          "keyTimes",
          "lang",
          "lengthAdjust",
          "letterSpacing",
          "kernelMatrix",
          "kernelUnitLength",
          "lightingColor",
          "local",
          "markerEnd",
          "markerMid",
          "markerStart",
          "markerHeight",
          "markerUnits",
          "markerWidth",
          "maskContentUnits",
          "maskUnits",
          "max",
          "mask",
          "media",
          "method",
          "mode",
          "min",
          "name",
          "numOctaves",
          "offset",
          "operator",
          "opacity",
          "order",
          "orient",
          "orientation",
          "origin",
          "overflow",
          "paintOrder",
          "path",
          "pathLength",
          "patternContentUnits",
          "patternTransform",
          "patternUnits",
          "points",
          "preserveAlpha",
          "preserveAspectRatio",
          "r",
          "rx",
          "ry",
          "radius",
          "refX",
          "refY",
          "repeatCount",
          "repeatDur",
          "restart",
          "result",
          "rotate",
          "scale",
          "seed",
          "shapeRendering",
          "specularConstant",
          "specularExponent",
          "spreadmethod",
          "stdDeviation",
          "stitchTiles",
          "stopColor",
          "stopOpacity",
          "strokeDasharray",
          "strokeDashoffset",
          "strokeLinecap",
          "strokeLinejoin",
          "strokeMiterlimit",
          "strokeOpacity",
          "stroke",
          "strokeWidth",
          "style",
          "surfaceScale",
          "tabindex",
          "targetX",
          "targetY",
          "transform",
          "textAnchor",
          "textDecoration",
          "textRendering",
          "textLength",
          "type",
          "u1",
          "u2",
          "unicode",
          "values",
          "viewBox",
          "visibility",
          "vectorEffect",
          "vertAdvY",
          "vertOriginX",
          "vertOriginY",
          "width",
          "wordSpacing",
          "wrap",
          "writingMode",
          "xChannelSelector",
          "yChannelSelector",
          "x",
          "x1",
          "x2",
          "xmlns",
          "y",
          "y1",
          "y2",
          "z",
          "zoomAndPan"
        ]
      },
      tagNames: [
        // SVG
        "svg",
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "circle",
        "clipPath",
        "defs",
        "desc",
        "ellipse",
        "filter",
        "font",
        "g",
        "glyph",
        "glyphRef",
        "hkern",
        "image",
        "line",
        "linearGradient",
        "marker",
        "mask",
        "metadata",
        "mpath",
        "path",
        "pattern",
        "polygon",
        "polyline",
        "radialGradient",
        "rect",
        "stop",
        "switch",
        "symbol",
        "text",
        "textPath",
        "title",
        "tref",
        "tspan",
        "use",
        "view",
        "vkern",
        // SVG Filters
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence"
      ]
    }
  );
  const InjectSchema = (type) => SourceMappedObjectSchema.extend({
    inject: literalType(type)
  }).strict();
  const hasInSettings = (name2, has) => (value, ctx) => {
    if (!has) {
      ctx.addIssue({
        code: ZodIssueCode.custom,
        message: `Used '${name2}' inject while the corresponding setting is not defined in the animation's settings`,
        path: ["inject"]
      });
      return NEVER;
    }
    return value;
  };
  function InjectWithMeta(schema, {
    immediate = false,
    lazy = false,
    allowed = null
  } = {}) {
    if (Array.isArray(schema)) return schema;
    return [schema, { immediate, lazy, allowed }];
  }
  const buildSwitchSchema = (keys2, value = Defined) => Object.fromEntries([].concat(keys2).map((k) => [k.toString(), value]));
  function SwitchSchema(inject, valueList, options = {}) {
    const { currentValue, defaultValue, possibleValues, setting } = options;
    return (context) => {
      const get = (value) => typeof value === "function" ? value(context) : value;
      let values = get(valueList);
      let schema = InjectSchema(inject).extend(buildSwitchSchema(values, Defined.optional()));
      if (setting) schema = schema.transform(hasInSettings(inject, setting in context.settings));
      return schema.transform((params, ctx) => {
        params = clearSourceMap(params);
        if (get(possibleValues))
          values = values.filter((v) => get(possibleValues).includes(v));
        else if (setting && context.settings[setting] !== true)
          values = values.filter((v) => context.settings[setting].includes(v));
        let value = get(currentValue) ?? (setting && context[setting]);
        if (!values.includes(value)) value = defaultValue;
        if (values.some((k) => k in params))
          if (values.every((k) => k in params)) return params[value];
          else {
            ctx.addIssue({
              code: ZodIssueCode.custom,
              message: `All of the possible values must be defined in the '${inject}' inject when using switch mode. Missing keys: ${formatValuesList(values.filter((k) => !(k in params)))}`
            });
            return NEVER;
          }
        else return value;
      });
    };
  }
  function _queryElement(target, selector, multiple = false) {
    if (!target) return null;
    if (multiple) return Array.from(target.querySelectorAll(selector));
    return target.querySelector(selector);
  }
  function queryElement(ctx, target, selector, multiple = false) {
    try {
      const matched = _queryElement(target, selector, multiple);
      if (Array.isArray(matched) ? !matched.length : !matched) {
        ctx.addIssue({
          code: ZodIssueCode.custom,
          message: `Couldn't find any element${multiple ? "s" : ""} matching the selector: '${selector}'`
        });
        return NEVER;
      }
      return matched;
    } catch {
      ctx.addIssue({
        code: ZodIssueCode.custom,
        message: `Invalid selector: '${selector}'`
      });
      return NEVER;
    }
  }
  function ElementSchema(inject, element2 = null, allowDirect = true) {
    return InjectSchema(inject).extend({
      selector: allowDirect ? stringType().optional() : stringType(),
      multiple: booleanType().optional().default(false)
    }).transform(
      ({ selector, multiple }, ctx) => selector != null ? queryElement(ctx, element2, selector, multiple) : element2
    );
  }
  const ValidateInjectableDeepSchema = lazyType(
    () => unionType([
      Literal,
      symbolType(),
      DOMElementSchema,
      SourceMapSchema,
      LazyInjectSchema,
      TrustedFunctionSchema,
      arrayType(ValidateInjectableDeepSchema),
      recordType(ValidateInjectableDeepSchema)
    ])
  );
  const ParametersSchema = recordType(stringType(), anyType()).pipe(ValidateInjectableDeepSchema);
  const TargetSchema = (context, multiple = false) => unionType([
    stringType(),
    DOMElementSchema
  ]).transform(
    (target, ctx) => typeof target === "string" ? queryElement(ctx, context.wrapper, target, multiple) : target
  );
  const TargetsSchema = (context) => ArrayOrSingleSchema(
    ArrayOrSingleSchema(
      TargetSchema(context, true).nullable()
    )
  ).transform((targets) => [].concat(targets).flat().filter((t) => t != null)).refine(
    (targets) => targets.length > 0,
    { message: "No targets specified" }
  );
  const Inject = Enum({
    Element: "element",
    Hast: "hast",
    Container: "container",
    Anchor: "anchor",
    Stagger: "stagger",
    UtilsRandom: "utils.random",
    UtilsGet: "utils.get",
    UtilsSet: "utils.set",
    SvgMorphTo: "svg.morphTo",
    SvgCreateDrawable: "svg.createDrawable",
    SvgCreateMotionPath: "svg.createMotionPath",
    Duration: "duration",
    Easing: "easing",
    Variant: "variant",
    Position: "position",
    Direction: "direction",
    Module: "module",
    ModuleType: "module.type",
    Type: "type",
    Assign: "assign",
    Pick: "pick",
    Omit: "omit",
    Wait: "wait",
    StringTemplate: "string.template",
    Math: "math",
    StyleRemoveProperty: "style.removeProperty",
    Undefined: "undefined",
    Function: "function",
    Arguments: "arguments",
    Debug: "debug",
    VarGet: "var.get",
    VarSet: "var.set",
    Call: "call",
    Mouse: "mouse",
    Rect: "rect",
    Window: "window",
    IsIntersected: "isIntersected",
    Get: "get",
    If: "if",
    Switch: "switch",
    Load: "load",
    Raw: "raw",
    Vector: "vector",
    Rotate: "rotate",
    MathAbs: "math.abs",
    MathAcos: "math.acos",
    MathAcosh: "math.acosh",
    MathAsin: "math.asin",
    MathAsinh: "math.asinh",
    MathAtan: "math.atan",
    MathAtan2: "math.atan2",
    MathAtanh: "math.atanh",
    MathCbrt: "math.cbrt",
    MathCeil: "math.ceil",
    MathClz32: "math.clz32",
    MathCos: "math.cos",
    MathCosh: "math.cosh",
    MathExp: "math.exp",
    MathExpm1: "math.expm1",
    MathFloor: "math.floor",
    MathFround: "math.fround",
    MathHypot: "math.hypot",
    MathImul: "math.imul",
    MathLog: "math.log",
    MathLog1p: "math.log1p",
    MathLog10: "math.log10",
    MathLog2: "math.log2",
    MathMax: "math.max",
    MathMin: "math.min",
    MathPow: "math.pow",
    MathRandom: "math.random",
    MathRound: "math.round",
    MathSign: "math.sign",
    MathSin: "math.sin",
    MathSinh: "math.sinh",
    MathSqrt: "math.sqrt",
    MathTan: "math.tan",
    MathTanh: "math.tanh",
    MathTrunc: "math.trunc",
    MathE: "math.E",
    MathLN10: "math.LN10",
    MathLN2: "math.LN2",
    MathLOG10E: "math.LOG10E",
    MathLOG2E: "math.LOG2E",
    MathPI: "math.PI",
    MathSQRT1_2: "math.SQRT1_2",
    MathSQRT2: "math.SQRT2",
    AdditionOperator: "+",
    DivisionOperator: "/",
    EqualityOperator: "==",
    GreaterThanOperator: ">",
    GreaterThanOrEqualOperator: ">=",
    InOperator: "in",
    InequalityOperator: "!=",
    LessThanOperator: "<",
    LessThanOrEqualOperator: "<=",
    LogicalAndOperator: "&&",
    LogicalNotOperator: "!",
    LogicalOrOperator: "||",
    MultiplicationOperator: "*",
    NullishCoalescingOperator: "??",
    RemainderOperator: "%",
    StrictEqualityOperator: "===",
    StrictInequalityOperator: "!==",
    SubtractionOperator: "-",
    Includes: "includes",
    Accordion: "accordion",
    Snippet: "snippet",
    SnippetParams: "snippet.params"
  });
  const AnimationType = Enum({
    Enter: "enter",
    Exit: "exit"
  });
  const ModuleKeyAlias = Enum({
    Switch: "switch",
    Reveal: "reveal",
    Sidebars: "sidebars"
  });
  const ModuleKey = Enum({
    Servers: "servers",
    Channels: "channels",
    Settings: "settings",
    Popouts: "popouts",
    Tooltips: "tooltips",
    ContextMenu: "contextMenu",
    Messages: "messages",
    ChannelList: "channelList",
    Modals: "modals",
    ModalsBackdrop: "modalsBackdrop",
    Layers: "layers",
    MembersSidebar: "membersSidebar",
    ThreadSidebar: "threadSidebar",
    ThreadSidebarSwitch: "threadSidebarSwitch"
  });
  class Debug {
    constructor({ animation, animationType }) {
      this.animation = animation;
      this.animationType = animationType;
    }
    static animation(animation, type) {
      return new Debug({ animation, animationType: type });
    }
    get isEnabled() {
      if (this.animation)
        return [true, this.animationType].includes(this.animation.debug);
      return false;
    }
    __log(type, message, ...data2) {
      if (this.animation)
        return Logger.stylized(
          "Animation",
          type,
          `%c${this.animation.key} (${this.animationType}) %c[DEBUG]%c ` + message,
          "color: #B8AF5E;",
          "color: #6BA6FF;",
          "",
          ...data2
        );
      return Logger[type]("Debug", message, ...data2);
    }
    _log(message, ...data2) {
      return this.__log("log", message, ...data2);
    }
    _warn(message, ...data2) {
      return this.__log("warn", message, ...data2);
    }
    _error(message, ...data2) {
      return this.__log("error", message, ...data2);
    }
    _groupCollapsed(message, ...data2) {
      return this.__log("groupCollapsed", message, ...data2);
    }
    _groupEnd() {
      return Logger.groupEnd();
    }
    _system(event, message = null, meta2 = {}, type = "log") {
      return this[`_${type}`](
        `%c${event}%c` + (message ? `: ${message}` : ""),
        "font-weight: bold;",
        "",
        ...Object.entries(meta2).flatMap(
          ([key2, value]) => [`
↪ ${capitalize(key2)}:`, value]
        )
      );
    }
    _visualized(event, name2, path2, context, meta2 = {}, options = {}) {
      const { type, visPath = path2, ...visOptions } = options;
      const visualized = visualizeAddonPath(context.pack, visPath, visOptions);
      return this._system(
        event,
        `'${name2}' at "${toPath(path2)}"` + (visualized ? "\n" + visualized : ""),
        meta2,
        type
      );
    }
    _inject(event, name2, path2, context, meta2 = {}, options = {}) {
      return this._visualized(event, name2, path2, context, meta2, {
        visPath: path2.concat("inject"),
        ...options
      });
    }
    debug(name2, path2, context, data2) {
      return this._inject(
        "Debug",
        name2,
        path2,
        context,
        {
          context: snapshotContext(context),
          data: sanitizeInjectable(data2)
        }
      );
    }
    invalidSelector(selector, path2, context) {
      return this._visualized(
        "Invalid selector",
        selector,
        path2,
        context,
        { context: snapshotContext(context) },
        { type: "warn", pointAt: "key" }
      );
    }
    inject(name2, path2, context, received, output = void 0) {
      if (!this.isEnabled) return () => {
      };
      const contextSnapshot = snapshotContext(context);
      const report = (output2) => this._inject(
        "Inject parsed",
        name2,
        path2,
        context,
        {
          context: contextSnapshot,
          received: sanitizeInjectable(received),
          output: sanitizeInjectable(output2)
        }
      );
      return output ? report(output) : report;
    }
    lazyInjectCall(name2, path2, args, context) {
      if (!this.isEnabled) return;
      this._system(
        "Lazy inject call",
        `'${name2}' at "${toPath(path2)}"`,
        {},
        "groupCollapsed"
      );
      this._inject(
        "Lazy inject called",
        name2,
        path2,
        context,
        {
          context: snapshotContext(context),
          arguments: args
        }
      );
      return () => this._groupEnd();
    }
    initializeStart(received, context) {
      if (!this.isEnabled) return;
      this._system("Initialize", null, {}, "groupCollapsed");
      this._system(
        "Initialize started",
        null,
        {
          context: snapshotContext(context),
          received: sanitizeInjectable(received)
        }
      );
      return () => this._groupEnd();
    }
    initializeEnd(result, context) {
      if (!this.isEnabled) return;
      return this._system(
        "Initialize completed",
        null,
        {
          context: snapshotContext(context),
          result: sanitizeInjectable(result)
        }
      );
    }
    parseStart(stage, received, context) {
      if (!this.isEnabled) return;
      this._system("Parsing stage", stage, {}, "groupCollapsed");
      this._system(
        "Parsing started",
        stage,
        {
          context: snapshotContext(context),
          received: sanitizeInjectable(received)
        }
      );
      return () => this._groupEnd();
    }
    parseEnd(stage, result, context) {
      if (!this.isEnabled) return;
      return this._system(
        "Parsing completed",
        stage,
        {
          context: snapshotContext(context),
          result: sanitizeInjectable(result)
        }
      );
    }
    hook(name2, context) {
      if (!this.isEnabled) return;
      return this._system(
        "Hook triggered",
        name2,
        { context: snapshotContext(context) }
      );
    }
  }
  const forbiddenKeys = [
    ...reservedKeys$1,
    /**
     * Prevent manipulation with string coercion
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#string_coercion
     */
    "toString",
    "valueOf"
  ];
  const reservedKeys = [...forbiddenKeys, "inject"];
  function restrictKeys(keys2) {
    return (value) => !keys2.includes(value);
  }
  const restrictForbiddenKeys = restrictKeys(forbiddenKeys);
  const restrictReservedKeys = restrictKeys(reservedKeys);
  const Position = Enum({
    TopLeft: "top left",
    Top: "top",
    TopRight: "top right",
    Left: "left",
    Center: "center",
    Right: "right",
    BottomLeft: "bottom left",
    Bottom: "bottom",
    BottomRight: "bottom right"
  });
  const Direction = Enum({
    Upwards: "upwards",
    Downwards: "downwards",
    Leftwards: "leftwards",
    Rightwards: "rightwards",
    Forwards: "forwards",
    Backwards: "backwards"
  });
  function getRect(el, parent = null) {
    if (!parent) {
      const { x: x2, y: y2, left, top, right, bottom, width: width2, height: height2 } = el.getBoundingClientRect();
      return { x: x2, y: y2, left, top, right, bottom, width: width2, height: height2 };
    }
    const { offsetWidth: width, offsetHeight: height } = el;
    let x = 0, y = 0, current = el;
    while (current != null && current !== parent) {
      x += current.offsetLeft;
      y += current.offsetTop;
      current = current.offsetParent;
    }
    return {
      x,
      y,
      left: x,
      top: y,
      right: x + width,
      bottom: y + height,
      width,
      height
    };
  }
  function reversePosition(position2) {
    switch (position2) {
      case Position.Top:
        return Position.Bottom;
      case Position.Bottom:
        return Position.Top;
      case Position.Left:
        return Position.Right;
      case Position.Right:
        return Position.Left;
      case Position.Center:
        return Position.Center;
    }
  }
  function getPosition(position2, align = Position.Center) {
    if (position2 === Position.Center) return Position.Center;
    if (align === Position.Center) return position2;
    const pair = [position2, align];
    const equals = (a, b) => [a, b].every((p) => pair.includes(p));
    if (equals(Position.Top, Position.Right)) return Position.TopRight;
    if (equals(Position.Top, Position.Left)) return Position.TopLeft;
    if (equals(Position.Bottom, Position.Right)) return Position.BottomRight;
    if (equals(Position.Bottom, Position.Left)) return Position.BottomLeft;
  }
  function toDirection(position2) {
    switch (position2) {
      case Position.Top:
        return Direction.Upwards;
      case Position.Bottom:
        return Direction.Downwards;
      case Position.Left:
        return Direction.Leftwards;
      case Position.Right:
        return Direction.Rightwards;
      case Position.Center:
        return Direction.Backwards;
    }
  }
  function toPercent(value, rect) {
    if (typeof value === "string")
      switch (value) {
        case Position.TopLeft:
          return [0, 0];
        case Position.Top:
          return [0.5, 0];
        case Position.TopRight:
          return [1, 0];
        case Position.Left:
          return [0, 0.5];
        case Position.Center:
          return [0.5, 0.5];
        case Position.Right:
          return [1, 0.5];
        case Position.BottomLeft:
          return [0, 1];
        case Position.Bottom:
          return [0.5, 1];
        case Position.BottomRight:
          return [1, 1];
      }
    const [x, y] = value;
    return [x / rect.width, y / rect.height];
  }
  function toPx(value, rect) {
    const [x, y] = typeof value === "string" ? toPercent(value, rect) : value;
    return [x * rect.width, y * rect.height];
  }
  function toUnit(value, unit, rect = void 0) {
    switch (unit) {
      case "px":
        return toPx(value, rect);
      case "%":
        return toPercent(value, rect);
    }
  }
  function getCenter(rect, unit = "px", relative = { x: 0, y: 0 }) {
    const [x, y] = [
      rect.x + rect.width / 2 - relative.x,
      rect.y + rect.height / 2 - relative.y
    ];
    if (unit === "%") return toPercent([x, y], relative);
    return [x, y];
  }
  const ElementInjectSchema = ({ element: element2 }) => InjectSchema(Inject.Element).transform(() => element2);
  const ContainerInjectSchema = ({ container }) => InjectSchema(Inject.Container).transform(() => container);
  const AnchorInjectSchema = ({ anchor }) => InjectSchema(Inject.Anchor).transform(() => isElement(anchor) ? anchor : void 0);
  const HastInjectSchema = ({ wrapper }) => ElementSchema(Inject.Hast, wrapper, false);
  const ModuleInjectSchema = InjectWithMeta(
    SwitchSchema(Inject.Module, ModuleKey.values(), {
      currentValue: (ctx) => ctx.module.id,
      possibleValues: (ctx) => Array.from(ctx.animation.modules)
    }),
    { immediate: ["module"] }
  );
  const ModuleTypeInjectSchema = InjectWithMeta(
    SwitchSchema(Inject.ModuleType, ModuleType.values(), { currentValue: (ctx) => ctx.module.type }),
    { immediate: ["module"] }
  );
  const TypeInjectSchema = InjectWithMeta(
    SwitchSchema(Inject.Type, AnimationType.values(), { currentValue: (ctx) => ctx.type }),
    { immediate: ["type"] }
  );
  const StringTemplateInjectSchema = InjectSchema(Inject.StringTemplate).extend({
    template: stringType(),
    values: unionType([recordType(anyType()), anyType().array()])
  }).transform(zodTransformErrorBoundary(
    ({ template, values }) => {
      values = clearSourceMap(values);
      return template.replaceAll(
        /\${([^\${}\s]+)}/g,
        (_, key2) => String(values[Array.isArray(values) ? +key2 : key2]) ?? ""
      );
    }
  ));
  const StyleRemovePropertyInjectSchema = InjectWithMeta(
    (context) => InjectSchema(Inject.StyleRemoveProperty).extend({
      targets: TargetsSchema(context).optional().default([context.element]),
      property: ArrayOrSingleSchema(stringType())
    }).transform(({ targets, property }) => targets.forEach(
      (e) => [].concat(property).forEach((p) => e.style.removeProperty(p))
    )),
    { lazy: true }
  );
  const UndefinedInjectSchema = InjectWithMeta(
    InjectSchema(Inject.Undefined).transform(() => void 0),
    { immediate: true }
  );
  const FunctionInjectSchema = InjectWithMeta(
    (context, { args }) => InjectSchema(Inject.Function).extend({
      functions: ArrayOrSingleSchema(TrustedFunctionSchema).optional(),
      "return": anyType().optional()
    }).transform(zodTransformErrorBoundary(
      ({ functions, return: returnValue }) => {
        const functionReturnValues = [].concat(functions).map((f) => f?.(...args));
        return clearSourceMapDeep(
          returnValue === void 0 ? functionReturnValues.pop() : returnValue
        );
      }
    )),
    { lazy: true }
  );
  const ArgumentsInjectSchema = (context, { args }) => InjectSchema(Inject.Arguments).extend({
    index: numberType().optional()
  }).transform(({ index: index2 }) => index2 == null ? args : args[index2]);
  const DebugInjectSchema = InjectWithMeta(
    (context) => InjectSchema(Inject.Debug).extend({
      data: anyType().optional()
    }).transform(
      (value) => Debug.animation(context.animation, context.type).debug(Inject.Debug, getSourcePath(value, SELF_KEY), context, value.data)
    ),
    { lazy: true }
  );
  const VarSetInjectSchema = InjectWithMeta(
    ({ vars }) => InjectSchema(Inject.VarSet).extend({
      name: stringType().refine(
        restrictForbiddenKeys,
        (name2) => ({ message: `Forbidden variable name: '${name2}'` })
      ),
      value: anyType()
    }).transform(({ name: name2, value }) => {
      vars[name2] = value;
    }),
    { lazy: true }
  );
  const VarGetInjectSchema = ({ vars }) => InjectSchema(Inject.VarGet).extend({
    name: stringType().refine(
      restrictForbiddenKeys,
      (name2) => ({ message: `Forbidden variable name: '${name2}'` })
    )
  }).transform(({ name: name2 }) => vars[name2]);
  const CallInjectSchema = InjectSchema(Inject.Call).extend({
    function: TrustedFunctionSchema,
    arguments: ArrayOrSingleSchema(anyType()).optional()
  }).transform(zodTransformErrorBoundary(
    ({ function: fn, arguments: args }) => fn(
      ...[].concat(clearSourceMapDeep(args))
    )
  ));
  const RectInjectSchema = (context) => InjectSchema(Inject.Rect).extend({
    target: TargetSchema(context).optional(),
    value: enumType(["x", "y", "top", "left", "right", "bottom", "width", "height"]).optional()
  }).transform(({ target, value }) => {
    const rect = target ? getRect(target, context.viewport) : context.containerRect;
    return value ? rect[value] : rect;
  });
  const WindowInjectSchema = ({ viewport, window: window2 }) => InjectSchema(Inject.Window).extend({
    value: enumType(["width", "height"])
  }).transform(({ value }) => {
    switch (value) {
      case "width":
        return viewport?.offsetWidth ?? window2.innerWidth;
      case "height":
        return viewport?.offsetHeight ?? window2.innerHeight;
    }
  });
  const MouseInjectSchema = ({ containerRect, mouse }) => InjectSchema(Inject.Mouse).extend({
    value: enumType(["x", "y"]).optional(),
    absolute: booleanType().optional().default(false)
  }).transform(({ value, absolute }) => {
    const { x, y } = (() => {
      if (absolute || !containerRect) return { x: mouse.x, y: mouse.y };
      const { left, top } = containerRect;
      return {
        x: mouse.x - left,
        y: mouse.y - top
      };
    })();
    switch (value) {
      case "x":
        return x;
      case "y":
        return y;
      default:
        return `${x}px ${y}px`;
    }
  });
  const IsIntersectedInjectSchema = SwitchSchema(Inject.IsIntersected, [true, false], {
    currentValue: (ctx) => !!ctx.isIntersected
  });
  const GetInjectSchema = InjectSchema(Inject.Get).extend({
    target: unionType([
      recordType(anyType()),
      arrayType(anyType())
    ]),
    key: unionType([
      stringType(),
      numberType()
    ]).refine(
      restrictForbiddenKeys,
      (key2) => ({ message: `Forbidden key: '${key2}'` })
    ).optional(),
    path: stringType().startsWith("/", "JSON Pointer must begin with `/`").superRefine((path2, ctx) => {
      if (!path2.startsWith("/")) return;
      path2 = parsePath(path2);
      const index2 = path2.findIndex((i) => !restrictForbiddenKeys(i));
      if (index2 === -1) return;
      ctx.addIssue({
        code: ZodIssueCode.custom,
        message: `Forbidden key '${path2[index2]}' at index ${index2} in JSON Pointer`
      });
    }).optional()
  }).transform(({ target, key: key2, path: path2 }) => {
    if (key2 != null) return target[key2];
    if (path2 != null) return getPath$1(target, path2);
    return target;
  });
  const IfInjectSchema = InjectSchema(Inject.If).extend({
    value: anyType(),
    then: anyType(),
    else: anyType().optional()
  }).transform(({ value, then, else: elseValue }) => value ? then : elseValue);
  const SwitchInjectSchema = InjectSchema(Inject.Switch).extend({
    value: anyType(),
    case: unionType([
      recordType(anyType()),
      tupleType([anyType(), anyType()]).array()
    ]),
    default: anyType().optional()
  }).transform(({ value, case: cases, default: defaultValue }) => {
    cases = clearSourceMap(cases);
    return new Map(
      Array.isArray(cases) ? cases : Object.entries(cases)
    ).get(value) ?? defaultValue;
  });
  const LoadInjectSchema = ({ pack, animation, type }) => InjectSchema(Inject.Load).extend({
    animation: enumType(pack.animations.map((a) => a.key).filter((k) => k !== animation.key)),
    type: enumType(AnimationType.values()).optional().default(type)
  }).transform(({ animation: key2, type: type2 }) => {
    const target = pack.animations.find((a) => a.key === key2);
    return target?.[type2] ?? target?.animate;
  });
  const RawInjectBaseSchema = InjectSchema(Inject.Raw).extend({
    value: anyType()
  });
  const RawInjectSchema = RawInjectBaseSchema.transform(({ value }) => value);
  const ValueSchema = ArrayOrSingleSchema(unionType([numberType(), stringType()])).optional().default(0).transform((value) => [].concat(value));
  const VectorInjectSchema = InjectSchema(Inject.Vector).extend({
    values: SourceMappedObjectSchema.extend({
      x: ValueSchema,
      y: ValueSchema,
      z: ValueSchema
    }).strict(),
    unit: unionType([stringType(), nullType()]).optional().default("px")
  }).transform(({ values: { x, y, z }, unit }) => {
    const amount = Math.max(1, ...[x, y, z].map((v) => v.length));
    const keyframes2 = Array(amount).fill(null).map(
      (_, i) => [x, y, z].map((values) => {
        const value = values[i] ?? 0;
        return typeof value === "number" && value !== 0 ? value + (unit ?? "") : String(value);
      }).join(" ")
    );
    return amount === 1 ? keyframes2[0] : keyframes2;
  });
  const RotateInjectSchema = InjectSchema(Inject.Rotate).extend({
    axis: unionType([
      literalType("x"),
      literalType("y"),
      literalType("z")
    ]),
    angle: ValueSchema,
    unit: unionType([stringType(), nullType()]).optional().default("deg")
  }).transform(({ axis, angle, unit }) => {
    if (!angle.length) return axis + " 0";
    const keyframes2 = angle.map(
      (value) => axis + " " + (typeof value === "number" && value !== 0 ? value + (unit ?? "") : String(value))
    );
    return keyframes2.length === 1 ? keyframes2[0] : keyframes2;
  });
  const GeneralInjectSchemas = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    AnchorInjectSchema,
    ArgumentsInjectSchema,
    CallInjectSchema,
    ContainerInjectSchema,
    DebugInjectSchema,
    ElementInjectSchema,
    FunctionInjectSchema,
    GetInjectSchema,
    HastInjectSchema,
    IfInjectSchema,
    IsIntersectedInjectSchema,
    LoadInjectSchema,
    ModuleInjectSchema,
    ModuleTypeInjectSchema,
    MouseInjectSchema,
    RawInjectBaseSchema,
    RawInjectSchema,
    RectInjectSchema,
    RotateInjectSchema,
    StringTemplateInjectSchema,
    StyleRemovePropertyInjectSchema,
    SwitchInjectSchema,
    TypeInjectSchema,
    UndefinedInjectSchema,
    VarGetInjectSchema,
    VarSetInjectSchema,
    VectorInjectSchema,
    WindowInjectSchema
  }, Symbol.toStringTag, { value: "Module" }));
  const AssignInjectSchema = InjectSchema(Inject.Assign).extend({
    target: recordType(anyType()),
    source: ArrayOrSingleSchema(recordType(anyType()))
  }).transform(({ target, source }) => sourceMappedObjectAssign(target, ...[].concat(source)));
  const PickInjectSchema = InjectSchema(Inject.Pick).extend({
    target: recordType(anyType()),
    keys: ArrayOrSingleSchema(
      stringType().refine(
        restrictForbiddenKeys,
        (key2) => ({ message: `Forbidden key: '${key2}'` })
      )
    )
  }).transform(({ target, keys: keys2 }) => sourceMappedPick(target, [].concat(keys2)));
  const OmitInjectSchema = InjectSchema(Inject.Omit).extend({
    target: recordType(anyType()),
    keys: ArrayOrSingleSchema(
      stringType().refine(
        restrictForbiddenKeys,
        (key2) => ({ message: `Forbidden key: '${key2}'` })
      )
    )
  }).transform(({ target, keys: keys2 }) => sourceMappedOmit(target, [].concat(keys2)));
  const ObjectInjectSchemas = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    AssignInjectSchema,
    OmitInjectSchema,
    PickInjectSchema
  }, Symbol.toStringTag, { value: "Module" }));
  const ArrayInjectBaseSchema = (inject) => InjectSchema(inject).extend({
    target: arrayType(anyType())
  });
  const IncludesInjectSchema = ArrayInjectBaseSchema(Inject.Includes).extend({
    value: anyType()
  }).transform(({ target, value }) => target.includes(value));
  const ArrayInjectSchemas = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    IncludesInjectSchema
  }, Symbol.toStringTag, { value: "Module" }));
  const StaggerValueSchema = unionType([numberType(), stringType()]);
  const StaggerInjectSchema = (context) => InjectSchema(Inject.Stagger).extend({
    value: unionType([
      StaggerValueSchema,
      tupleType([StaggerValueSchema, StaggerValueSchema])
    ]),
    parameters: ParametersSchema.optional()
  }).transform(
    zodTransformErrorBoundary(({ value, parameters }, { path: path2 }) => {
      value = clearSourceMapDeep(value);
      parameters = clearSourceMapDeep(parameters);
      return zodErrorBoundary(
        stagger(value, parameters),
        context,
        { path: path2, name: "stagger" }
      );
    })
  );
  const UtilsRandomInjectSchema = InjectSchema(Inject.UtilsRandom).extend({
    min: numberType(),
    max: numberType(),
    decimalLength: numberType().optional()
  }).transform(
    zodTransformErrorBoundary(
      ({ min, max: max2, decimalLength }) => utils.random(min, max2, decimalLength)
    )
  );
  const UtilsGetInjectSchema = (context) => InjectSchema(Inject.UtilsGet).extend({
    target: TargetSchema(context).optional().default(context.element),
    property: stringType(),
    unit: unionType([stringType(), booleanType()]).optional()
  }).transform(
    zodTransformErrorBoundary(
      ({ target, property, unit }) => utils.get(target, property, unit)
    )
  );
  const UtilsSetInjectSchema = InjectWithMeta(
    (context) => InjectSchema(Inject.UtilsSet).extend({
      targets: TargetsSchema(context).optional().default([context.element]),
      properties: ParametersSchema
    }).transform(
      zodTransformErrorBoundary(
        ({ targets, properties: properties2 }, { path: path2 }) => {
          const instance = utils.set(
            targets,
            clearSourceMapDeep(properties2)
          );
          return zodErrorBoundary(
            instance.revert.bind(instance),
            context,
            { path: path2, name: "revert" }
          );
        }
      )
    ),
    { lazy: true }
  );
  const SvgMorphToInjectSchema = (context) => InjectSchema(Inject.SvgMorphTo).extend({
    target: TargetSchema(context),
    precision: numberType().min(0).max(1).optional()
  }).transform(
    zodTransformErrorBoundary(
      ({ target, precision }, { path: path2 }) => zodErrorBoundary(
        svg$2.morphTo(target, precision),
        context,
        { path: path2, name: "svg.morphTo" }
      )
    )
  );
  const SvgCreateDrawableInjectSchema = (context) => InjectSchema(Inject.SvgCreateDrawable).extend({
    targets: TargetsSchema(context)
  }).transform(
    zodTransformErrorBoundary(
      ({ targets }) => targets.flatMap((target) => svg$2.createDrawable(target))
    )
  );
  const SvgCreateMotionPathInjectSchema = (context) => InjectSchema(Inject.SvgCreateMotionPath).extend({
    target: TargetSchema(context)
  }).transform(
    zodTransformErrorBoundary(
      ({ target }, { path: path2 }) => {
        const { translateX, translateY, rotate } = svg$2.createMotionPath(target);
        const boundary = (fn) => zodErrorBoundary(fn, context, { path: path2, name: "svg.createMotionPath" });
        return {
          translateX: boundary(translateX),
          translateY: boundary(translateY),
          rotate: boundary(rotate)
        };
      }
    )
  );
  const AnimeInjectSchemas = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    StaggerInjectSchema,
    SvgCreateDrawableInjectSchema,
    SvgCreateMotionPathInjectSchema,
    SvgMorphToInjectSchema,
    UtilsGetInjectSchema,
    UtilsRandomInjectSchema,
    UtilsSetInjectSchema
  }, Symbol.toStringTag, { value: "Module" }));
  const AnimationSetting = Enum({
    Duration: "duration",
    Easing: "easing",
    Variant: "variant",
    Position: "position",
    PositionPreserve: "positionPreserve",
    Direction: "direction",
    DirectionAxis: "directionAxis",
    DirectionReverse: "directionReverse",
    DirectionTowards: "directionTowards",
    Overflow: "overflow"
  });
  const EasingType = Enum({
    Linear: "linear",
    Ease: "ease",
    Back: "back",
    Elastic: "elastic",
    Steps: "steps"
  });
  const EasingBezier = Enum({
    In: "in",
    Out: "out",
    InOut: "inOut"
  });
  const EasingStyle = Enum({
    Sine: "sine",
    Quad: "quad",
    Cubic: "cubic",
    Quart: "quart",
    Quint: "quint",
    Circ: "circ",
    Expo: "expo",
    Bounce: "bounce"
  });
  const easingTypes = [
    { value: EasingType.Linear, label: "Linear" },
    { value: EasingType.Ease, label: "Ease" },
    { value: EasingType.Back, label: "Back" },
    { value: EasingType.Elastic, label: "Elastic" },
    { value: EasingType.Steps, label: "Steps" }
  ];
  const easingBeziers = [
    { value: EasingBezier.In, label: "In" },
    { value: EasingBezier.Out, label: "Out" },
    { value: EasingBezier.InOut, label: "In Out" }
  ];
  const easingStyles = [
    { value: EasingStyle.Sine, label: "Sine" },
    { value: EasingStyle.Quad, label: "Quad" },
    { value: EasingStyle.Cubic, label: "Cubic" },
    { value: EasingStyle.Quart, label: "Quart" },
    { value: EasingStyle.Quint, label: "Quint" },
    { value: EasingStyle.Circ, label: "Circ" },
    { value: EasingStyle.Expo, label: "Expo" },
    { value: EasingStyle.Bounce, label: "Bounce" }
  ];
  const easingValues = {
    [EasingType.Back]: {
      overshoot: {
        min: 1,
        max: 10,
        default: 1.7,
        fractionDigits: 2
      }
    },
    [EasingType.Elastic]: {
      amplitude: {
        min: 1,
        max: 10,
        default: 1,
        fractionDigits: 2
      },
      period: {
        min: 0.1,
        max: 2,
        default: 0.5,
        fractionDigits: 2
      }
    },
    [EasingType.Steps]: {
      amount: {
        min: 1,
        max: 100,
        default: 10
      }
    }
  };
  const EasingBaseSchema = (type) => SourceMappedObjectSchema.extend({
    type: literalType(type)
  }).strict();
  const EasingValueSchema = (options) => {
    let schema = numberType();
    if (!options.fractionDigits) schema = schema.int();
    if ("min" in options) schema = schema.min(options.min);
    if ("max" in options) schema = schema.max(options.max);
    schema = schema.optional();
    if ("default" in options) schema = schema.default(options.default);
    return schema;
  };
  const EasingLinearSchema = EasingBaseSchema(EasingType.Linear);
  const EasingEaseSchema = EasingBaseSchema(EasingType.Ease).extend({
    bezier: enumType(EasingBezier.values()).optional().default(EasingBezier.InOut),
    style: enumType(EasingStyle.values()).optional().default(EasingStyle.Sine)
  });
  const EasingBackSchema = EasingBaseSchema(EasingType.Back).extend({
    bezier: enumType(EasingBezier.values()).optional().default(EasingBezier.Out),
    overshoot: EasingValueSchema(easingValues[EasingType.Back]["overshoot"])
  });
  const EasingElasticSchema = EasingBaseSchema(EasingType.Elastic).extend({
    bezier: enumType(EasingBezier.values()).optional().default(EasingBezier.Out),
    amplitude: EasingValueSchema(easingValues[EasingType.Elastic]["amplitude"]),
    period: EasingValueSchema(easingValues[EasingType.Elastic]["period"])
  });
  const EasingStepsSchema = EasingBaseSchema(EasingType.Steps).extend({
    amount: EasingValueSchema(easingValues[EasingType.Steps]["amount"])
  });
  const EasingSchema = discriminatedUnionType("type", [
    EasingLinearSchema,
    EasingEaseSchema,
    EasingBackSchema,
    EasingElasticSchema,
    EasingStepsSchema
  ]);
  function getEasingFn(easing) {
    switch (easing.type) {
      case EasingType.Linear:
        return eases.linear();
      case EasingType.Ease:
        return eases[`${easing.bezier}${capitalize(easing.style)}`];
      case EasingType.Back:
        return eases[`${easing.bezier}Back`](easing.overshoot);
      case EasingType.Elastic:
        return eases[`${easing.bezier}Elastic`](easing.amplitude, easing.period);
      case EasingType.Steps:
        return eases.steps(easing.amount);
    }
  }
  const DurationInjectSchema = InjectWithMeta(
    ({ duration, settings }) => InjectSchema(Inject.Duration).transform(hasInSettings(Inject.Duration, AnimationSetting.Duration in settings)).transform(() => duration),
    { immediate: [AnimationSetting.Duration, "settings"] }
  );
  const EasingInjectSchema = (context) => InjectSchema(Inject.Easing).extend({
    easing: AnimationSetting.Easing in context.settings ? EasingSchema.optional().default(context.easing) : EasingSchema,
    raw: booleanType().optional().default(false)
  }).transform(
    ({ easing, raw }, { path: path2 }) => raw ? easing : zodErrorBoundary(
      getEasingFn(easing),
      context,
      { path: path2, name: "easing" }
    )
  );
  const PositionInjectSchema = (context) => {
    if (context.settings?.[AnimationSetting.Position] !== true)
      return SwitchSchema(Inject.Position, Position.values(), { defaultValue: Position.Center, setting: AnimationSetting.Position })({
        ...context,
        position: context.position?.isAuto ? context.position.value : context.position
      });
    return InjectSchema(Inject.Position).extend({
      value: enumType(["x", "y"]).optional(),
      unit: enumType(["px", "%"]).optional().default("px"),
      clip: booleanType().optional().default(true)
    }).transform(({ value, unit, clip }) => {
      const { position: position2, containerRect, anchorRect } = context;
      let [x, y] = (() => {
        if (!position2?.isAuto)
          return toUnit(position2, unit, containerRect);
        if (anchorRect)
          return getCenter(
            anchorRect,
            unit,
            containerRect
          );
        if (position2.value)
          return toUnit(position2.value, unit, containerRect);
        const mouse = [
          position2.mouse.x - containerRect.x,
          position2.mouse.y - containerRect.y
        ];
        if (unit === "%") return toPercent(mouse, containerRect);
        return mouse;
      })();
      if (clip)
        switch (unit) {
          case "%": {
            [x, y] = [x, y].map((v) => Math.min(1, Math.max(0, v)));
            break;
          }
          case "px": {
            [x, y] = [
              Math.min(containerRect.width, Math.max(0, x)),
              Math.min(containerRect.height, Math.max(0, y))
            ];
            break;
          }
        }
      switch (value) {
        case "x":
          return x;
        case "y":
          return y;
        default:
          switch (unit) {
            case "%":
              return `${x * 100}% ${y * 100}%`;
            default:
              return `${x}px ${y}px`;
          }
      }
    });
  };
  const DirectionInjectSchema = InjectWithMeta(
    SwitchSchema(Inject.Direction, Direction.values(), { defaultValue: Direction.Rightwards, setting: AnimationSetting.Direction }),
    { immediate: [AnimationSetting.Direction, "settings"] }
  );
  const getVariantKeys = (context) => context.settings?.[AnimationSetting.Variant]?.map((v) => v.key) ?? [];
  const VariantInjectSchema = InjectWithMeta(
    SwitchSchema(Inject.Variant, getVariantKeys, { setting: AnimationSetting.Variant, possibleValues: getVariantKeys }),
    { immediate: [AnimationSetting.Variant, "settings"] }
  );
  const SettingsInjectSchemas = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    DirectionInjectSchema,
    DurationInjectSchema,
    EasingInjectSchema,
    PositionInjectSchema,
    VariantInjectSchema
  }, Symbol.toStringTag, { value: "Module" }));
  function isNumber(code) {
    return code > 47 && code < 58;
  }
  function isWhiteSpace(code) {
    return code === 32 || code === 9 || code === 160;
  }
  class Scanner {
    constructor(str, start, end) {
      if (end == null && typeof str === "string") {
        end = str.length;
      }
      this.string = str;
      this.pos = this.start = start || 0;
      this.end = end || 0;
    }
    /**
     * Returns true only if the stream is at the end of the file.
     */
    eof() {
      return this.pos >= this.end;
    }
    /**
     * Creates a new stream instance which is limited to given `start` and `end`
     * range. E.g. its `eof()` method will look at `end` property, not actual
     * stream end
     */
    limit(start, end) {
      return new Scanner(this.string, start, end);
    }
    /**
     * Returns the next character code in the stream without advancing it.
     * Will return NaN at the end of the file.
     */
    peek() {
      return this.string.charCodeAt(this.pos);
    }
    /**
     * Returns the next character in the stream and advances it.
     * Also returns <code>undefined</code> when no more characters are available.
     */
    next() {
      if (this.pos < this.string.length) {
        return this.string.charCodeAt(this.pos++);
      }
    }
    /**
     * `match` can be a character code or a function that takes a character code
     * and returns a boolean. If the next character in the stream 'matches'
     * the given argument, it is consumed and returned.
     * Otherwise, `false` is returned.
     */
    eat(match) {
      const ch = this.peek();
      const ok = typeof match === "function" ? match(ch) : ch === match;
      if (ok) {
        this.next();
      }
      return ok;
    }
    /**
     * Repeatedly calls <code>eat</code> with the given argument, until it
     * fails. Returns <code>true</code> if any characters were eaten.
     */
    eatWhile(match) {
      const start = this.pos;
      while (!this.eof() && this.eat(match)) {
      }
      return this.pos !== start;
    }
    /**
     * Backs up the stream n characters. Backing it up further than the
     * start of the current token will cause things to break, so be careful.
     */
    backUp(n) {
      this.pos -= n || 1;
    }
    /**
     * Get the string between the start of the current token and the
     * current stream position.
     */
    current() {
      return this.substring(this.start, this.pos);
    }
    /**
     * Returns substring for given range
     */
    substring(start, end) {
      return this.string.slice(start, end);
    }
    /**
     * Creates error object with current stream state
     */
    error(message, pos = this.pos) {
      return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);
    }
  }
  class ScannerError extends Error {
    constructor(message, pos, str) {
      super(message);
      this.pos = pos;
      this.string = str;
    }
  }
  const nullary = token("null", 0);
  function parse$1(expr) {
    const scanner = typeof expr === "string" ? new Scanner(expr) : expr;
    let ch;
    let priority = 0;
    let expected = 1 | 4 | 16;
    const tokens = [];
    while (!scanner.eof()) {
      scanner.eatWhile(isWhiteSpace);
      scanner.start = scanner.pos;
      if (consumeNumber(scanner)) {
        if ((expected & 1) === 0) {
          error("Unexpected number", scanner);
        }
        tokens.push(number(scanner.current()));
        expected = 2 | 8;
      } else if (isOperator(scanner.peek())) {
        ch = scanner.next();
        if (isSign(ch) && expected & 16) {
          if (isNegativeSign(ch)) {
            tokens.push(op1(ch, priority));
          }
          expected = 1 | 4 | 16;
        } else {
          if ((expected & 2) === 0) {
            error("Unexpected operator", scanner);
          }
          tokens.push(op2(ch, priority));
          expected = 1 | 4 | 16;
        }
      } else if (scanner.eat(
        40
        /* LeftParenthesis */
      )) {
        if ((expected & 4) === 0) {
          error('Unexpected "("', scanner);
        }
        priority += 10;
        expected = 1 | 4 | 16 | 32;
      } else if (scanner.eat(
        41
        /* RightParenthesis */
      )) {
        priority -= 10;
        if (expected & 32) {
          tokens.push(nullary);
        } else if ((expected & 8) === 0) {
          error('Unexpected ")"', scanner);
        }
        expected = 2 | 8 | 4;
      } else {
        error("Unknown character", scanner);
      }
    }
    if (priority < 0 || priority >= 10) {
      error('Unmatched "()"', scanner);
    }
    const result = orderTokens(tokens);
    if (result === null) {
      error("Parity", scanner);
    }
    return result;
  }
  function consumeNumber(scanner) {
    const start = scanner.pos;
    if (scanner.eat(
      46
      /* Dot */
    ) && scanner.eatWhile(isNumber)) {
      return true;
    }
    if (scanner.eatWhile(isNumber) && (!scanner.eat(
      46
      /* Dot */
    ) || scanner.eatWhile(isNumber))) {
      return true;
    }
    scanner.pos = start;
    return false;
  }
  function orderTokens(tokens) {
    const operators = [];
    const operands = [];
    let nOperators = 0;
    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];
      if (t.type === "num") {
        operands.push(t);
      } else {
        nOperators += t.type === "op1" ? 1 : 2;
        while (operators.length) {
          if (t.priority <= operators[operators.length - 1].priority) {
            operands.push(operators.pop());
          } else {
            break;
          }
        }
        operators.push(t);
      }
    }
    return nOperators + 1 === operands.length + operators.length ? operands.concat(operators.reverse()) : null;
  }
  function number(value, priority) {
    return token("num", parseFloat(value), priority);
  }
  function op1(value, priority = 0) {
    if (value === 45) {
      priority += 2;
    }
    return token("op1", value, priority);
  }
  function op2(value, priority = 0) {
    if (value === 42) {
      priority += 1;
    } else if (value === 47 || value === 92) {
      priority += 2;
    }
    return token("op2", value, priority);
  }
  function error(name2, scanner) {
    if (scanner) {
      name2 += ` at column ${scanner.pos} of expression`;
    }
    throw new Error(name2);
  }
  function isSign(ch) {
    return isPositiveSign(ch) || isNegativeSign(ch);
  }
  function isPositiveSign(ch) {
    return ch === 43;
  }
  function isNegativeSign(ch) {
    return ch === 45;
  }
  function isOperator(ch) {
    return ch === 43 || ch === 45 || ch === 42 || ch === 47 || ch === 92;
  }
  function token(type, value, priority = 0) {
    return { type, value, priority };
  }
  const ops1 = {
    [
      45
      /* Minus */
    ]: (num) => -num
  };
  const ops2 = {
    [
      43
      /* Plus */
    ]: (a, b) => a + b,
    [
      45
      /* Minus */
    ]: (a, b) => a - b,
    [
      42
      /* Multiply */
    ]: (a, b) => a * b,
    [
      47
      /* Divide */
    ]: (a, b) => a / b,
    [
      92
      /* IntDivide */
    ]: (a, b) => Math.floor(a / b)
  };
  function evaluate(expr) {
    if (!Array.isArray(expr)) {
      expr = parse$1(expr);
    }
    if (!expr || !expr.length) {
      return null;
    }
    const nStack = [];
    let n1;
    let n2;
    let f;
    for (let i = 0, il = expr.length; i < il; i++) {
      const token2 = expr[i];
      if (token2.type === "num") {
        nStack.push(token2.value);
      } else if (token2.type === "op2") {
        n2 = nStack.pop();
        n1 = nStack.pop();
        f = ops2[token2.value];
        nStack.push(f(n1, n2));
      } else if (token2.type === "op1") {
        n1 = nStack.pop();
        f = ops1[token2.value];
        nStack.push(f(n1));
      } else {
        throw new Error("Invalid expression");
      }
    }
    if (nStack.length > 1) {
      throw new Error("Invalid Expression (parity)");
    }
    return nStack[0];
  }
  const MathInjectSchema = InjectSchema(Inject.Math).extend({
    expression: stringType()
  }).transform(({ expression }, ctx) => {
    try {
      return evaluate(expression);
    } catch (e) {
      ctx.addIssue({
        code: ZodIssueCode.custom,
        message: e.message + ` "${expression}"`,
        path: ["expression"]
      });
      return NEVER;
    }
  });
  const MathConstantInjectSchema = (inject, value) => InjectWithMeta(
    InjectSchema(inject).transform(() => value),
    { immediate: true }
  );
  const MathSingleInjectSchema = (inject, fn) => InjectSchema(inject).extend({
    value: numberType()
  }).transform(zodTransformErrorBoundary(
    ({ value }) => fn(value)
  ));
  const MathMultipleInjectSchema = (inject, fn) => InjectSchema(inject).extend({
    values: ArrayOrSingleSchema(numberType())
  }).transform(zodTransformErrorBoundary(
    ({ values }) => fn(...[].concat(values))
  ));
  const MathAbsInjectSchema = MathSingleInjectSchema(Inject.MathAbs, Math.abs);
  const MathAcosInjectSchema = MathSingleInjectSchema(Inject.MathAcos, Math.acos);
  const MathAcoshInjectSchema = MathSingleInjectSchema(Inject.MathAcosh, Math.acosh);
  const MathAsinInjectSchema = MathSingleInjectSchema(Inject.MathAsin, Math.asin);
  const MathAsinhInjectSchema = MathSingleInjectSchema(Inject.MathAsinh, Math.asinh);
  const MathAtanInjectSchema = MathSingleInjectSchema(Inject.MathAtan, Math.atan);
  const MathAtan2InjectSchema = InjectSchema(Inject.MathAtan2).extend({
    y: numberType(),
    x: numberType()
  }).transform(zodTransformErrorBoundary(({ y, x }) => Math.atan2(y, x)));
  const MathAtanhInjectSchema = MathSingleInjectSchema(Inject.MathAtanh, Math.atanh);
  const MathCbrtInjectSchema = MathSingleInjectSchema(Inject.MathCbrt, Math.cbrt);
  const MathCeilInjectSchema = MathSingleInjectSchema(Inject.MathCeil, Math.ceil);
  const MathClz32InjectSchema = MathSingleInjectSchema(Inject.MathClz32, Math.clz32);
  const MathCosInjectSchema = MathSingleInjectSchema(Inject.MathCos, Math.cos);
  const MathCoshInjectSchema = MathSingleInjectSchema(Inject.MathCosh, Math.cosh);
  const MathExpInjectSchema = MathSingleInjectSchema(Inject.MathExp, Math.exp);
  const MathExpm1InjectSchema = MathSingleInjectSchema(Inject.MathExpm1, Math.expm1);
  const MathFloorInjectSchema = MathSingleInjectSchema(Inject.MathFloor, Math.floor);
  const MathFroundInjectSchema = MathSingleInjectSchema(Inject.MathFround, Math.fround);
  const MathHypotInjectSchema = MathMultipleInjectSchema(Inject.MathHypot, Math.hypot);
  const MathImulInjectSchema = InjectSchema(Inject.MathImul).extend({
    a: numberType(),
    b: numberType()
  }).transform(zodTransformErrorBoundary(({ a, b }) => Math.imul(a, b)));
  const MathLogInjectSchema = MathSingleInjectSchema(Inject.MathLog, Math.log);
  const MathLog1pInjectSchema = MathSingleInjectSchema(Inject.MathLog1p, Math.log1p);
  const MathLog10InjectSchema = MathSingleInjectSchema(Inject.MathLog10, Math.log10);
  const MathLog2InjectSchema = MathSingleInjectSchema(Inject.MathLog2, Math.log2);
  const MathMaxInjectSchema = MathMultipleInjectSchema(Inject.MathMax, Math.max);
  const MathMinInjectSchema = MathMultipleInjectSchema(Inject.MathMin, Math.min);
  const MathPowInjectSchema = InjectSchema(Inject.MathPow).extend({
    base: numberType(),
    exponent: numberType()
  }).transform(zodTransformErrorBoundary(({ base, exponent }) => Math.pow(base, exponent)));
  const MathRandomInjectSchema = InjectSchema(Inject.MathRandom).transform(() => Math.random());
  const MathRoundInjectSchema = MathSingleInjectSchema(Inject.MathRound, Math.round);
  const MathSignInjectSchema = MathSingleInjectSchema(Inject.MathSign, Math.sign);
  const MathSinInjectSchema = MathSingleInjectSchema(Inject.MathSin, Math.sin);
  const MathSinhInjectSchema = MathSingleInjectSchema(Inject.MathSinh, Math.sinh);
  const MathSqrtInjectSchema = MathSingleInjectSchema(Inject.MathSqrt, Math.sqrt);
  const MathTanInjectSchema = MathSingleInjectSchema(Inject.MathTan, Math.tan);
  const MathTanhInjectSchema = MathSingleInjectSchema(Inject.MathTanh, Math.tanh);
  const MathTruncInjectSchema = MathSingleInjectSchema(Inject.MathTrunc, Math.trunc);
  const MathEInjectSchema = MathConstantInjectSchema(Inject.MathE, Math.E);
  const MathLN10InjectSchema = MathConstantInjectSchema(Inject.MathLN10, Math.LN10);
  const MathLN2InjectSchema = MathConstantInjectSchema(Inject.MathLN2, Math.LN2);
  const MathLOG10EInjectSchema = MathConstantInjectSchema(Inject.MathLOG10E, Math.LOG10E);
  const MathLOG2EInjectSchema = MathConstantInjectSchema(Inject.MathLOG2E, Math.LOG2E);
  const MathPIInjectSchema = MathConstantInjectSchema(Inject.MathPI, Math.PI);
  const MathSQRT1_2InjectSchema = MathConstantInjectSchema(Inject.MathSQRT1_2, Math.SQRT1_2);
  const MathSQRT2InjectSchema = MathConstantInjectSchema(Inject.MathSQRT2, Math.SQRT2);
  const MathInjectSchemas = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    MathAbsInjectSchema,
    MathAcosInjectSchema,
    MathAcoshInjectSchema,
    MathAsinInjectSchema,
    MathAsinhInjectSchema,
    MathAtan2InjectSchema,
    MathAtanInjectSchema,
    MathAtanhInjectSchema,
    MathCbrtInjectSchema,
    MathCeilInjectSchema,
    MathClz32InjectSchema,
    MathCosInjectSchema,
    MathCoshInjectSchema,
    MathEInjectSchema,
    MathExpInjectSchema,
    MathExpm1InjectSchema,
    MathFloorInjectSchema,
    MathFroundInjectSchema,
    MathHypotInjectSchema,
    MathImulInjectSchema,
    MathInjectSchema,
    MathLN10InjectSchema,
    MathLN2InjectSchema,
    MathLOG10EInjectSchema,
    MathLOG2EInjectSchema,
    MathLog10InjectSchema,
    MathLog1pInjectSchema,
    MathLog2InjectSchema,
    MathLogInjectSchema,
    MathMaxInjectSchema,
    MathMinInjectSchema,
    MathPIInjectSchema,
    MathPowInjectSchema,
    MathRandomInjectSchema,
    MathRoundInjectSchema,
    MathSQRT1_2InjectSchema,
    MathSQRT2InjectSchema,
    MathSignInjectSchema,
    MathSinInjectSchema,
    MathSinhInjectSchema,
    MathSqrtInjectSchema,
    MathTanInjectSchema,
    MathTanhInjectSchema,
    MathTruncInjectSchema
  }, Symbol.toStringTag, { value: "Module" }));
  const OperatorInjectSchema = (inject, fn) => InjectSchema(inject).extend({
    a: anyType(),
    b: anyType()
  }).transform(
    zodTransformErrorBoundary(({ a, b }) => fn(
      clearSourceMap(a),
      clearSourceMap(b)
    ))
  );
  const AdditionOperatorInjectSchema = OperatorInjectSchema(Inject.AdditionOperator, (a, b) => a + b);
  const DivisionOperatorInjectSchema = OperatorInjectSchema(Inject.DivisionOperator, (a, b) => a / b);
  const EqualityOperatorInjectSchema = OperatorInjectSchema(Inject.EqualityOperator, (a, b) => a == b);
  const GreaterThanOperatorInjectSchema = OperatorInjectSchema(Inject.GreaterThanOperator, (a, b) => a > b);
  const GreaterThanOrEqualOperatorInjectSchema = OperatorInjectSchema(Inject.GreaterThanOrEqualOperator, (a, b) => a >= b);
  const InOperatorInjectSchema = OperatorInjectSchema(Inject.InOperator, (a, b) => a in b);
  const InequalityOperatorInjectSchema = OperatorInjectSchema(Inject.InequalityOperator, (a, b) => a != b);
  const LessThanOperatorInjectSchema = OperatorInjectSchema(Inject.LessThanOperator, (a, b) => a < b);
  const LessThanOrEqualOperatorInjectSchema = OperatorInjectSchema(Inject.LessThanOrEqualOperator, (a, b) => a <= b);
  const LogicalAndOperatorInjectSchema = OperatorInjectSchema(Inject.LogicalAndOperator, (a, b) => a && b);
  const LogicalNotOperatorInjectSchema = InjectSchema(Inject.LogicalNotOperator).extend({ value: anyType() }).transform(({ value }) => !value);
  const LogicalOrOperatorInjectSchema = OperatorInjectSchema(Inject.LogicalOrOperator, (a, b) => a || b);
  const MultiplicationOperatorInjectSchema = OperatorInjectSchema(Inject.MultiplicationOperator, (a, b) => a * b);
  const NullishCoalescingOperatorInjectSchema = OperatorInjectSchema(Inject.NullishCoalescingOperator, (a, b) => a ?? b);
  const RemainderOperatorInjectSchema = OperatorInjectSchema(Inject.RemainderOperator, (a, b) => a % b);
  const StrictEqualityOperatorInjectSchema = OperatorInjectSchema(Inject.StrictEqualityOperator, (a, b) => a === b);
  const StrictInequalityOperatorInjectSchema = OperatorInjectSchema(Inject.StrictInequalityOperator, (a, b) => a !== b);
  const SubtractionOperatorInjectSchema = OperatorInjectSchema(Inject.SubtractionOperator, (a, b) => a - b);
  const OperatorsInjectSchemas = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    AdditionOperatorInjectSchema,
    DivisionOperatorInjectSchema,
    EqualityOperatorInjectSchema,
    GreaterThanOperatorInjectSchema,
    GreaterThanOrEqualOperatorInjectSchema,
    InOperatorInjectSchema,
    InequalityOperatorInjectSchema,
    LessThanOperatorInjectSchema,
    LessThanOrEqualOperatorInjectSchema,
    LogicalAndOperatorInjectSchema,
    LogicalNotOperatorInjectSchema,
    LogicalOrOperatorInjectSchema,
    MultiplicationOperatorInjectSchema,
    NullishCoalescingOperatorInjectSchema,
    RemainderOperatorInjectSchema,
    StrictEqualityOperatorInjectSchema,
    StrictInequalityOperatorInjectSchema,
    SubtractionOperatorInjectSchema
  }, Symbol.toStringTag, { value: "Module" }));
  const MIN_ANIMATION_DURATION = 100;
  const MAX_ANIMATION_DURATION = 5e3;
  const Axis = Enum({
    X: "x",
    Y: "y",
    Z: "z"
  });
  function getDirectionsByAxis(axis) {
    switch (axis) {
      case Axis.X:
        return [Direction.Rightwards, Direction.Leftwards];
      case Axis.Y:
        return [Direction.Downwards, Direction.Upwards];
      case Axis.Z:
        return [Direction.Backwards, Direction.Forwards];
    }
  }
  function getSupportedAxes(directions2) {
    return Axis.values().filter((axis) => getDirectionsByAxis(axis).every((d) => directions2.includes(d)));
  }
  function getDirection(axis, isMore) {
    return getDirectionsByAxis(axis)[+isMore];
  }
  function reverseDirection(direction) {
    switch (direction) {
      case Direction.Upwards:
        return Direction.Downwards;
      case Direction.Downwards:
        return Direction.Upwards;
      case Direction.Leftwards:
        return Direction.Rightwards;
      case Direction.Rightwards:
        return Direction.Leftwards;
      case Direction.Forwards:
        return Direction.Backwards;
      case Direction.Backwards:
        return Direction.Forwards;
    }
  }
  function getAnchorDirection(position2, isTowards) {
    const direction = toDirection(position2);
    return isTowards ? reverseDirection(direction) : direction;
  }
  const AccordionType = Enum({
    MarginTop: "marginTop",
    MarginBottom: "marginBottom",
    MarginLeft: "marginLeft",
    MarginRight: "marginRight"
  });
  function reverseType(type) {
    switch (type) {
      case AccordionType.MarginTop:
        return AccordionType.MarginBottom;
      case AccordionType.MarginBottom:
        return AccordionType.MarginTop;
      case AccordionType.MarginLeft:
        return AccordionType.MarginRight;
      case AccordionType.MarginRight:
        return AccordionType.MarginLeft;
    }
  }
  function getSizeProperty(type) {
    switch (type) {
      case AccordionType.MarginTop:
      case AccordionType.MarginBottom:
        return "offsetHeight";
      case AccordionType.MarginLeft:
      case AccordionType.MarginRight:
        return "offsetWidth";
    }
  }
  function getMarginProperty(type, opposite = false) {
    switch (opposite ? reverseType(type) : type) {
      case AccordionType.MarginTop:
        return "marginTop";
      case AccordionType.MarginBottom:
        return "marginBottom";
      case AccordionType.MarginLeft:
        return "marginLeft";
      case AccordionType.MarginRight:
        return "marginRight";
    }
  }
  function buildAccordionGenerator(type, options = {}) {
    const { hideElement = false } = options;
    return (animationType, { easing, duration }) => ({ container, element: element2, isIntersected }) => Object.assign(
      {
        execute: () => {
          const value = -(utils.get(element2, getSizeProperty(type), false) + utils.get(container, getMarginProperty(type, true), false));
          return animate(container, {
            autoplay: false,
            duration,
            ease: getEasingFn(easing),
            [getMarginProperty(type)]: {
              [AnimationType.Enter]: isIntersected ? 0 : { from: value },
              [AnimationType.Exit]: value
            }[animationType]
          });
        }
      },
      hideElement ? {
        onBeforeBegin: () => element2.style.visibility = "hidden",
        onCompleted: animationType === AnimationType.Exit ? void 0 : () => element2.style.removeProperty("visibility"),
        onDestroyed: () => element2.style.removeProperty("visibility")
      } : null
    );
  }
  const DirectionAutoType = Enum({
    Alternate: "alternate",
    Anchor: "anchor"
  });
  const PositionAutoType = Enum({
    Precise: "precise"
  });
  const moduleAliases = {
    [ModuleKeyAlias.Switch]: [
      ModuleKey.Servers,
      ModuleKey.Channels,
      ModuleKey.Settings,
      ModuleKey.Layers,
      ModuleKey.ThreadSidebarSwitch
    ],
    [ModuleKeyAlias.Reveal]: [
      ModuleKey.Popouts,
      ModuleKey.Tooltips,
      ModuleKey.ContextMenu,
      ModuleKey.Messages,
      ModuleKey.ChannelList,
      ModuleKey.Modals
    ],
    [ModuleKeyAlias.Sidebars]: [
      ModuleKey.MembersSidebar,
      ModuleKey.ThreadSidebar
    ]
  };
  const modules$1 = [
    {
      id: ModuleKey.Servers,
      name: "Servers",
      meta: {
        type: ModuleType.Switch,
        settings: {
          supportsAuto: {
            [AnimationSetting.Position]: PositionAutoType.Precise,
            [AnimationSetting.Direction]: DirectionAutoType.Alternate
          },
          defaults: {
            [AnimationSetting.DirectionAxis]: Axis.Y,
            [AnimationSetting.Overflow]: false
          }
        }
      }
    },
    {
      id: ModuleKey.Channels,
      name: "Channels",
      meta: {
        type: ModuleType.Switch,
        settings: {
          supportsAuto: {
            [AnimationSetting.Position]: PositionAutoType.Precise,
            [AnimationSetting.Direction]: DirectionAutoType.Alternate
          },
          defaults: {
            [AnimationSetting.DirectionAxis]: Axis.Y,
            [AnimationSetting.Overflow]: false
          }
        }
      }
    },
    {
      id: ModuleKey.Messages,
      name: "Messages",
      meta: {
        accordion: {
          create: buildAccordionGenerator(AccordionType.MarginBottom, { hideElement: true }),
          defaults: {
            [AnimationSetting.Duration]: 200,
            [AnimationSetting.Easing]: {
              type: EasingType.Ease,
              bezier: EasingBezier.InOut,
              style: EasingStyle.Quad
            }
          }
        }
      }
    },
    {
      id: ModuleKey.Tooltips,
      name: "Tooltips",
      meta: {
        interceptEvents: false,
        waitUntilSafe: true,
        settings: {
          supportsAuto: {
            [AnimationSetting.Position]: true,
            [AnimationSetting.Direction]: DirectionAutoType.Anchor
          }
        }
      }
    },
    {
      id: ModuleKey.Popouts,
      name: "Popouts",
      meta: {
        waitUntilSafe: true,
        settings: {
          supportsAuto: {
            [AnimationSetting.Position]: true,
            [AnimationSetting.Direction]: DirectionAutoType.Anchor
          }
        }
      }
    },
    {
      id: ModuleKey.ContextMenu,
      name: "Context Menu",
      meta: {
        waitUntilSafe: true,
        settings: {
          supportsAuto: {
            [AnimationSetting.Position]: true,
            [AnimationSetting.Direction]: DirectionAutoType.Anchor
          }
        }
      }
    },
    {
      id: ModuleKey.ChannelList,
      name: "Channel List",
      meta: {
        accordion: {
          create: buildAccordionGenerator(AccordionType.MarginBottom, { hideElement: true }),
          defaults: {
            [AnimationSetting.Duration]: 200,
            [AnimationSetting.Easing]: {
              type: EasingType.Ease,
              bezier: EasingBezier.InOut,
              style: EasingStyle.Quad
            }
          }
        }
      }
    },
    {
      id: ModuleKey.Layers,
      name: "Layers",
      meta: {
        type: ModuleType.Switch,
        settings: {
          supportsAuto: {
            [AnimationSetting.Position]: [PositionAutoType.Precise, { preservable: true, preserveLabel: "Preserve for individual layers" }],
            [AnimationSetting.Direction]: DirectionAutoType.Alternate
          },
          defaults: {
            [AnimationSetting.DirectionAxis]: Axis.Z,
            [AnimationSetting.Overflow]: false
          },
          hideOverflow: true
        }
      }
    },
    {
      id: ModuleKey.Settings,
      name: "Settings",
      meta: {
        type: ModuleType.Switch,
        settings: {
          supportsAuto: {
            [AnimationSetting.Position]: PositionAutoType.Precise,
            [AnimationSetting.Direction]: DirectionAutoType.Alternate
          },
          defaults: {
            [AnimationSetting.DirectionAxis]: Axis.Y,
            [AnimationSetting.Overflow]: false
          }
        }
      }
    },
    {
      id: ModuleKey.Modals,
      name: "Modals",
      meta: {
        settings: {
          supportsAuto: {
            [AnimationSetting.Position]: [PositionAutoType.Precise, { asDefault: false }]
          }
        }
      }
    },
    {
      id: ModuleKey.ModalsBackdrop,
      name: "Backdrop",
      parent: ModuleKey.Modals,
      meta: {
        revert: false,
        settings: {
          supportsAuto: {
            [AnimationSetting.Position]: [PositionAutoType.Precise, { asDefault: false }]
          },
          hideOverflow: true
        }
      }
    },
    {
      id: ModuleKey.MembersSidebar,
      name: "Members Sidebar",
      meta: {
        settings: {
          supportsAuto: {
            [AnimationSetting.Position]: [PositionAutoType.Precise, { asDefault: false }]
          }
        },
        accordion: {
          create: buildAccordionGenerator(AccordionType.MarginRight),
          defaults: {
            [AnimationSetting.Duration]: 400,
            [AnimationSetting.Easing]: {
              type: EasingType.Ease,
              bezier: EasingBezier.InOut,
              style: EasingStyle.Quint
            }
          }
        }
      }
    },
    {
      id: ModuleKey.ThreadSidebar,
      name: "Thread Sidebar",
      meta: {
        settings: {
          supportsAuto: {
            [AnimationSetting.Position]: [PositionAutoType.Precise, { asDefault: false }]
          }
        },
        accordion: {
          create: buildAccordionGenerator(AccordionType.MarginRight),
          defaults: {
            [AnimationSetting.Duration]: 400,
            [AnimationSetting.Easing]: {
              type: EasingType.Ease,
              bezier: EasingBezier.InOut,
              style: EasingStyle.Quint
            }
          }
        }
      }
    },
    {
      id: ModuleKey.ThreadSidebarSwitch,
      name: "Switch",
      parent: ModuleKey.ThreadSidebar,
      meta: {
        type: ModuleType.Switch,
        settings: {
          supportsAuto: {
            [AnimationSetting.Position]: [PositionAutoType.Precise, { asDefault: false }]
          },
          defaults: {
            [AnimationSetting.Overflow]: false
          }
        }
      }
    }
  ];
  const DefaultConditionsSchema = strictObjectType({
    type: enumType(AnimationType.values()),
    "module.type": enumType(ModuleType.values()),
    module: ArrayOrSingleSchema(
      enumType(ModuleKey.values().concat(ModuleKeyAlias.values()))
    ).transform((value) => [].concat(value).flatMap((key2) => moduleAliases[key2] ?? key2))
  }).partial();
  function computeOverridable(overridable, conditionValues, presets = {}) {
    return Object.assign(
      omit(overridable, ["override"]),
      ...[].concat(overridable.override).flatMap(
        (override) => override != null && "preset" in override ? presets[override.preset] : override
      ).filter(
        (override) => override != null && Object.entries(override.for).every(
          ([condition, values]) => [].concat(values).includes(conditionValues[condition])
        )
      ).map((v) => omit(v, ["for"]))
    );
  }
  const OverrideSchema = (schema, conditionsSchema = DefaultConditionsSchema) => schema.partial().extend({
    for: conditionsSchema
  });
  const OverridableSchema = (schema, { conditionsSchema, presets = [] } = {}) => schema.extend({
    override: ArrayOrSingleSchema(
      !presets.length ? OverrideSchema(schema, conditionsSchema) : unionType([
        OverrideSchema(schema, conditionsSchema),
        strictObjectType({
          preset: enumType(presets)
        })
      ])
    ).optional()
  });
  const DurationSchema = (from = MIN_ANIMATION_DURATION, to = MAX_ANIMATION_DURATION) => numberType().int().min(from).max(to);
  const DefaultsSchema = (settings) => {
    const entries = [];
    if (AnimationSetting.Duration in settings) {
      const { from, to } = settings[AnimationSetting.Duration];
      entries.push([AnimationSetting.Duration, DurationSchema(from, to)]);
    }
    if (AnimationSetting.Easing in settings) entries.push(
      [AnimationSetting.Easing, EasingSchema]
    );
    if (AnimationSetting.Variant in settings) entries.push(
      [AnimationSetting.Variant, enumType(settings[AnimationSetting.Variant].map((v) => v.key))]
    );
    if (AnimationSetting.Position in settings) entries.push(
      [AnimationSetting.Position, enumType(settings[AnimationSetting.Position] === true ? Position.values() : settings[AnimationSetting.Position])],
      [AnimationSetting.PositionPreserve, booleanType().optional()]
    );
    if (AnimationSetting.Direction in settings) entries.push(
      [AnimationSetting.Direction, enumType(settings[AnimationSetting.Direction])],
      [AnimationSetting.DirectionAxis, enumType(getSupportedAxes(settings[AnimationSetting.Direction])).optional()],
      [AnimationSetting.DirectionReverse, booleanType().optional()],
      [AnimationSetting.DirectionTowards, booleanType().optional()]
    );
    if (AnimationSetting.Overflow in settings) entries.push(
      [AnimationSetting.Overflow, booleanType()]
    );
    return OverridableSchema(
      strictObjectType(
        Object.fromEntries(entries)
      )
    );
  };
  const SettingsSchema = objectType({
    [AnimationSetting.Duration]: unionType([
      literalType(true),
      objectType({
        from: numberType().int().min(MIN_ANIMATION_DURATION).multipleOf(100),
        to: numberType().int().max(MAX_ANIMATION_DURATION).multipleOf(100)
      }).strict()
    ]).optional().transform((v) => v === true ? { from: MIN_ANIMATION_DURATION, to: 2e3 } : v).refine(
      (value) => !value || value.to > value.from,
      { message: `'to' must be greater than 'from'`, path: ["to"] }
    ),
    [AnimationSetting.Easing]: literalType(true).optional(),
    [AnimationSetting.Variant]: objectType({
      key: stringType().refine(
        restrictReservedKeys,
        (key2) => ({ message: `Forbidden variant key: '${key2}'` })
      ),
      name: stringType()
    }).strict().array().nonempty().optional(),
    [AnimationSetting.Position]: unionType([
      literalType(true),
      literalType("precise"),
      literalType("enum"),
      literalType("simple"),
      enumType(Position.values()).array().nonempty()
    ]).optional().transform((value) => {
      switch (value) {
        case "precise":
          return true;
        case "enum":
          return Position.values();
        case "simple":
          return [Position.Top, Position.Bottom, Position.Left, Position.Right, Position.Center];
        default:
          return value;
      }
    }),
    [AnimationSetting.Direction]: unionType([
      literalType(true),
      enumType(Direction.values()).array().nonempty()
    ]).optional().transform((value) => value === true ? [Direction.Upwards, Direction.Downwards, Direction.Leftwards, Direction.Rightwards] : value),
    [AnimationSetting.Overflow]: booleanType().optional(),
    defaults: recordType(anyType())
  }).strict().transform((settings, ctx) => {
    settings.defaults = DefaultsSchema(settings).parse(
      settings.defaults,
      { path: [...ctx.path, "defaults"] }
    );
    return settings;
  });
  function getVariableName(type, name2) {
    return `__accordion_${type}__${name2}`;
  }
  function getDefaultType(module2, type) {
    switch (module2.id) {
      case ModuleKey.Messages:
        return type === AnimationType.Enter ? AccordionType.MarginBottom : null;
      case ModuleKey.MembersSidebar:
      case ModuleKey.ThreadSidebar:
        return AccordionType.MarginRight;
      default:
        return null;
    }
  }
  function buildAccordion(type, { duration, easing }) {
    const variableName = getVariableName(type, "value");
    return {
      "onBeforeCreate": {
        "inject": "var.set",
        "name": variableName,
        "value": {
          "inject": "*",
          "a": -1,
          "b": {
            "inject": "+",
            "a": {
              "inject": "utils.get",
              "target": { "inject": "element" },
              "property": getSizeProperty(type),
              "unit": false
            },
            "b": {
              "inject": "utils.get",
              "target": { "inject": "container" },
              "property": getMarginProperty(type, true),
              "unit": false
            }
          }
        }
      },
      "anime": {
        "targets": { "inject": "container" },
        "parameters": {
          "duration": duration,
          "ease": {
            "inject": "easing",
            "easing": easing
          },
          [getMarginProperty(type)]: {
            "inject": "type",
            "enter": {
              "inject": "isIntersected",
              "true": 0,
              "false": {
                "from": {
                  "inject": "var.get",
                  "name": variableName
                }
              }
            },
            "exit": {
              "inject": "var.get",
              "name": variableName
            }
          }
        }
      }
    };
  }
  const AccordionInjectSchema = ({ module: module2, type, settings, duration, easing }) => InjectSchema(Inject.Accordion).extend({
    type: unionType([
      enumType(AccordionType.values()),
      nullType()
    ]).optional().default(getDefaultType(module2, type)),
    duration: AnimationSetting.Duration in settings ? DurationSchema().optional().default(duration) : DurationSchema(),
    easing: AnimationSetting.Easing in settings ? EasingSchema.optional().default(easing) : EasingSchema
  }).transform(
    ({ type: type2, duration: duration2, easing: easing2 }) => type2 ? buildAccordion(type2, { duration: duration2, easing: easing2 }) : null
  );
  const AccordionsInjectSchemas = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    AccordionInjectSchema
  }, Symbol.toStringTag, { value: "Module" }));
  function assertInjectType(type) {
    if (Array.isArray(type)) return type.map(assertInjectType).filter(Boolean);
    return injectTypes.find((t) => t.toLowerCase() === type.toLowerCase());
  }
  function parseInject({ schema, context, env: env2, value, ctx }) {
    const path2 = getSourcePath(value, SELF_KEY);
    const report = path2 && Debug.animation(context.animation, context.type).inject(value.inject, path2, context, value);
    try {
      const parsed = (typeof schema === "function" ? schema(context, env2) : schema).parse(value, { path: ctx.path });
      report?.(parsed);
      return parsed;
    } catch (error2) {
      throw error2 instanceof AnimationError ? error2 : new AnimationError(
        context.animation,
        formatZodError(error2, {
          pack: context.pack,
          data: value,
          context,
          path: ctx.path,
          sourceMap: { useSelf: true },
          docs: Documentation.getInjectUrl(value.inject)
        }),
        { module: context.module, pack: context.pack, type: context.type, context }
      );
    }
  }
  const stopPropagation = (value) => baseStopPropagation(value) || value.inject === Inject.Raw;
  function parseInjectable(value, context, env2 = {}, { path: path2 = [] } = {}) {
    const { allowed, disallowed, stage } = env2;
    const callback = (value2, ctx) => {
      try {
        if (isSourceMap(value2)) return value2;
        if (isLazyInject(value2)) {
          const generated = value2.generator(context, env2);
          generated[generatedLazyInjectSymbol] = value2.name;
          return trust(generated);
        }
        if (value2?.inject === void 0)
          return value2;
        try {
          const [schema, meta2] = injectSchemas[value2.inject] ?? [];
          if (stage === ParseStage.Initialize) {
            if (!schema) {
              const { found, word, suggestions } = injectDict.lookup(String(value2.inject));
              const injects = assertInjectType(found ? [word] : suggestions.map((s) => s.word));
              ctx.addIssue({
                code: ZodIssueCode.custom,
                message: `Unknown inject '${value2.inject}'` + (injects.length ? `. Did you mean: ${formatValuesList(injects)}` : ""),
                path: ["inject"]
              });
              return NEVER;
            }
            if (disallowed?.length && disallowed.includes(value2.inject) || allowed?.length && !allowed.includes(value2.inject) || typeof meta2.allowed === "function" && !meta2.allowed({ value: value2, context, ctx, env: env2 })) {
              ctx.addIssue({
                code: ZodIssueCode.custom,
                message: `Inject '${value2.inject}' is not allowed`
              });
              return NEVER;
            }
            if (meta2.immediate === true || Array.isArray(meta2.immediate) && meta2.immediate.every((key2) => key2 in context))
              return parseInject({ schema, context, env: env2, value: value2, ctx });
            if (meta2.lazy)
              return wrapLazyInject(
                value2.inject,
                (context2, env3) => (...args) => {
                  const path3 = getSourcePath(value2, SELF_KEY);
                  const groupEnd = path3 && Debug.animation(context2.animation, context2.type).lazyInjectCall(value2.inject, path3, args, context2);
                  try {
                    return parseInjectable(value2, context2, {
                      ...env3,
                      stage: ParseStage.Lazy,
                      args
                    }, { path: ctx.path });
                  } catch (error2) {
                    groupEnd?.();
                    context2.onError(
                      error2 instanceof AnimationError ? error2 : new AnimationError(
                        context2.animation,
                        formatZodError(error2, { pack: context2.pack, data: value2, context: context2, path: ctx.path, sourceMap: { useSelf: true } }),
                        { module: context2.module, pack: context2.pack, type: context2.type, context: context2 }
                      )
                    );
                    context2.instance.cancel(true);
                  } finally {
                    groupEnd?.();
                  }
                }
              );
            return value2;
          }
          return parseInject({ schema, context, env: env2, value: value2, ctx });
        } catch (error2) {
          if (error2 instanceof AnimationError) throw error2;
          ctx.addIssue({
            code: ZodIssueCode.custom,
            message: error2.message,
            path: ["inject"],
            params: { error: error2 }
          });
        }
      } catch (error2) {
        if (error2 instanceof AnimationError) throw error2;
        ctx.addIssue({
          code: ZodIssueCode.custom,
          message: error2.message,
          params: { error: error2 }
        });
      }
    };
    return deepMap(value, callback, { stopPropagation, path: path2 });
  }
  const SnippetInjectSchema = (context, env2) => InjectSchema(Inject.Snippet).extend({
    key: enumType(context.pack.snippets?.map((s) => s.key) ?? []),
    params: recordType(stringType(), anyType()).optional(),
    raw: booleanType().optional().default(false)
  }).transform(({ key: key2, params, raw }, ctx) => {
    if (env2.snippet && env2.snippet.depth > 10) {
      ctx.addIssue({
        code: ZodIssueCode.custom,
        message: "Maximum snippet depth exceeded"
      });
      return NEVER;
    }
    const snippetIndex = context.pack.snippets?.findIndex((s) => s.key === key2);
    if (snippetIndex == null || snippetIndex === -1) return;
    const snippet = context.pack.snippets[snippetIndex];
    if (raw) return snippet.value;
    const snippetEnv = {
      ...env2,
      snippet: {
        key: snippet.key,
        params: Object.assign({}, snippet.params, params),
        depth: env2.snippet ? env2.snippet.depth + 1 : 1
      }
    };
    const path2 = ["snippets", snippetIndex, "value"];
    try {
      const value = parseInjectable(snippet.value, context, {
        ...snippetEnv,
        stage: ParseStage.Initialize
      }, { path: path2 });
      return parseInjectable(value, context, snippetEnv, { path: path2 });
    } catch (error2) {
      throw error2 instanceof AnimationError ? error2 : new AnimationError(
        context.animation,
        formatZodError(error2, { pack: context.pack, data: snippet.value, context, path: path2, sourceMap: { useSelf: true } }),
        { module: context.module, pack: context.pack, type: context.type, context }
      );
    }
  });
  const SnippetParamsInjectSchema = InjectWithMeta(
    (context, { snippet }) => InjectSchema(Inject.SnippetParams).extend({
      name: stringType()
    }).transform(({ name: name2 }) => snippet.params[name2]),
    {
      allowed: ({ env: env2 }) => "snippet" in env2
    }
  );
  const SnippetsInjectSchemas = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    SnippetInjectSchema,
    SnippetParamsInjectSchema
  }, Symbol.toStringTag, { value: "Module" }));
  var spelling;
  var hasRequiredSpelling;
  function requireSpelling() {
    if (hasRequiredSpelling) return spelling;
    hasRequiredSpelling = 1;
    spelling = function(dictionary) {
      var dict = [], ALPHABETS = "abcdefghijklmnopqrstuvwxyz'- ".split(""), ETX = String.fromCharCode(3);
      function insert(word, rank) {
        var i, c, subDict = dict;
        if (rank !== void 0 && typeof rank !== "number") {
          throw new TypeError("Word's rank must be a number");
        }
        if (word === void 0) {
          throw new TypeError("Word cannot be undefined");
        }
        word = word.toString().toLowerCase().trim();
        for (i = 0; c = word.charAt(i), c; i++) {
          subDict[c] = subDict[c] || {};
          subDict = subDict[c];
        }
        if (rank !== void 0) {
          subDict[ETX] = rank;
        } else {
          subDict[ETX] = subDict[ETX] ? subDict[ETX] + 1 : 1;
        }
        return this;
      }
      function lookup(word, opts) {
        var i, subDict = dict, result = {};
        opts = opts || {};
        if (opts.suggest === void 0) {
          opts.suggest = true;
        }
        if (Array.isArray(word)) {
          result = [];
          for (i = 0; i < word.length; i++) {
            result.push(lookup(word[i], opts));
          }
          return result;
        }
        word = word.toString().toLowerCase().trim();
        if (!Number.isNaN(+word)) {
          return { found: true, word, rank: 0 };
        }
        for (i = 0; i < word.length && subDict; i++) {
          subDict = subDict[word[i]];
        }
        result.found = subDict && subDict[ETX] ? true : false;
        result.word = word;
        if (result.found) {
          result.rank = subDict[ETX];
        } else if (opts.suggest) {
          result.suggestions = suggest(word, opts);
        }
        return result;
      }
      function remove2(word) {
        if (lookup(word, { sugget: false }).found) {
          insert(word, 0);
        }
        return this;
      }
      function edits(word) {
        var i, j, edit, results = [], checkResult = function(candidate) {
          var response = lookup(candidate, { suggest: false });
          if (response.found) {
            results.push(response);
          }
        };
        for (i = 0; i < word.length; i++) {
          checkResult(word.slice(0, i) + word.slice(i + 1));
        }
        for (i = 0; i < word.length - 1; i++) {
          edit = word.slice(0, i) + word.slice(i + 1, i + 2) + word.slice(i, i + 1) + word.slice(i + 2);
          checkResult(edit);
        }
        for (i = 0; i < word.length; i++) {
          for (j = 0; j < ALPHABETS.length; j++) {
            edit = word.slice(0, i) + ALPHABETS[j] + word.slice(i + 1);
            checkResult(edit);
          }
        }
        for (i = 0; i <= word.length; i++) {
          for (j = 0; j < ALPHABETS.length; j++) {
            edit = word.slice(0, i) + ALPHABETS[j] + word.slice(i);
            checkResult(edit);
          }
        }
        return results;
      }
      function equal(word) {
        return this.word === word.word;
      }
      function suggest(word, opts) {
        var i, suggestions = [], edit1 = [], edit2 = [];
        opts = opts || {};
        opts.suggestionsLimit = opts.suggestionsLimit || 10;
        word = word.toString().toLowerCase();
        edit1 = edits(word);
        for (i = 0; i < edit1.length && edit1.length < opts.suggestionsLimit; i++) {
          edit2 = edit2.concat(edits(edit1[i].word));
        }
        edit1 = edit1.sort(function(word1, word2) {
          return word2.rank - word1.rank;
        });
        edit2 = edit2.sort(function(word1, word2) {
          return word2.rank - word1.rank;
        });
        for (i = 0; i < edit1.length && suggestions.length < opts.suggestionsLimit; i++) {
          if (!suggestions.some(equal, edit1[i])) {
            suggestions.push(edit1[i]);
          }
        }
        for (i = 0; i < edit2.length && suggestions.length < opts.suggestionsLimit; i++) {
          if (!suggestions.some(equal, edit2[i])) {
            suggestions.push(edit2[i]);
          }
        }
        return suggestions;
      }
      function fetchWords(subDict, prefix) {
        var key2, results = [];
        for (key2 in subDict) {
          if (Object.prototype.hasOwnProperty.call(subDict, key2) && subDict[key2][ETX]) {
            results.push({ word: prefix + key2, rank: subDict[key2][ETX] });
          }
        }
        return results;
      }
      function doSearch(prefix, subDict, opts) {
        var key2, results = [];
        if (!opts.depth || !subDict) {
          return results;
        }
        results = results.concat(fetchWords(subDict, prefix));
        for (key2 in subDict) {
          if (Object.prototype.hasOwnProperty.call(subDict, key2)) {
            results = results.concat(doSearch(prefix + key2, subDict[key2], { depth: opts.depth - 1 }));
          }
        }
        return results;
      }
      function search(prefix, opts) {
        var i, results = [], subDict = dict, word;
        opts = opts || {};
        if (opts.depth === void 0) {
          opts.depth = 3;
        }
        prefix = prefix.toString().toLowerCase().trim();
        for (i = 0; i < prefix.length && subDict; i++) {
          subDict = subDict[prefix[i]];
        }
        if (!subDict) {
          return results;
        }
        results = doSearch(prefix, subDict, opts);
        word = lookup(prefix, { suggest: false });
        if (word.found) {
          results.push({ word: prefix, rank: word.rank });
        }
        return results.sort(function(word1, word2) {
          return word2.rank - word1.rank;
        });
      }
      function build() {
        if (dictionary === void 0) return;
        if (typeof dictionary === "string") {
          var i, words = dictionary.split(" ");
          for (i = 0; i < words.length; i++) {
            insert(words[i], +words[++i]);
          }
          dictionary = "";
        } else if (Array.isArray(dictionary)) {
          dictionary.forEach(function(elem) {
            insert(elem, 1);
          });
          dictionary = "";
        }
      }
      build();
      return {
        insert,
        lookup,
        remove: remove2,
        search
      };
    };
    return spelling;
  }
  var spellingExports = requireSpelling();
  const Spelling = /* @__PURE__ */ getDefaultExportFromCjs(spellingExports);
  function parseInjectSchemas(schemas) {
    return Object.fromEntries(
      Object.entries(schemas).filter(([key2]) => key2.endsWith("InjectSchema")).map(([key2, schema]) => [
        Inject[key2.replace(/InjectSchema$/, "")],
        InjectWithMeta(schema)
      ])
    );
  }
  const groupedInjectSchemas = {
    general: parseInjectSchemas(GeneralInjectSchemas),
    object: parseInjectSchemas(ObjectInjectSchemas),
    array: parseInjectSchemas(ArrayInjectSchemas),
    anime: parseInjectSchemas(AnimeInjectSchemas),
    settings: parseInjectSchemas(SettingsInjectSchemas),
    math: parseInjectSchemas(MathInjectSchemas),
    operators: parseInjectSchemas(OperatorsInjectSchemas),
    accordions: parseInjectSchemas(AccordionsInjectSchemas),
    snippets: parseInjectSchemas(SnippetsInjectSchemas)
  };
  const injectSchemas = Object.assign({}, ...Object.values(groupedInjectSchemas));
  const injectTypes = Object.keys(injectSchemas);
  const injectDict = new Spelling(injectTypes);
  const safeInjects = [
    ...Object.keys(groupedInjectSchemas.settings),
    ...Object.keys(groupedInjectSchemas.math),
    ...Object.keys(groupedInjectSchemas.operators),
    ...Object.keys(groupedInjectSchemas.array),
    ...Object.keys(groupedInjectSchemas.snippets),
    // Anime
    Inject.UtilsRandom,
    Inject.UtilsGet,
    // Common
    Inject.Element,
    Inject.Hast,
    Inject.Container,
    Inject.Anchor,
    Inject.Module,
    Inject.ModuleType,
    Inject.Type,
    Inject.Assign,
    Inject.StringTemplate,
    Inject.Undefined,
    Inject.VarGet,
    Inject.Rect,
    Inject.Window,
    Inject.Mouse,
    Inject.IsIntersected,
    Inject.If,
    Inject.Switch,
    Inject.Raw,
    Inject.Vector,
    Inject.Rotate
  ];
  const layoutDependentInjects = [
    Inject.Hast
  ];
  const Documentation = new class Documentation2 {
    Definition = {
      Pack: "pack",
      Animation: "animation",
      Meta: "meta",
      Settings: "settings",
      Animate: "animate",
      Anime: "anime",
      Snippet: "snippet",
      Easing: "easing"
    };
    Setting = {
      Duration: "duration",
      Position: "position",
      Direction: "direction",
      Variant: "variant",
      Easing: "easing",
      Overflow: "overflow"
    };
    get baseUrl() {
      return "https://docs.betteranimations.net";
    }
    get referenceBaseUrl() {
      return `${this.baseUrl}/reference`;
    }
    get injectsBaseUrl() {
      return `${this.referenceBaseUrl}/injects`;
    }
    get homeUrl() {
      return this.baseUrl;
    }
    get usageUrl() {
      return `${this.baseUrl}/usage/basics`;
    }
    get createUrl() {
      return `${this.baseUrl}/create/introduction`;
    }
    get packDirectoryUrl() {
      return `${this.baseUrl}/usage/pack-directory`;
    }
    get enhanceLayoutUrl() {
      return `${this.baseUrl}/usage/modules#enhance-layout`;
    }
    get accordionUrl() {
      return `${this.baseUrl}/usage/basics#expand-collapse-animations`;
    }
    get themeCompatibilityUrl() {
      return `${this.baseUrl}/usage/theme-compatibility`;
    }
    getDefinitionUrl(definition) {
      return `${this.referenceBaseUrl}/${definition.toLowerCase()}`;
    }
    getInjectGroup(inject) {
      return Object.keys(groupedInjectSchemas).find((group) => inject in groupedInjectSchemas[group] && group !== "operators");
    }
    getInjectAnchor(inject) {
      return inject.match(/[a-zA-Z0-9]+/g).join("-").toLowerCase();
    }
    getInjectUrl(inject) {
      const group = this.getInjectGroup(inject);
      if (!group) return;
      return `${this.injectsBaseUrl}/${group}#${this.getInjectAnchor(inject)}`;
    }
    getSettingUrl(setting) {
      const section2 = [this.Setting.Easing, this.Setting.Overflow].includes(setting) ? "advanced-animation-settings" : "animation-settings";
      return `${this.baseUrl}/usage/${section2}#${setting.toLowerCase()}`;
    }
  }();
  const ParsableSchema = (stage, schema) => (context, env2) => (![ParseStage.Initialize, stage].includes(env2.stage) ? anyType() : anyType().transform((value, ctx) => parseInjectable(
    value,
    context,
    env2,
    { path: ctx.path }
  ))).transform((value, ctx) => {
    try {
      return (env2.stage === stage ? typeof schema === "function" ? schema(context, env2) : schema : anyType()).parse(value, { path: ctx.path });
    } catch (error2) {
      throw new AnimationError(
        context.animation,
        formatZodError(error2, { pack: context.pack, data: value, context, path: ctx.path, docs: Documentation.getDefinitionUrl(Documentation.Definition.Animate) }),
        { module: context.module, pack: context.pack, type: context.type, context }
      );
    }
  });
  function promisify(instance) {
    if (instance.finished) return instance.finished;
    instance.finished = Promise.resolve(instance);
    return instance.finished;
  }
  function mergeInlineStyles(instances) {
    return [].concat(instances).reduce(
      (styles, instance) => Object.assign(styles, instance._inlineStyles),
      {}
    );
  }
  function intersect(instance, withInstances = null) {
    if (!instance) return instance;
    if (withInstances) instance._inlineStyles = mergeInlineStyles(withInstances);
    return instance;
  }
  const AnimeBaseSchema = (type, isDefault = false) => SourceMappedObjectSchema.extend({
    type: isDefault ? literalType(type).optional() : literalType(type)
  }).strict();
  const AnimeTimerSchema = AnimeBaseSchema("timer").extend({
    parameters: ParametersSchema
  });
  const AnimeAnimationSchema = (context) => AnimeBaseSchema("animation", true).extend({
    targets: TargetsSchema(context),
    parameters: ParametersSchema
  });
  const AnimeWAAPISchema = (context) => AnimeBaseSchema("waapi").extend({
    targets: TargetsSchema(context),
    parameters: ParametersSchema
  });
  const AnimeTimelineChildBaseSchema = (type, isDefault = false) => AnimeBaseSchema(type, isDefault).extend({
    position: unionType([
      numberType(),
      stringType(),
      TrustedFunctionSchema
    ]).optional()
  });
  const AnimeTimelineAddChildSchema = (context) => AnimeTimelineChildBaseSchema("add", true).extend({
    targets: TargetsSchema(context).optional(),
    parameters: ParametersSchema
  });
  const AnimeTimelineSetChildSchema = (context) => AnimeTimelineChildBaseSchema("set").extend({
    targets: TargetsSchema(context),
    parameters: ParametersSchema
  });
  const AnimeTimelineLabelChildSchema = AnimeTimelineChildBaseSchema("label").extend({
    name: stringType()
  });
  const AnimeTimelineCallChildSchema = AnimeTimelineChildBaseSchema("call").extend({
    callback: TrustedFunctionSchema
  });
  const AnimeTimelineChildSchema = (context) => discriminatedUnionType("type", [
    AnimeTimelineAddChildSchema(context),
    AnimeTimelineSetChildSchema(context),
    AnimeTimelineLabelChildSchema,
    AnimeTimelineCallChildSchema
  ]);
  const AnimeTimelineSchema = (context) => AnimeBaseSchema("timeline").extend({
    parameters: ParametersSchema.optional(),
    children: arrayType(AnimeTimelineChildSchema(context)).nonempty()
  });
  function prepareParameters(parameters) {
    return Object.assign(
      parameters ? clearSourceMapDeep(parameters) : {},
      { autoplay: false }
    );
  }
  function buildInstance({ type, targets, parameters, children: children2 }) {
    parameters = prepareParameters(parameters);
    switch (type) {
      case "timer":
        return createTimer(parameters);
      case "timeline": {
        const tl = createTimeline(parameters);
        clearSourceMapDeep(children2).forEach((child) => {
          switch (child.type) {
            case "set":
              return tl.set(child.targets, prepareParameters(child.parameters), child.position);
            case "label":
              return tl.label(child.name, child.position);
            case "call":
              return tl.call(child.callback, child.position);
            default:
              return tl.add(
                ...(child.targets ? [child.targets] : []).concat([prepareParameters(child.parameters), child.position])
              );
          }
        });
        return tl;
      }
      case "waapi":
        return waapi.animate(targets, parameters);
      default:
        return animate(targets, parameters);
    }
  }
  const AnimeInstanceSchema = (context) => discriminatedUnionType("type", [
    AnimeTimerSchema,
    AnimeAnimationSchema(context),
    AnimeWAAPISchema(context),
    AnimeTimelineSchema(context)
  ]).transform(
    zodTransformErrorBoundary(
      (options) => storeInjectable(
        intersect(
          buildInstance(options),
          context.intersectWith?.instances
        ),
        options
      )
    )
  );
  const AnimeSchema = (context) => ArrayOrSingleSchema(
    ArrayOrSingleSchema(
      AnimeInstanceSchema(context).nullable()
    )
  ).transform((instances) => [].concat(instances).flat().filter((i) => i != null)).refine(
    (instances) => instances.length > 0,
    { message: "No anime instances created" }
  );
  function buildPreLayoutEnv(env2) {
    return Object.assign({ disallowed: layoutDependentInjects }, env2);
  }
  function buildLayoutEnv(env2) {
    return Object.assign({ allowed: safeInjects, disallowed: layoutDependentInjects }, env2);
  }
  const HookSchema = (context, env2, stage) => ParsableSchema(
    stage,
    (context2) => ArrayOrSingleSchema(
      ArrayOrSingleSchema(
        TrustedFunctionSchema.nullable()
      )
    ).transform(
      zodTransformErrorBoundary((value, ctx) => {
        const hook = () => executeWithZod(value, (value2, ctx2) => {
          [].concat(value2).flat().forEach((fn, i) => {
            if (!fn) return;
            try {
              fn();
            } catch (error2) {
              ctx2.addIssue({
                code: ZodIssueCode.custom,
                message: error2.message,
                path: Array.isArray(value2) ? [i] : [],
                params: { error: error2, received: fn }
              });
            }
          });
        }, context2, ctx);
        return storeInjectable(hook, value);
      })
    ).optional()
  )(context, env2);
  const HastSchema = ParsableSchema(
    ParseStage.Layout,
    ArrayOrSingleSchema(
      ArrayOrSingleSchema(
        recordType(anyType()).nullable()
      )
    ).transform(
      zodTransformErrorBoundary((value, ctx) => {
        return [].concat(value).flat().filter(Boolean).map((node, i) => {
          const sanitized = sanitize(clearSourceMapDeep(node), hastSanitizeSchema);
          if (sanitized.type === "root") {
            ctx.addIssue({
              code: ZodIssueCode.custom,
              message: "Invalid or forbidden hast node",
              path: Array.isArray(value) ? [i] : [],
              params: { received: node }
            });
            return NEVER;
          }
          return storeInjectable(
            toDom(sanitized),
            value
          );
        });
      })
    ).optional()
  );
  const CssSchema = ParsableSchema(
    ParseStage.Layout,
    ArrayOrSingleSchema(
      ArrayOrSingleSchema(
        recordType(
          unionType([
            recordType(
              unionType([stringType(), numberType(), SourceMapSchema])
            ),
            SourceMapSchema
          ])
        ).nullable()
      )
    ).optional()
  );
  const ParsableAnimeSchema = ParsableSchema(
    ParseStage.Anime,
    AnimeSchema
  );
  const ParsableAnimateSchema = (context, env2) => {
    const preLayoutEnv = buildPreLayoutEnv(env2);
    const layoutEnv = buildLayoutEnv(env2);
    return SourceMappedObjectSchema.extend({
      onBeforeLayout: HookSchema(context, preLayoutEnv, ParseStage.BeforeLayout),
      hast: HastSchema(context, layoutEnv),
      css: CssSchema(context, layoutEnv),
      onBeforeCreate: HookSchema(context, env2, ParseStage.BeforeCreate),
      anime: ParsableAnimeSchema(context, env2),
      onCreated: HookSchema(context, env2, ParseStage.Created),
      onBeforeBegin: HookSchema(context, env2, ParseStage.BeforeBegin),
      onCompleted: HookSchema(context, env2, ParseStage.Completed),
      onBeforeDestroy: HookSchema(context, preLayoutEnv, ParseStage.BeforeDestroy),
      onDestroyed: HookSchema(context, preLayoutEnv, ParseStage.Destroyed)
    }).strict();
  };
  const ExtendsSchema = ParsableSchema(
    ParseStage.Extend,
    anyType()
  );
  const ParsableExtendableAnimateSchema = (context, env2) => {
    const preLayoutEnv = buildPreLayoutEnv(env2);
    return ParsableAnimateSchema(context, env2).extend({
      onBeforeExtend: HookSchema(context, preLayoutEnv, ParseStage.BeforeExtend),
      extends: ArrayOrSingleSchema(ExtendsSchema(context, preLayoutEnv)).optional()
    }).strict();
  };
  const ParsableExtendsSchema = (context, env2) => ArrayOrSingleSchema(
    ParsableExtendableAnimateSchema(context, env2).nullable()
  ).optional();
  function buildContext(pack, animation, type, settings = {}, meta2 = {}, context = {}) {
    return Object.assign(
      {
        pack,
        animation,
        settings: animation?.settings,
        meta: meta2,
        type,
        vars: {}
      },
      settings,
      context
    );
  }
  function buildWrapper(data2, context) {
    if (!data2.hast && !data2.css) return null;
    const id = `${context.module.id}-${context.type}-${Date.now()}`;
    const wrapper = context.document.createElement("div");
    wrapper.setAttribute("data-baa", id);
    wrapper.append(
      ...[].concat(data2.hast).filter(isElement)
    );
    if (data2.css) {
      const parent = `[data-baa="${id}"]`;
      wrapper.append(
        ...[].concat(
          data2.css
        ).flat().filter(Boolean).map((css2, cssIndex) => {
          const element2 = context.document.createElement("style");
          element2.appendChild(context.document.createTextNode(
            buildCSS(
              clearSourceMapDeep(css2),
              (selector, selectorIndex) => {
                if (selector === "{element}") return `${parent} + *`;
                if (selector === "{container}") return `[data-ba-container]:has(> ${parent})`;
                const attribute = `data-baa-${id}-${cssIndex}-${selectorIndex}`;
                try {
                  wrapper.querySelectorAll(selector).forEach((e) => e.setAttribute(attribute, ""));
                } catch {
                  Debug.animation(context.animation, context.type).invalidSelector(selector, getSourcePath(css2, selector) ?? context.path.concat("css"), context);
                }
                return `[${attribute}]`;
              }
            )
          ));
          return element2;
        })
      );
    }
    return wrapper;
  }
  function parse(data2 = null, context, options = {}) {
    const debug = context.animation ? Debug.animation(context.animation, context.type) : null;
    const _parseStage = (stage, data3, schema, path2 = []) => {
      path2 = context.path.concat(path2);
      const groupEnd = debug?.parseStart(stage, data3, context);
      try {
        data3 = data3 ? schema(context, { stage }).parse(data3, { path: path2 }) : {};
        debug?.parseEnd(stage, data3, context);
        return data3;
      } catch (error2) {
        groupEnd?.();
        context.onError(
          error2 instanceof AnimationError ? error2 : new AnimationError(
            context.animation,
            formatZodError(error2, { pack: context.pack, data: data3, context, path: path2, docs: Documentation.getDefinitionUrl(Documentation.Definition.Animate) }),
            { module: context.module, pack: context.pack, type: context.type, context }
          )
        );
        context.instance.cancel(true);
        return null;
      } finally {
        groupEnd?.();
      }
    };
    const _hook = (name2, stage, data3, schema, path2 = []) => {
      debug?.hook(name2, context);
      if (!(name2 in (data3 ?? {}))) return data3;
      data3 = _parseStage(stage, data3, schema, path2);
      if (data3 === null) return null;
      data3[name2]?.();
      return data3;
    };
    const extend = (data3, path2 = [], _depth = 1) => {
      if (_depth > 10) {
        context.onError(
          new AnimationError(
            context.animation,
            "Maximum extend depth exceeded",
            { module: context.module, pack: context.pack, type: context.type, context }
          )
        );
        context.instance.cancel(true);
        return { success: false, data: data3 };
      }
      if (!("extends" in (data3 ?? {}))) return { success: true, data: data3 };
      if (_hook("onBeforeExtend", ParseStage.BeforeExtend, data3, ParsableExtendableAnimateSchema, path2) === null) return { success: false, data: data3 };
      data3 = omit(data3, ["onBeforeExtend"]);
      let _data = _parseStage(ParseStage.Extend, data3, ParsableExtendableAnimateSchema, path2);
      if (_data === null) return { success: false, data: data3 };
      _data.extends = _parseStage(ParseStage.Initialize, _data.extends, ParsableExtendsSchema, path2.concat("extends"));
      if (_data.extends === null) return { success: false, data: data3 };
      const _extends = [];
      for (const value of [].concat(_data.extends)) {
        const { success, data: data4 } = extend(
          value,
          path2.concat("extends", Array.isArray(_data.extends) ? _data.extends.indexOf(value) : []),
          _depth + 1
        );
        if (!success) return { success: false, data: data4 };
        _extends.unshift(data4);
      }
      data3 = omit(data3, ["extends"]);
      _extends.forEach((value) => {
        if (!value) return;
        sourceMappedObjectEntries(value).forEach(([key2, value2]) => {
          if (!data3[key2]) data3[key2] = [];
          data3[key2] = [].concat(value2).concat(data3[key2]);
        });
      });
      return { success: true, data: data3 };
    };
    const parseStage = (stage, schema = ParsableAnimateSchema) => {
      if (data2 === null) return true;
      const _data = _parseStage(stage, data2, schema);
      if (_data === null) return false;
      data2 = _data;
      return true;
    };
    const hook = (name2, stage, schema = ParsableAnimateSchema) => {
      if (data2 === null) return true;
      const _data = _hook(name2, stage, data2, schema);
      if (_data === null) return false;
      data2 = _data;
      return !context.instance.cancelled;
    };
    let before, after, accordion;
    const sharedHook = (name2, stage, schema = ParsableExtendableAnimateSchema) => () => {
      before?.[name2]?.();
      after?.[name2]?.();
      return hook(name2, stage, schema);
    };
    context.instance.onBeforeDestroy = sharedHook("onBeforeDestroy", ParseStage.BeforeDestroy);
    context.instance.onDestroyed = sharedHook("onDestroyed", ParseStage.Destroyed);
    parsing: {
      const { success, data: _data } = extend(data2);
      data2 = _data;
      if (!success) break parsing;
      if (!hook("onBeforeLayout", ParseStage.BeforeLayout)) break parsing;
      if (!parseStage(ParseStage.Layout)) break parsing;
      context.wrapper = data2 ? buildWrapper(data2, context) : null;
      if (!hook("onBeforeCreate", ParseStage.BeforeCreate)) break parsing;
      if (!parseStage(ParseStage.Anime)) break parsing;
      if (!hook("onCreated", ParseStage.Created)) break parsing;
      before = options.before && (!context.intersectWith?.accordion || context.intersectWith.accordion.began) ? options.before(context) : null;
      after = options.after ? options.after(context) : null;
      accordion = intersect(
        before?.execute() ?? after?.execute() ?? null,
        context.intersectWith?.accordion
      );
    }
    const instances = !context.instance.cancelled ? data2?.anime ?? [] : [];
    instances.pause = () => instances.concat(accordion).forEach((i) => i?.pause());
    instances.cancel = () => instances.concat(accordion).forEach((i) => i?.cancel());
    instances.revert = () => instances.concat(accordion).forEach((i) => i?.revert());
    const finishedAll = Promise.all(instances.map(promisify));
    const raf = (fn) => context.window.requestAnimationFrame(
      () => !context.instance.cancelled && fn()
    );
    let onBeforeBegin;
    const begin = (immediate = true) => {
      if (context.instance.cancelled) return;
      onBeforeBegin = () => hook("onBeforeBegin", ParseStage.BeforeBegin);
      if (!immediate) {
        onBeforeBegin();
        if (context.instance.cancelled) return;
      }
      raf(() => instances.forEach(
        after && context.intersectWith?.accordion && !context.intersectWith.accordion.completed ? (i) => i.complete() : (i) => i.resume()
      ));
    };
    if (before) {
      onBeforeBegin = () => before.onBeforeBegin?.();
      raf(() => {
        accordion.play();
      });
      promisify(accordion).then(() => {
        before.onCompleted?.();
        begin(false);
      });
    } else begin();
    return {
      wrapper: context.wrapper,
      onBeforeBegin,
      accordion,
      instances,
      finished: finishedAll.then(() => {
        if (context.instance.cancelled) return;
        if (!hook("onCompleted", ParseStage.Completed)) return;
        if (before) return promisify(accordion);
        if (after) {
          after.onBeforeBegin?.();
          raf(() => accordion.play());
          return promisify(accordion).then(() => after.onCompleted?.());
        }
      })
    };
  }
  const metaOverridePresets = {
    accordion: [
      {
        for: {
          module: [ModuleKey.Messages, ModuleKey.MembersSidebar, ModuleKey.ThreadSidebar]
        },
        accordion: false
      },
      {
        for: {
          module: ModuleKey.Messages,
          type: AnimationType.Exit
        },
        accordion: true
      }
    ]
  };
  const MetaSchema = OverridableSchema(
    strictObjectType({
      intersect: booleanType().optional().default(true),
      revert: booleanType().optional().default(true),
      accordion: booleanType().optional().default(true)
    }),
    { presets: Object.keys(metaOverridePresets) }
  );
  function Auto(enumInstance) {
    if (!enumInstance) return "auto";
    return Enum({
      ...enumInstance.raw,
      Auto: "auto"
    });
  }
  const name = "preinstalled";
  const version = "0.0.0";
  const snippets = [{ "key": "opacity", "value": { "inject": "type", "enter": { "inject": "isIntersected", "true": 1, "false": [0, 1] }, "exit": 0 } }, { "key": "directionalTranslate", "params": { "value": 5, "negativeValue": -5 }, "value": { "inject": "vector", "values": { "inject": "type", "enter": { "inject": "isIntersected", "true": { "inject": "direction", "upwards": { "y": 0 }, "downwards": { "y": 0 }, "leftwards": { "x": 0 }, "rightwards": { "x": 0 } }, "false": { "inject": "direction", "upwards": { "y": [{ "inject": "snippet.params", "name": "value" }, 0] }, "downwards": { "y": [{ "inject": "snippet.params", "name": "negativeValue" }, 0] }, "leftwards": { "x": [{ "inject": "snippet.params", "name": "value" }, 0] }, "rightwards": { "x": [{ "inject": "snippet.params", "name": "negativeValue" }, 0] } } }, "exit": { "inject": "direction", "upwards": { "y": { "inject": "snippet.params", "name": "negativeValue" } }, "downwards": { "y": { "inject": "snippet.params", "name": "value" } }, "leftwards": { "x": { "inject": "snippet.params", "name": "negativeValue" } }, "rightwards": { "x": { "inject": "snippet.params", "name": "value" } } } } } }, { "key": "computeCircle", "value": [{ "inject": "var.set", "name": "radius", "value": { "inject": "string.template", "template": "${value}px", "values": { "value": { "inject": "math.hypot", "values": [{ "inject": "math.max", "values": [{ "inject": "math.abs", "value": { "inject": "position", "value": "x", "clip": false } }, { "inject": "math.abs", "value": { "a": { "inject": "position", "value": "x", "clip": false }, "inject": "-", "b": { "inject": "rect", "value": "width" } } }] }, { "inject": "math.max", "values": [{ "inject": "math.abs", "value": { "inject": "position", "value": "y", "clip": false } }, { "inject": "math.abs", "value": { "a": { "inject": "position", "value": "y", "clip": false }, "inject": "-", "b": { "inject": "rect", "value": "height" } } }] }] } } } }, { "inject": "var.set", "name": "clipPathExpanded", "value": { "inject": "string.template", "template": "circle(${radius} at ${position})", "values": { "radius": { "inject": "var.get", "name": "radius" }, "position": { "inject": "position", "clip": false } } } }, { "inject": "var.set", "name": "clipPathCollapsed", "value": { "inject": "string.template", "template": "circle(0px at ${position})", "values": { "position": { "inject": "position", "clip": false } } } }] }];
  const animations = /* @__PURE__ */ JSON.parse('[{"key":"fade","name":"Fade","meta":{"override":{"preset":"accordion"}},"settings":{"duration":true,"easing":true,"defaults":{"duration":200,"easing":{"type":"ease"},"override":[{"for":{"module":["switch","messages","sidebars"]},"easing":{"type":"ease","style":"quart"}},{"for":{"module":["switch","sidebars"]},"duration":400}]}},"animate":{"extends":{"inject":"accordion"},"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"opacity":{"inject":"snippet","key":"opacity"}}}}},{"key":"slip","name":"Slip","settings":{"duration":true,"easing":true,"direction":true,"defaults":{"duration":200,"easing":{"type":"back"},"direction":"upwards","override":[{"for":{"module.type":"reveal","type":"exit"},"direction":"downwards","directionTowards":true},{"for":{"module":["switch","modals"]},"easing":{"type":"ease","style":"quart"}},{"for":{"module":"channelList"},"direction":"downwards"},{"for":{"module":"channelList","type":"exit"},"direction":"upwards"}]}},"animate":{"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"opacity":{"inject":"snippet","key":"opacity"},"translate":{"inject":"snippet","key":"directionalTranslate","params":{"value":5,"negativeValue":-5}}}}}},{"key":"slide","name":"Slide","modules":["switch","messages","channelList"],"meta":{"override":{"preset":"accordion"}},"settings":{"duration":true,"easing":true,"direction":true,"overflow":false,"defaults":{"duration":600,"easing":{"type":"ease","style":"quart"},"direction":"upwards","overflow":false,"override":[{"for":{"module":["messages","channelList"]},"duration":400,"direction":"rightwards","overflow":true},{"for":{"module":["messages","channelList"],"type":"exit"},"direction":"leftwards"}]}},"animate":{"extends":{"inject":"accordion"},"css":{"{container}":{"z-index":{"inject":"type","enter":2,"exit":1}}},"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"translate":{"inject":"snippet","key":"directionalTranslate","params":{"value":"100%","negativeValue":"-100%"}}}}}},{"key":"scale","name":"Scale","settings":{"duration":true,"easing":true,"position":true,"direction":["forwards","backwards"],"defaults":{"duration":200,"easing":{"type":"back"},"position":"center","direction":"backwards","override":[{"for":{"type":"exit","module.type":"reveal"},"direction":"forwards"},{"for":{"module.type":"switch"},"easing":{"type":"ease","style":"cubic"}},{"for":{"module":["messages","channelList"]},"position":"left"}]}},"animate":{"css":{"{element}":{"transform-origin":{"inject":"position"}}},"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"opacity":{"inject":"snippet","key":"opacity"},"scale":{"inject":"type","enter":{"inject":"isIntersected","true":1,"false":[{"inject":"direction","forwards":1.1,"backwards":0.9},1]},"exit":{"inject":"direction","forwards":0.9,"backwards":1.1}}}}}},{"key":"point","name":"Point","modules":["popouts","tooltips","contextMenu"],"settings":{"duration":true,"easing":true,"position":true,"defaults":{"duration":400,"easing":{"type":"ease","bezier":"out","style":"quart"},"position":"center","override":[{"for":{"type":"exit"},"easing":{"type":"ease","bezier":"in","style":"quart"}},{"for":{"module":["tooltips","contextMenu"]},"duration":200}]}},"animate":{"css":{"{element}":{"transform-origin":{"inject":"position"}}},"onBeforeCreate":[{"inject":"var.set","name":"x","value":{"a":{"inject":"position","value":"x","clip":{"a":{"inject":"module"},"inject":"===","b":"contextMenu"}},"inject":"-","b":{"inject":"position","value":"x"}}},{"inject":"var.set","name":"y","value":{"a":{"inject":"position","value":"y","clip":{"a":{"inject":"module"},"inject":"===","b":"contextMenu"}},"inject":"-","b":{"inject":"position","value":"y"}}}],"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"scale":{"inject":"type","enter":{"inject":"isIntersected","true":1,"false":[0,1]},"exit":0},"translate":{"inject":"vector","values":{"inject":"type","enter":{"inject":"isIntersected","true":{"x":0,"y":0},"false":{"x":[{"inject":"var.get","name":"x"},0],"y":[{"inject":"var.get","name":"y"},0]}},"exit":{"x":{"inject":"var.get","name":"x"},"y":{"inject":"var.get","name":"y"}}}}}}}},{"key":"blur","name":"Blur","meta":{"override":{"preset":"accordion"}},"settings":{"duration":true,"easing":true,"defaults":{"duration":200,"easing":{"type":"ease"},"override":[{"for":{"module":["switch","messages","sidebars"]},"easing":{"type":"ease","style":"quart"}},{"for":{"module":["switch","sidebars"]},"duration":400}]}},"animate":{"extends":{"inject":"accordion"},"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"opacity":{"inject":"snippet","key":"opacity"},"filter":{"inject":"type","enter":{"inject":"isIntersected","true":"blur(0)","false":["blur(12px)","blur(0)"]},"exit":"blur(12px)"}}}}},{"key":"flip","name":"Flip","modules":["reveal","sidebars"],"meta":{"override":{"preset":"accordion"}},"settings":{"duration":true,"easing":true,"position":true,"direction":["forwards","backwards"],"variant":[{"key":"horizontal","name":"Horizontal"},{"key":"vertical","name":"Vertical"}],"defaults":{"duration":400,"easing":{"type":"ease","style":"quart"},"position":"center","direction":"forwards","variant":"horizontal","override":[{"for":{"type":"exit"},"direction":"backwards"},{"for":{"module":["tooltips","channelList","contextMenu"]},"duration":200},{"for":{"module":"tooltips"},"easing":{"type":"back"}},{"for":{"module":"messages"},"position":"top"},{"for":{"module":"sidebars"},"position":"right","variant":"vertical"}]}},"animate":{"extends":{"inject":"accordion","type":{"inject":"switch","value":{"inject":"module"},"case":{"membersSidebar":"marginLeft","threadSidebar":"marginLeft"},"default":{"inject":"undefined"}}},"onBeforeLayout":[{"inject":"var.set","name":"origin","value":{"inject":"string.template","template":{"inject":"variant","horizontal":"50% ${value}px","vertical":"${value}px 50%"},"values":{"value":{"inject":"position","value":{"inject":"variant","horizontal":"y","vertical":"x"}}}}},{"inject":"var.set","name":"rotate","value":{"inject":"type","enter":{"inject":"isIntersected","true":0,"false":[{"inject":"direction","forwards":-90,"backwards":90},0]},"exit":{"inject":"direction","forwards":90,"backwards":-90}}}],"css":{"{container}":{"perspective":{"a":{"inject":"math.max","values":[{"a":{"inject":"rect","value":{"inject":"variant","horizontal":"height","vertical":"width"}},"inject":"*","b":1.75},150]},"inject":"+","b":"px"},"perspective-origin":{"inject":"var.get","name":"origin"}},"{element}":{"transform-origin":{"inject":"var.get","name":"origin"}}},"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"opacity":{"inject":"snippet","key":"opacity"},"rotate":{"inject":"rotate","axis":{"inject":"variant","horizontal":"x","vertical":"y"},"angle":{"inject":"var.get","name":"rotate"}}}}}},{"key":"outOfBounds","name":"Out-of-bounds","modules":["popouts","contextMenu","modals"],"settings":{"duration":true,"easing":true,"direction":true,"defaults":{"duration":400,"easing":{"type":"ease","bezier":"out","style":"quart"},"direction":"upwards","override":[{"for":{"type":"exit"},"easing":{"type":"ease","bezier":"in","style":"quart"},"direction":"downwards","directionTowards":true},{"for":{"module":"tooltips"},"duration":200}]}},"animate":{"css":{"{element}":{"pointer-events":"none"}},"onBeforeCreate":[{"inject":"var.set","name":"left","value":{"a":{"inject":"rect","value":"left"},"inject":"+","b":{"inject":"rect","value":"width"}}},{"inject":"var.set","name":"top","value":{"a":{"inject":"rect","value":"top"},"inject":"+","b":{"inject":"rect","value":"height"}}},{"inject":"var.set","name":"right","value":{"a":{"inject":"window","value":"width"},"inject":"-","b":{"inject":"rect","value":"left"}}},{"inject":"var.set","name":"bottom","value":{"a":{"inject":"window","value":"height"},"inject":"-","b":{"inject":"rect","value":"top"}}},{"inject":"var.set","name":"value","value":{"a":{"inject":"var.get","name":{"inject":"direction","rightwards":{"inject":"type","enter":"left","exit":"right"},"downwards":{"inject":"type","enter":"top","exit":"bottom"},"leftwards":{"inject":"type","enter":"right","exit":"left"},"upwards":{"inject":"type","enter":"bottom","exit":"top"}}},"inject":"+","b":20}}],"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"translate":{"inject":"snippet","key":"directionalTranslate","params":{"value":{"inject":"var.get","name":"value"},"negativeValue":{"a":{"inject":"var.get","name":"value"},"inject":"*","b":-1}}}}}}},{"key":"circle","name":"Circle","modules":["servers","channels","settings","popouts","contextMenu","sidebars"],"settings":{"duration":true,"easing":true,"position":true,"defaults":{"duration":200,"easing":{"type":"ease"},"position":"center","override":{"for":{"module":"switch"},"duration":400}}},"animate":{"onBeforeCreate":{"inject":"snippet","key":"computeCircle"},"css":{"{container}":{"z-index":{"inject":"type","enter":2,"exit":1}}},"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"clipPath":{"inject":"type","enter":{"inject":"isIntersected","true":{"inject":"var.get","name":"clipPathExpanded"},"false":[{"inject":"var.get","name":"clipPathCollapsed"},{"inject":"var.get","name":"clipPathExpanded"}]},"exit":{"inject":"module.type","reveal":{"inject":"isIntersected","true":{"inject":"var.get","name":"clipPathCollapsed"},"false":[{"inject":"var.get","name":"clipPathExpanded"},{"inject":"var.get","name":"clipPathCollapsed"}]},"switch":[]}},"opacity":{"inject":"module.type","switch":{"inject":"type","exit":[1,0],"enter":[]},"reveal":[]}}}}},{"key":"circleScale","name":"Circle Scale","modules":"switch","settings":{"duration":true,"easing":true,"position":true,"direction":["forwards","backwards"],"defaults":{"duration":400,"easing":{"type":"ease"},"position":"center","positionPreserve":true,"direction":"forwards"}},"animate":{"extends":{"inject":"if","value":{"a":{"a":{"a":{"inject":"type"},"inject":"===","b":"enter"},"inject":"&&","b":{"a":{"inject":"direction"},"inject":"===","b":"forwards"}},"inject":"||","b":{"a":{"a":{"inject":"type"},"inject":"===","b":"exit"},"inject":"&&","b":{"a":{"inject":"direction"},"inject":"===","b":"backwards"}}},"then":{"inject":"raw","value":{"css":{"{container}":{"z-index":2}},"onBeforeCreate":{"inject":"snippet","key":"computeCircle"},"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"clipPath":{"inject":"type","enter":[{"inject":"var.get","name":"clipPathCollapsed"},{"inject":"var.get","name":"clipPathExpanded"}],"exit":[{"inject":"var.get","name":"clipPathExpanded"},{"inject":"var.get","name":"clipPathCollapsed"}]}}}}},"else":{"inject":"raw","value":{"css":{"{container}":{"z-index":1},"{element}":{"transform-origin":{"inject":"position"}}},"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"opacity":{"inject":"snippet","key":"opacity"},"scale":{"inject":"type","enter":{"inject":"direction","backwards":[1.1,1],"forwards":[0.9,1]},"exit":{"inject":"direction","backwards":0.9,"forwards":1.1}}}}}}}}},{"key":"drawer","name":"Drawer","modules":["servers","channels","settings","popouts","contextMenu"],"settings":{"duration":true,"position":true,"defaults":{"duration":300,"position":"center","override":{"for":{"module.type":"switch"},"duration":500}}},"animate":{"onBeforeCreate":[{"inject":"var.set","name":"value","value":{"a":{"inject":"position","value":"y","unit":"%","clip":false},"inject":"*","b":100}},{"inject":"var.set","name":"isSwitchExit","value":{"a":{"a":{"inject":"module.type"},"inject":"===","b":"switch"},"inject":"&&","b":{"a":{"inject":"type"},"inject":"===","b":"exit"}}},{"inject":"var.set","name":"collapsed","value":{"inject":"if","value":{"inject":"var.get","name":"isSwitchExit"},"then":"polygon(0% 0%, 0% 0%, 100% 0%, 100% 100%, 0% 100%, 0% 100%, 100% 100%, 100% 0%)","else":{"inject":"string.template","template":"polygon(0% ${value}%, 100% ${value}%, 100% ${value}%, 0% ${value}%)","values":{"value":{"inject":"var.get","name":"value"}}}}},{"inject":"var.set","name":"expanded","value":{"inject":"if","value":{"inject":"var.get","name":"isSwitchExit"},"then":{"inject":"string.template","template":"polygon(0% 0%, 0% ${value}%, 100% ${value}%, 100% ${value}%, 0% ${value}%, 0% 100%, 100% 100%, 100% 0%)","values":{"value":{"inject":"var.get","name":"value"}}},"else":"polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)"}},{"inject":"var.set","name":"translate","value":{"a":{"inject":"math","expression":{"inject":"string.template","template":"(${value} - 0.5) * 100","values":{"value":{"inject":"position","value":"x","unit":"%","clip":false}}}},"inject":"+","b":"%"}},{"inject":"var.set","name":"translateParameters","value":{"inject":"type","enter":{"inject":"isIntersected","true":"0%","false":[{"inject":"var.get","name":"translate"},"0%"]},"exit":{"inject":"var.get","name":"translate"}}}],"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"inject":"assign","target":{"duration":{"inject":"duration"},"ease":{"inject":"type","enter":"cubicBezier(.25,0,0,1)","exit":"cubicBezier(1,0,.75,1)"},"opacity":{"inject":"snippet","key":"opacity"},"clipPath":{"inject":"assign","target":{"ease":{"inject":"type","enter":"cubicBezier(1,0,.25,1)","exit":"cubicBezier(.75,0,0,1)"},"to":{"inject":"var.get","name":{"inject":"type","enter":"expanded","exit":"collapsed"}}},"source":{"inject":"isIntersected","true":{},"false":{"from":{"inject":"var.get","name":{"inject":"type","enter":"collapsed","exit":"expanded"}}}}}},"source":{"inject":"if","value":{"inject":"var.get","name":"isSwitchExit"},"then":{},"else":{"translate":{"inject":"vector","values":{"x":{"inject":"var.get","name":"translateParameters"}}}}}}}}},{"key":"wave","name":"Wave","modules":["servers","channels","settings"],"settings":{"duration":true,"defaults":{"duration":1000}},"enter":{"anime":{"type":"timer","parameters":{"duration":{"inject":"duration"}}}},"exit":{"hast":{"type":"element","tagName":"svg","properties":{"className":"overlay","width":"100%","height":"100%","viewBox":"0 0 100 100","preserveAspectRatio":"none"},"children":[{"type":"element","tagName":"path","properties":{"className":"overlay__path","vectorEffect":"non-scaling-stroke","d":"M 0 0 h 0 c 0 50 0 50 0 100 H 0 V 0 Z","fill":"var(--background-base-lowest)"}}]},"css":{".overlay":{"inset":0,"z-index":5}},"anime":{"type":"timeline","children":[{"targets":".overlay__path","parameters":{"duration":{"a":0.3720930233,"inject":"*","b":{"inject":"duration"}},"ease":"inQuart","d":["M 0 0 h 0 c 0 50 0 50 0 100 H 0 V 0 Z","M 0 0 h 43 c -60 55 140 65 0 100 H 0 V 0 Z"]}},{"targets":".overlay__path","parameters":{"duration":{"a":0.0930232558,"inject":"*","b":{"inject":"duration"}},"ease":"outSine","d":"M 0 0 h 100 c 0 50 0 50 0 100 H 0 V 0 Z"}},{"type":"set","targets":{"inject":"element"},"parameters":{"opacity":0}},{"targets":".overlay__path","parameters":{"duration":{"a":0.0697674419,"inject":"*","b":{"inject":"duration"}},"ease":"inSine","d":["M 100 0 H 0 c 0 50 0 50 0 100 h 100 V 50 Z","M 100 0 H 50 c 28 43 4 81 0 100 h 50 V 0 Z"]}},{"targets":".overlay__path","parameters":{"duration":{"a":0.4651162791,"inject":"*","b":{"inject":"duration"}},"ease":"outExpo","d":"M 100 0 H 100 c 0 50 0 50 0 100 h 0 V 0 Z"}}]}}},{"key":"backdropSolid","name":"Solid","modules":"modalsBackdrop","meta":{"revert":false},"settings":{"duration":true,"easing":true,"variant":[{"key":"dark","name":"Dark"},{"key":"light","name":"Light"}],"defaults":{"duration":200,"easing":{"type":"ease","style":"quart"},"variant":"dark"}},"animate":{"onBeforeCreate":[{"inject":"var.set","name":"hidden","value":{"inject":"variant","dark":"rgba(0, 0, 0, 0)","light":"rgba(255, 255, 255, 0)"}},{"inject":"var.set","name":"visible","value":{"inject":"variant","dark":"rgba(0, 0, 0, .7)","light":"rgba(255, 255, 255, .7)"}}],"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"background":{"inject":"type","enter":{"inject":"isIntersected","true":{"inject":"var.get","name":"visible"},"false":[{"inject":"var.get","name":"hidden"},{"inject":"var.get","name":"visible"}]},"exit":{"inject":"var.get","name":"hidden"}}}}}},{"key":"backdropBlur","name":"Blur","modules":"modalsBackdrop","meta":{"revert":false},"settings":{"duration":true,"easing":true,"variant":[{"key":"dark","name":"Dark"},{"key":"light","name":"Light"}],"defaults":{"duration":200,"easing":{"type":"ease","style":"quart"},"variant":"dark"}},"animate":{"extends":{"inject":"load","animation":"backdropSolid"},"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"backdropFilter":{"inject":"type","enter":{"inject":"isIntersected","true":"blur(2px)","false":["blur(0px)","blur(2px)"]},"exit":"blur(0px)"}}}}},{"key":"backdropGrayscale","name":"Grayscale","modules":"modalsBackdrop","meta":{"revert":false},"settings":{"duration":true,"easing":true,"variant":[{"key":"dark","name":"Dark"},{"key":"light","name":"Light"}],"defaults":{"duration":200,"easing":{"type":"ease","style":"quart"},"variant":"dark"}},"animate":{"extends":{"inject":"load","animation":"backdropSolid"},"anime":{"type":"waapi","targets":{"inject":"element"},"parameters":{"duration":{"inject":"duration"},"ease":{"inject":"easing"},"backdropFilter":{"inject":"type","enter":{"inject":"isIntersected","true":"grayscale(1)","false":["grayscale(0)","grayscale(1)"]},"exit":"grayscale(0)"}}}}}]');
  const preinstalled = {
    name,
    version,
    snippets,
    animations
  };
  const semver = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
  const url = /^((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[.\!\/\\w]*))?)$/i;
  const regex = {
    semver,
    url
  };
  const AnimatePropertySchema = ArrayOrSingleSchema(
    ArrayOrSingleSchema(
      recordType(anyType()).nullable()
    )
  );
  const AnimateSchema = SourceMappedObjectSchema.extend({
    onBeforeLayout: AnimatePropertySchema,
    hast: AnimatePropertySchema,
    css: AnimatePropertySchema,
    onBeforeCreate: AnimatePropertySchema,
    anime: AnimatePropertySchema,
    onCreated: AnimatePropertySchema,
    onBeforeBegin: AnimatePropertySchema,
    onCompleted: AnimatePropertySchema,
    onBeforeDestroy: AnimatePropertySchema,
    onDestroyed: AnimatePropertySchema
  }).partial().strict();
  const ExtendableAnimateSchema = AnimateSchema.extend({
    onBeforeExtend: AnimatePropertySchema,
    extends: AnimatePropertySchema
  }).partial().strict();
  const PrepareInjectableSchema = lazyType(
    () => anyType().transform(
      (value, ctx) => deepMap(value, (value2, { path: path2 }) => {
        if (typeof value2 !== "object" || value2 === null) return value2;
        if (forbiddenKeys.map((key2) => {
          if (!Object.hasOwn(value2, key2)) return false;
          ctx.addIssue({
            code: ZodIssueCode.custom,
            message: `Forbidden key: '${key2}'`,
            path: path2.concat(key2),
            params: { pointAt: "key" }
          });
          return true;
        }).some(Boolean)) return NEVER;
        return storeSourceMap(value2, ctx.path.concat(path2));
      })
    )
  );
  const AnimationSchema = objectType({
    key: stringType().min(1),
    name: stringType().min(1).trim(),
    modules: ArrayOrSingleSchema(
      enumType(ModuleKey.values().concat(ModuleKeyAlias.values()))
    ).optional().default(() => [ModuleKeyAlias.Switch, ModuleKeyAlias.Reveal, ModuleKeyAlias.Sidebars]).transform((value) => new Set([].concat(value).flatMap((key2) => moduleAliases[key2] ?? key2))),
    meta: MetaSchema.optional().default({}),
    settings: SettingsSchema.optional().default({ defaults: {} }),
    debug: unionType([
      booleanType(),
      enumType(AnimationType.values())
    ]).optional(),
    animate: ExtendableAnimateSchema.pipe(PrepareInjectableSchema).optional(),
    enter: ExtendableAnimateSchema.pipe(PrepareInjectableSchema).optional(),
    exit: ExtendableAnimateSchema.pipe(PrepareInjectableSchema).optional()
  }).strict().refine(
    (v) => v.animate ? !(v.enter || v.exit) : v.enter && v.exit,
    (v) => ({
      message: `Execution definition is required and must be either inside a single 'animate' property or inside 'enter' and 'exit' properties`,
      path: [].concat(Object.keys(v).find((k) => ["enter", "exit", "animate"].includes(k)) ?? []),
      params: { pointAt: "key" }
    })
  );
  const Messages = {
    SELECT_ANIMATION_TO_ENABLE: "Select animation to enable",
    IMPLEMENTED_BY_ANIMATION: (animationName) => `Implemented by selected animation: ${animationName}`,
    SHOULD_BE_VALID_URL: "Should be a valid URL",
    PRIORITIZE_ANIMATION_SMOOTHNESS: "Prioritize Animation Smoothness",
    CACHE_USER_SETTINGS_SECTIONS: "Cache User Settings Sections",
    CATALOG_OUT_OF_DATE: "The last attempt to load the Catalog was unsuccessful. The information below may be out of date.",
    SETTINGS_MIGRATOR: "Settings Migrator"
  };
  const SnippetSchema = strictObjectType({
    key: stringType().min(1),
    params: recordType(stringType(), anyType()).optional(),
    value: PrepareInjectableSchema
  });
  const BasePackSchemaShape = {
    name: stringType().trim().min(1),
    author: stringType().trim().min(1),
    version: stringType().regex(regex.semver, "Should match semver format"),
    description: stringType().min(1).optional(),
    changelog: recordType(stringType(), anyType()).optional(),
    invite: stringType().optional(),
    authorLink: stringType().regex(regex.url, Messages.SHOULD_BE_VALID_URL).optional(),
    donate: stringType().regex(regex.url, Messages.SHOULD_BE_VALID_URL).optional()
  };
  const PackSchema = objectType({
    ...BasePackSchemaShape,
    snippets: SnippetSchema.array().optional(),
    animations: AnimationSchema.array().superRefine((animations2, ctx) => {
      const keys2 = {};
      animations2.forEach((a, i) => (keys2[a.key] ??= []).push(i));
      Object.entries(keys2).filter(([, indexes]) => indexes.length > 1).forEach(([key2, indexes]) => {
        if (indexes.length <= 1) return;
        indexes.forEach((i) => ctx.addIssue({
          code: ZodIssueCode.custom,
          message: `Duplicate animation key: '${key2}'`,
          path: [i, "key"]
        }));
      });
    })
  });
  const PackFallbackSchema = ({
    name: name2 = "Invalid name",
    author: author2 = "Unknown",
    version: version2 = "0.0.0",
    ...rest
  }) => {
    const fallbackValues = {
      name: name2,
      author: author2,
      version: version2,
      ...rest
    };
    return objectType(
      Object.fromEntries(
        Object.entries(BasePackSchemaShape).map(([key2, schema]) => [
          key2,
          schema.catch(fallbackValues[key2])
        ])
      )
    );
  };
  const PREINSTALLED_PACK_SLUG = "preinstalled";
  function createInternalPack(slug2, data2) {
    return Object.assign(
      { slug: slug2, id: slug2 },
      PackSchema.parse(data2)
    );
  }
  const internalPacks = {
    [PREINSTALLED_PACK_SLUG]: createInternalPack(PREINSTALLED_PACK_SLUG, {
      author: config.author,
      invite: config.invite,
      ...preinstalled
    })
  };
  const internalPackSlugs = Object.keys(internalPacks);
  let Module$1 = class Module {
    constructor({
      id,
      name: name2,
      parent = null,
      meta: meta2 = {},
      description,
      controls,
      alert,
      onToggle
    }) {
      this.id = id;
      this.name = name2;
      this.description = description ?? "No description provided.";
      this.controls = controls;
      this._alert = alert;
      this._onToggle = onToggle;
      this.meta = meta2;
      this.parent = parent;
      this.animations = {};
    }
    get settings() {
      return {};
    }
    getPack(slug2) {
      return internalPacks[slug2];
    }
    getAnimationConfig(pack, animation, type) {
      return {};
    }
    onToggle(value) {
      this._onToggle?.(value);
    }
    onSettingsChange() {
    }
    isEnabled(type = null) {
      if (!type) return this.settings.enabled ?? true;
      return (this.settings.enabled ?? true) && (!!this.animations[type]?.animate || !!this.getAccordion(type)?.enabled);
    }
    setIsEnabled(value) {
      this.settings.enabled = value;
      this.onToggle(value);
    }
    enable() {
      this.setIsEnabled(true);
    }
    disable() {
      this.setIsEnabled(false);
    }
    toggle() {
      this.setIsEnabled(!this.isEnabled());
    }
    get type() {
      return this.meta.type ?? ModuleType.Reveal;
    }
    get interceptEvents() {
      return this.meta.interceptEvents ?? true;
    }
    get alert() {
      if (typeof this._alert === "function") return this._alert(this.name);
      return this._alert;
    }
    findAnimation(packOrSlug, key2) {
      const animation = (typeof packOrSlug === "string" ? this.getPack(packOrSlug) : packOrSlug)?.animations.find((a) => a.key === key2);
      return animation && this.isSupportedBy(animation) ? animation : null;
    }
    getAnimationSettings(pack, animation, type, options = {}) {
      return this.buildSettings(animation, type, this.getAnimationConfig(pack, animation, type), options);
    }
    initializeAnimation(pack, animation, type) {
      if (typeof pack === "string") {
        type = pack;
        const pointer = this.settings[type] ?? {};
        pack = pointer.packSlug && this.getPack(pointer.packSlug);
        animation = pack && this.findAnimation(pack, pointer.animationKey);
      }
      const config2 = animation ? this.getAnimationConfig(pack, animation, type) : {};
      const path2 = animation ? ["animations", pack.animations.indexOf(animation), type in animation ? type : "animate"] : [];
      const settings = animation && this.buildSettings(animation, type, config2, { auto: false });
      const meta2 = animation && this.buildAnimationMeta(animation, type);
      const context = animation && buildContext(pack, animation, type, settings, meta2, { module: this, path: path2 });
      const debug = Debug.animation(animation, type);
      const data2 = animation?.[type] ?? animation?.animate;
      let animate2, error2;
      if (animation) {
        const groupEnd = debug.initializeStart(data2, context);
        try {
          animate2 = ParsableExtendableAnimateSchema(context, { stage: ParseStage.Initialize }).parse(data2, { path: path2 });
          debug.initializeEnd(animate2, context);
        } catch (err) {
          error2 = err instanceof AnimationError ? err : new AnimationError(
            animation,
            formatZodError(err, { pack, data: data2, context, received: false, docs: Documentation.getDefinitionUrl(Documentation.Definition.Animate) }),
            { module: this, pack, type, context }
          );
        } finally {
          groupEnd?.();
        }
      }
      return {
        packSlug: pack?.slug ?? null,
        animationKey: animation?.key ?? null,
        id: [pack?.slug, animation?.key].filter(Boolean).join("/") || null,
        pack: animation && pack,
        animation,
        path: path2,
        meta: meta2,
        config: config2,
        animate: animate2,
        error: error2
      };
    }
    initializeAnimations(pack, animation) {
      if (pack && animation)
        return {
          enter: this.initializeAnimation(pack, animation, AnimationType.Enter),
          exit: this.initializeAnimation(pack, animation, AnimationType.Exit)
        };
      this.animations = {
        enter: this.initializeAnimation(AnimationType.Enter),
        exit: this.initializeAnimation(AnimationType.Exit)
      };
      Object.values(this.animations).forEach(({ error: error2 }) => error2 && ErrorManager.registerAnimationError(error2));
      return this;
    }
    getAnimation(data2, type, options, context) {
      if (typeof data2 === "string") {
        [type, options, context] = arguments;
        data2 = this.animations[type];
      }
      const { pack, animation, path: path2, meta: meta2, config: config2 } = data2;
      const settings = animation && this.buildSettings(animation, type, config2, options);
      const ctx = buildContext(pack, animation, type, settings, meta2, { module: this, path: path2, ...context });
      return {
        ...data2,
        settings,
        context: ctx
      };
    }
    getAnimations(options = {}) {
      return {
        enter: this.getAnimation(AnimationType.Enter, options),
        exit: this.getAnimation(AnimationType.Exit, options)
      };
    }
    setAnimation(type, packSlug, animationKey) {
      this.settings[type] = { packSlug, animationKey };
      this.onSettingsChange();
    }
    isSupportedBy(animation) {
      return animation.modules.has(this.id);
    }
    getSupportsAuto(setting) {
      const [type, options] = [].concat(this.meta.settings?.supportsAuto?.[setting]);
      return {
        type,
        options: {
          asDefault: true,
          ...options
        }
      };
    }
    supportsAuto(animation, setting, autoType = null) {
      if (!animation.settings?.[setting]) return false;
      const { type } = this.getSupportsAuto(setting);
      if (autoType === null ? !type : type !== autoType) return false;
      if (animation.settings[setting] === true) return true;
      switch (setting) {
        case AnimationSetting.Position:
          if (type === PositionAutoType.Precise) return false;
          return [
            Position.Top,
            Position.Bottom,
            Position.Left,
            Position.Right
          ].every((v) => animation.settings[setting].includes(v));
        case AnimationSetting.Direction:
          switch (type) {
            case DirectionAutoType.Alternate:
              return getSupportedAxes(animation.settings[setting]).length > 0;
            case DirectionAutoType.Anchor:
              return [
                Direction.Upwards,
                Direction.Downwards,
                Direction.Leftwards,
                Direction.Rightwards
              ].every((v) => animation.settings[setting]?.includes(v));
          }
        default:
          return false;
      }
    }
    getAllSettingsSupportingAuto(animation, defaultOnly = false) {
      return [
        AnimationSetting.Position,
        AnimationSetting.Direction
      ].filter(
        (s) => this.supportsAuto(animation, s) && (!defaultOnly || this.getSupportsAuto(s).options.asDefault)
      );
    }
    getOverridableConditionValues(type) {
      return {
        type,
        module: this.id,
        "module.type": this.type
      };
    }
    buildAnimationMeta(animation, type) {
      return computeOverridable(
        animation.meta,
        this.getOverridableConditionValues(type),
        metaOverridePresets
      );
    }
    buildAnimationDefaultSettings(animation, type) {
      return computeOverridable(
        animation.settings.defaults,
        this.getOverridableConditionValues(type)
      );
    }
    buildModuleDefaultSettings(animation) {
      return Object.fromEntries(
        Object.entries(this.meta.settings?.defaults ?? {}).filter(([key2]) => {
          if (key2 === AnimationSetting.Overflow) return true;
          if ([AnimationSetting.DirectionAxis, AnimationSetting.DirectionReverse, AnimationSetting.DirectionTowards].includes(key2))
            key2 = AnimationSetting.Direction;
          return key2 in (animation.settings ?? {});
        })
      );
    }
    buildDefaultSettings(animation, type, normalized = true) {
      const settings = Object.assign(
        { [AnimationSetting.Overflow]: true },
        this.buildModuleDefaultSettings(animation),
        this.buildAnimationDefaultSettings(animation, type),
        Object.fromEntries(
          this.getAllSettingsSupportingAuto(animation, true).map((s) => [s, Auto()])
        )
      );
      return normalized ? this.normalizeSettings(animation, type, settings) : settings;
    }
    buildSettings(animation, type, config2, options = {}) {
      const settings = animation ? this.normalizeSettings(
        animation,
        type,
        Object.assign(
          this.buildDefaultSettings(animation, type, false),
          config2
        )
      ) : {};
      if ("auto" in options) this.assignAutoValues(animation, type, settings, options.auto);
      return settings;
    }
    normalizeSetting(animation, type, setting, value, allSettings, animationDefaults) {
      switch (setting) {
        case AnimationSetting.PositionPreserve: {
          if (allSettings[AnimationSetting.Position] !== Auto() || !this.supportsAuto(animation, AnimationSetting.Position, PositionAutoType.Precise) || !this.getSupportsAuto(AnimationSetting.Position).options.preservable)
            return void 0;
          return Boolean(value);
        }
        case AnimationSetting.DirectionAxis: {
          if (allSettings[AnimationSetting.Direction] !== Auto() || !this.supportsAuto(animation, AnimationSetting.Direction, DirectionAutoType.Alternate))
            return void 0;
          const directions2 = animation.settings[AnimationSetting.Direction] ?? [];
          if (getDirectionsByAxis(value)?.every((d) => directions2.includes(d))) return value;
          return animationDefaults[setting] ?? [Axis.Y, Axis.Z, Axis.X].find((axis) => getDirectionsByAxis(axis).every((d) => directions2.includes(d)));
        }
        case AnimationSetting.DirectionReverse: {
          if (allSettings[AnimationSetting.Direction] !== Auto() || !this.supportsAuto(animation, AnimationSetting.Direction, DirectionAutoType.Alternate))
            return void 0;
          return Boolean(value);
        }
        case AnimationSetting.DirectionTowards: {
          if (allSettings[AnimationSetting.Direction] !== Auto() || !this.supportsAuto(animation, AnimationSetting.Direction, DirectionAutoType.Anchor))
            return void 0;
          return Boolean(value);
        }
        case AnimationSetting.Overflow: {
          if (animation.settings?.[setting] === false)
            return animationDefaults[setting];
          return Boolean(value);
        }
      }
      if (animation.settings?.[setting] === void 0) return void 0;
      switch (setting) {
        case AnimationSetting.Duration: {
          const { from, to } = animation.settings[setting];
          return Math.max(from, Math.min(to, typeof value === "number" ? value : animationDefaults[setting]));
        }
        case AnimationSetting.Variant: {
          const keys2 = animation.settings[setting].map((v) => v.key);
          if (!keys2.includes(value)) return animationDefaults[setting] ?? keys2[0];
          return value;
        }
        case AnimationSetting.Position: {
          if (value === Auto() && this.supportsAuto(animation, setting)) return value;
          const values = animation.settings[setting] === true ? Position.values() : animation.settings[setting];
          if (!values.includes(value)) return animationDefaults[setting] ?? values[0];
          return value;
        }
        case AnimationSetting.Direction: {
          if (value === Auto() && this.supportsAuto(animation, setting)) return value;
          const values = animation.settings[setting];
          if (!values.includes(value)) return animationDefaults[setting] ?? values[0];
          return value;
        }
        case AnimationSetting.Easing: {
          return EasingSchema.catch(animationDefaults[setting]).parse(value);
        }
        default:
          return void 0;
      }
    }
    normalizeSettings(animation, type, settings) {
      const animationDefaults = this.buildAnimationDefaultSettings(animation, type);
      return Object.fromEntries(
        AnimationSetting.values().map((key2) => [key2, this.normalizeSetting(animation, type, key2, settings[key2], settings, animationDefaults)]).filter((a) => a[1] !== void 0)
      );
    }
    assignAutoValues(animation, type, normalizedSettings, values = {}) {
      const settings = normalizedSettings;
      const animationDefaults = this.buildAnimationDefaultSettings(animation, type);
      if (values === false) {
        Object.keys(settings).forEach((key2) => settings[key2] === Auto() && delete settings[key2]);
        return settings;
      }
      if (settings[AnimationSetting.Position] === Auto()) {
        if (!values.position)
          settings[AnimationSetting.Position] = { isAuto: true, mouse: settings[AnimationSetting.PositionPreserve] ? values.preservedMouse : values.mouse };
        else {
          const position2 = reversePosition(values.position);
          const mergedPosition = getPosition(position2, values.align);
          const supportedPositions = animation.settings[AnimationSetting.Position];
          const value = Array.isArray(supportedPositions) && !supportedPositions.includes(mergedPosition) ? position2 : mergedPosition;
          settings[AnimationSetting.Position] = { isAuto: true, value };
        }
      }
      if (settings[AnimationSetting.Direction] === Auto())
        switch (this.getSupportsAuto(AnimationSetting.Direction).type) {
          case DirectionAutoType.Alternate: {
            const direction = getDirection(settings[AnimationSetting.DirectionAxis], values.direction);
            settings[AnimationSetting.Direction] = settings[AnimationSetting.DirectionReverse] ? reverseDirection(direction) : direction;
            break;
          }
          case DirectionAutoType.Anchor: {
            settings[AnimationSetting.Direction] = values.position ? getAnchorDirection(values.position, settings[AnimationSetting.DirectionTowards]) : animationDefaults[AnimationSetting.Direction];
            break;
          }
        }
      return settings;
    }
    getAccordionAnimation() {
      const { accordion } = this.meta;
      if (!accordion) return null;
      return {
        name: "Smooth Expand/Collapse",
        settings: {
          [AnimationSetting.Overflow]: false,
          [AnimationSetting.Duration]: { from: 100, to: 2e3 },
          [AnimationSetting.Easing]: true,
          defaults: accordion.defaults
        }
      };
    }
    getAccordion(data2, type, options) {
      if (typeof data2 === "string") {
        [type, options] = arguments;
        data2 = this.animations[type];
      }
      options ??= {};
      const { accordion } = this.meta;
      if (!accordion) return null;
      const forceDisabled = data2?.meta?.accordion === false;
      const animation = this.getAccordionAnimation();
      const config2 = this.settings.accordion?.[type] ?? {};
      const defaults2 = () => this.buildDefaultSettings(animation, type);
      const settings = this.buildSettings(animation, type, config2.settings, options);
      const context = buildContext(null, animation, type, settings);
      return {
        animate: accordion.create(type, context),
        forceDisabled,
        enabled: !forceDisabled && (config2.enabled ?? true),
        setEnabled: forceDisabled ? null : (enabled) => this.updateAccordion(type, { enabled }),
        settings,
        setSettings: (settings2) => this.updateAccordion(type, { settings: settings2 }),
        defaults: defaults2,
        context,
        onReset: () => this.updateAccordion(type, { settings: defaults2() })
      };
    }
    getAccordions(options = {}) {
      const animation = this.getAccordionAnimation();
      if (!animation) return null;
      return {
        animation,
        enter: this.getAccordion(AnimationType.Enter, options),
        exit: this.getAccordion(AnimationType.Exit, options)
      };
    }
    updateAccordion(type, values) {
      const config2 = this.settings.accordion ??= {};
      Object.assign(config2[type] ??= {}, values);
      this.onSettingsChange();
    }
    buildOptions(data2, type, options) {
      if (typeof data2 === "string") {
        [type, options] = arguments;
        data2 = this.animations[type];
      }
      const accordion = this.getAccordion(data2, type, options);
      if (!accordion?.enabled) return {};
      const key2 = {
        [AnimationType.Enter]: "before",
        [AnimationType.Exit]: "after"
      }[type];
      return { [key2]: accordion.animate };
    }
  };
  const ToastTypes = IconBrandTypes;
  function Toast({ children: children2, text: text2, type = ToastTypes.INFO }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: DiscordClasses.Toast.toast }, /* @__PURE__ */ BdApi.React.createElement(
      IconBrand,
      {
        type,
        className: classNames({
          [DiscordClasses.Toast.icon]: true,
          "BA__toastIcon": true,
          "BA__toastIconDefault": type === ToastTypes.DEFAULT
        })
      }
    ), text2 && /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        color: "header-primary",
        variant: "text-md/normal"
      },
      text2
    ), children2);
  }
  css`.BA__toastIcon {
    width: 32px !important;
    height: 32px !important;
    margin-right: 12px;
}

.BA__toastIconDefault {
    margin-right: 4px;
}``Toast`;
  class Toasts {
    static get Types() {
      return ToastTypes;
    }
    static success(content, options = {}) {
      return this.show(content, Object.assign(options, { type: Toasts.Types.SUCCESS }));
    }
    static info(content, options = {}) {
      return this.show(content, Object.assign(options, { type: Toasts.Types.INFO }));
    }
    static warning(content, options = {}) {
      return this.show(content, Object.assign(options, { type: Toasts.Types.WARNING }));
    }
    static error(content, options = {}) {
      return this.show(content, Object.assign(options, { type: Toasts.Types.ERROR }));
    }
    static default(content, options = {}) {
      return this.show(content, Object.assign(options, { type: Toasts.Types.DEFAULT }));
    }
    static show(content, options = {}) {
      const { type = Toasts.Types.DEFAULT, ...rest } = options;
      showToast(
        createToast(null, null, {
          component: /* @__PURE__ */ BdApi.React.createElement(Toast, { type, text: content }),
          ...rest
        })
      );
    }
  }
  var jsonSourceMap = {};
  var hasRequiredJsonSourceMap;
  function requireJsonSourceMap() {
    if (hasRequiredJsonSourceMap) return jsonSourceMap;
    hasRequiredJsonSourceMap = 1;
    var escapedChars = {
      "b": "\b",
      "f": "\f",
      "n": "\n",
      "r": "\r",
      "t": "	",
      '"': '"',
      "/": "/",
      "\\": "\\"
    };
    var A_CODE = "a".charCodeAt();
    jsonSourceMap.parse = function(source, _, options) {
      var pointers = {};
      var line = 0;
      var column = 0;
      var pos = 0;
      var bigint = options && options.bigint && typeof BigInt != "undefined";
      return {
        data: _parse("", true),
        pointers
      };
      function _parse(ptr, topLevel) {
        whitespace();
        var data2;
        map(ptr, "value");
        var char = getChar();
        switch (char) {
          case "t":
            read("rue");
            data2 = true;
            break;
          case "f":
            read("alse");
            data2 = false;
            break;
          case "n":
            read("ull");
            data2 = null;
            break;
          case '"':
            data2 = parseString();
            break;
          case "[":
            data2 = parseArray(ptr);
            break;
          case "{":
            data2 = parseObject(ptr);
            break;
          default:
            backChar();
            if ("-0123456789".indexOf(char) >= 0)
              data2 = parseNumber2();
            else
              unexpectedToken();
        }
        map(ptr, "valueEnd");
        whitespace();
        if (topLevel && pos < source.length) unexpectedToken();
        return data2;
      }
      function whitespace() {
        loop:
          while (pos < source.length) {
            switch (source[pos]) {
              case " ":
                column++;
                break;
              case "	":
                column += 4;
                break;
              case "\r":
                column = 0;
                break;
              case "\n":
                column = 0;
                line++;
                break;
              default:
                break loop;
            }
            pos++;
          }
      }
      function parseString() {
        var str = "";
        var char;
        while (true) {
          char = getChar();
          if (char == '"') {
            break;
          } else if (char == "\\") {
            char = getChar();
            if (char in escapedChars)
              str += escapedChars[char];
            else if (char == "u")
              str += getCharCode();
            else
              wasUnexpectedToken();
          } else {
            str += char;
          }
        }
        return str;
      }
      function parseNumber2() {
        var numStr = "";
        var integer = true;
        if (source[pos] == "-") numStr += getChar();
        numStr += source[pos] == "0" ? getChar() : getDigits();
        if (source[pos] == ".") {
          numStr += getChar() + getDigits();
          integer = false;
        }
        if (source[pos] == "e" || source[pos] == "E") {
          numStr += getChar();
          if (source[pos] == "+" || source[pos] == "-") numStr += getChar();
          numStr += getDigits();
          integer = false;
        }
        var result = +numStr;
        return bigint && integer && (result > Number.MAX_SAFE_INTEGER || result < Number.MIN_SAFE_INTEGER) ? BigInt(numStr) : result;
      }
      function parseArray(ptr) {
        whitespace();
        var arr = [];
        var i = 0;
        if (getChar() == "]") return arr;
        backChar();
        while (true) {
          var itemPtr = ptr + "/" + i;
          arr.push(_parse(itemPtr));
          whitespace();
          var char = getChar();
          if (char == "]") break;
          if (char != ",") wasUnexpectedToken();
          whitespace();
          i++;
        }
        return arr;
      }
      function parseObject(ptr) {
        whitespace();
        var obj = {};
        if (getChar() == "}") return obj;
        backChar();
        while (true) {
          var loc = getLoc();
          if (getChar() != '"') wasUnexpectedToken();
          var key2 = parseString();
          var propPtr = ptr + "/" + escapeJsonPointer(key2);
          mapLoc(propPtr, "key", loc);
          map(propPtr, "keyEnd");
          whitespace();
          if (getChar() != ":") wasUnexpectedToken();
          whitespace();
          obj[key2] = _parse(propPtr);
          whitespace();
          var char = getChar();
          if (char == "}") break;
          if (char != ",") wasUnexpectedToken();
          whitespace();
        }
        return obj;
      }
      function read(str) {
        for (var i = 0; i < str.length; i++)
          if (getChar() !== str[i]) wasUnexpectedToken();
      }
      function getChar() {
        checkUnexpectedEnd();
        var char = source[pos];
        pos++;
        column++;
        return char;
      }
      function backChar() {
        pos--;
        column--;
      }
      function getCharCode() {
        var count = 4;
        var code = 0;
        while (count--) {
          code <<= 4;
          var char = getChar().toLowerCase();
          if (char >= "a" && char <= "f")
            code += char.charCodeAt() - A_CODE + 10;
          else if (char >= "0" && char <= "9")
            code += +char;
          else
            wasUnexpectedToken();
        }
        return String.fromCharCode(code);
      }
      function getDigits() {
        var digits = "";
        while (source[pos] >= "0" && source[pos] <= "9")
          digits += getChar();
        if (digits.length) return digits;
        checkUnexpectedEnd();
        unexpectedToken();
      }
      function map(ptr, prop) {
        mapLoc(ptr, prop, getLoc());
      }
      function mapLoc(ptr, prop, loc) {
        pointers[ptr] = pointers[ptr] || {};
        pointers[ptr][prop] = loc;
      }
      function getLoc() {
        return {
          line,
          column,
          pos
        };
      }
      function unexpectedToken() {
        throw new SyntaxError("Unexpected token " + source[pos] + " in JSON at position " + pos);
      }
      function wasUnexpectedToken() {
        backChar();
        unexpectedToken();
      }
      function checkUnexpectedEnd() {
        if (pos >= source.length)
          throw new SyntaxError("Unexpected end of JSON input");
      }
    };
    jsonSourceMap.stringify = function(data2, _, options) {
      if (!validType(data2)) return;
      var wsLine = 0;
      var wsPos, wsColumn;
      var whitespace = typeof options == "object" ? options.space : options;
      switch (typeof whitespace) {
        case "number":
          var len = whitespace > 10 ? 10 : whitespace < 0 ? 0 : Math.floor(whitespace);
          whitespace = len && repeat(len, " ");
          wsPos = len;
          wsColumn = len;
          break;
        case "string":
          whitespace = whitespace.slice(0, 10);
          wsPos = 0;
          wsColumn = 0;
          for (var j = 0; j < whitespace.length; j++) {
            var char = whitespace[j];
            switch (char) {
              case " ":
                wsColumn++;
                break;
              case "	":
                wsColumn += 4;
                break;
              case "\r":
                wsColumn = 0;
                break;
              case "\n":
                wsColumn = 0;
                wsLine++;
                break;
              default:
                throw new Error("whitespace characters not allowed in JSON");
            }
            wsPos++;
          }
          break;
        default:
          whitespace = void 0;
      }
      var json = "";
      var pointers = {};
      var line = 0;
      var column = 0;
      var pos = 0;
      var es6 = options && options.es6 && typeof Map == "function";
      _stringify(data2, 0, "");
      return {
        json,
        pointers
      };
      function _stringify(_data, lvl, ptr) {
        map(ptr, "value");
        switch (typeof _data) {
          case "number":
          case "bigint":
          case "boolean":
            out("" + _data);
            break;
          case "string":
            out(quoted(_data));
            break;
          case "object":
            if (_data === null) {
              out("null");
            } else if (typeof _data.toJSON == "function") {
              out(quoted(_data.toJSON()));
            } else if (Array.isArray(_data)) {
              stringifyArray();
            } else if (es6) {
              if (_data.constructor.BYTES_PER_ELEMENT)
                stringifyArray();
              else if (_data instanceof Map)
                stringifyMapSet();
              else if (_data instanceof Set)
                stringifyMapSet(true);
              else
                stringifyObject();
            } else {
              stringifyObject();
            }
        }
        map(ptr, "valueEnd");
        function stringifyArray() {
          if (_data.length) {
            out("[");
            var itemLvl = lvl + 1;
            for (var i = 0; i < _data.length; i++) {
              if (i) out(",");
              indent2(itemLvl);
              var item = validType(_data[i]) ? _data[i] : null;
              var itemPtr = ptr + "/" + i;
              _stringify(item, itemLvl, itemPtr);
            }
            indent2(lvl);
            out("]");
          } else {
            out("[]");
          }
        }
        function stringifyObject() {
          var keys2 = Object.keys(_data);
          if (keys2.length) {
            out("{");
            var propLvl = lvl + 1;
            for (var i = 0; i < keys2.length; i++) {
              var key2 = keys2[i];
              var value = _data[key2];
              if (validType(value)) {
                if (i) out(",");
                var propPtr = ptr + "/" + escapeJsonPointer(key2);
                indent2(propLvl);
                map(propPtr, "key");
                out(quoted(key2));
                map(propPtr, "keyEnd");
                out(":");
                if (whitespace) out(" ");
                _stringify(value, propLvl, propPtr);
              }
            }
            indent2(lvl);
            out("}");
          } else {
            out("{}");
          }
        }
        function stringifyMapSet(isSet2) {
          if (_data.size) {
            out("{");
            var propLvl = lvl + 1;
            var first = true;
            var entries = _data.entries();
            var entry = entries.next();
            while (!entry.done) {
              var item = entry.value;
              var key2 = item[0];
              var value = isSet2 ? true : item[1];
              if (validType(value)) {
                if (!first) out(",");
                first = false;
                var propPtr = ptr + "/" + escapeJsonPointer(key2);
                indent2(propLvl);
                map(propPtr, "key");
                out(quoted(key2));
                map(propPtr, "keyEnd");
                out(":");
                if (whitespace) out(" ");
                _stringify(value, propLvl, propPtr);
              }
              entry = entries.next();
            }
            indent2(lvl);
            out("}");
          } else {
            out("{}");
          }
        }
      }
      function out(str) {
        column += str.length;
        pos += str.length;
        json += str;
      }
      function indent2(lvl) {
        if (whitespace) {
          json += "\n" + repeat(lvl, whitespace);
          line++;
          column = 0;
          while (lvl--) {
            if (wsLine) {
              line += wsLine;
              column = wsColumn;
            } else {
              column += wsColumn;
            }
            pos += wsPos;
          }
          pos += 1;
        }
      }
      function map(ptr, prop) {
        pointers[ptr] = pointers[ptr] || {};
        pointers[ptr][prop] = {
          line,
          column,
          pos
        };
      }
      function repeat(n, str) {
        return Array(n + 1).join(str);
      }
    };
    var VALID_TYPES = ["number", "bigint", "boolean", "string", "object"];
    function validType(data2) {
      return VALID_TYPES.indexOf(typeof data2) >= 0;
    }
    var ESC_QUOTE = /"|\\/g;
    var ESC_B = /[\b]/g;
    var ESC_F = /\f/g;
    var ESC_N = /\n/g;
    var ESC_R = /\r/g;
    var ESC_T = /\t/g;
    function quoted(str) {
      str = str.replace(ESC_QUOTE, "\\$&").replace(ESC_F, "\\f").replace(ESC_B, "\\b").replace(ESC_N, "\\n").replace(ESC_R, "\\r").replace(ESC_T, "\\t");
      return '"' + str + '"';
    }
    var ESC_0 = /~/g;
    var ESC_1 = /\//g;
    function escapeJsonPointer(str) {
      return str.replace(ESC_0, "~0").replace(ESC_1, "~1");
    }
    return jsonSourceMap;
  }
  var jsonSourceMapExports = requireJsonSourceMap();
  function VerifiedCheckIcon({ size, width, height, color = "var(--green-360)", secondaryColor = "var(--white-400)", ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...props,
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M9.592 3.2a6 6 0 0 1-.495.399c-.298.2-.633.338-.985.408c-.153.03-.313.043-.632.068c-.801.064-1.202.096-1.536.214a2.71 2.71 0 0 0-1.655 1.655c-.118.334-.15.735-.214 1.536a6 6 0 0 1-.068.632c-.07.352-.208.687-.408.985c-.087.13-.191.252-.399.495c-.521.612-.782.918-.935 1.238c-.353.74-.353 1.6 0 2.34c.153.32.414.626.935 1.238c.208.243.312.365.399.495c.2.298.338.633.408.985c.03.153.043.313.068.632c.064.801.096 1.202.214 1.536a2.71 2.71 0 0 0 1.655 1.655c.334.118.735.15 1.536.214c.319.025.479.038.632.068c.352.07.687.209.985.408c.13.087.252.191.495.399c.612.521.918.782 1.238.935c.74.353 1.6.353 2.34 0c.32-.153.626-.414 1.238-.935c.243-.208.365-.312.495-.399c.298-.2.633-.338.985-.408c.153-.03.313-.043.632-.068c.801-.064 1.202-.096 1.536-.214a2.71 2.71 0 0 0 1.655-1.655c.118-.334.15-.735.214-1.536c.025-.319.038-.479.068-.632c.07-.352.209-.687.408-.985c.087-.13.191-.252.399-.495c.521-.612.782-.918.935-1.238c.353-.74.353-1.6 0-2.34c-.153-.32-.414-.626-.935-1.238a6 6 0 0 1-.399-.495a2.7 2.7 0 0 1-.408-.985a6 6 0 0 1-.068-.632c-.064-.801-.096-1.202-.214-1.536a2.71 2.71 0 0 0-1.655-1.655c-.334-.118-.735-.15-1.536-.214a6 6 0 0 1-.632-.068a2.7 2.7 0 0 1-.985-.408a6 6 0 0 1-.495-.399c-.612-.521-.918-.782-1.238-.935a2.71 2.71 0 0 0-2.34 0c-.32.153-.626.414-1.238.935"
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof secondaryColor === "string" ? secondaryColor : secondaryColor.css,
          d: "M16.374 9.863a.814.814 0 0 0-1.151-1.151l-4.85 4.85l-1.595-1.595a.814.814 0 0 0-1.151 1.151l2.17 2.17a.814.814 0 0 0 1.15 0z"
        }
      )
    );
  }
  function DangerIcon({ size, width, height, color = colors.STATUS_DANGER, secondaryColor = "var(--white-400)", ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...props,
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "m16.157 3.802l.686.406c2.029 1.202 3.043 1.803 3.6 2.792c.557.99.557 2.19.557 4.594v.812c0 2.403 0 3.605-.557 4.594s-1.571 1.59-3.6 2.791l-.686.407C14.128 21.399 13.114 22 12 22s-2.128-.6-4.157-1.802l-.686-.407c-2.029-1.2-3.043-1.802-3.6-2.791C3 16.01 3 14.81 3 12.406v-.812C3 9.19 3 7.989 3.557 7s1.571-1.59 3.6-2.792l.686-.406C9.872 2.601 10.886 2 12 2s2.128.6 4.157 1.802"
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof secondaryColor === "string" ? secondaryColor : secondaryColor.css,
          d: "M12 6.25a.75.75 0 0 1 .75.75v6a.75.75 0 0 1-1.5 0V7a.75.75 0 0 1 .75-.75M12 17a1 1 0 1 0 0-2a1 1 0 0 0 0 2"
        }
      )
    );
  }
  function TrashIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M14.25 1c.41 0 .75.34.75.75V3h5.25c.41 0 .75.34.75.75v.5c0 .41-.34.75-.75.75H3.75A.75.75 0 0 1 3 4.25v-.5c0-.41.34-.75.75-.75H9V1.75c0-.41.34-.75.75-.75h4.5Z"
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M5.06 7a1 1 0 0 0-1 1.06l.76 12.13a3 3 0 0 0 3 2.81h8.36a3 3 0 0 0 3-2.81l.75-12.13a1 1 0 0 0-1-1.06H5.07ZM11 12a1 1 0 1 0-2 0v6a1 1 0 1 0 2 0v-6Zm3-1a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0v-6a1 1 0 0 1 1-1Z",
          clipRule: "evenodd"
        }
      )
    );
  }
  function DownloadIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M12 2a1 1 0 0 1 1 1v10.59l3.3-3.3a1 1 0 1 1 1.4 1.42l-5 5a1 1 0 0 1-1.4 0l-5-5a1 1 0 1 1 1.4-1.42l3.3 3.3V3a1 1 0 0 1 1-1ZM3 20a1 1 0 1 0 0 2h18a1 1 0 1 0 0-2H3Z"
        }
      )
    );
  }
  const VerificationStatus = {
    UNKNOWN: 0,
    UNVERIFIED: 1,
    FAILED: 2,
    VERIFIED: 3,
    OFFICIAL: 4
  };
  const VerificationIssueResolveMethod = {
    DELETE: "delete",
    UNINSTALL: "uninstall",
    REINSTALL: "reinstall",
    UPDATE: "update",
    ALLOW_ONCE: "allowOnce",
    ALLOW_ALWAYS: "allowAlways"
  };
  const verificationStatuses = Object.fromEntries(
    [
      {
        value: VerificationStatus.UNKNOWN,
        icon: (props) => /* @__PURE__ */ BdApi.React.createElement(
          VerifiedCheckIcon,
          {
            ...props,
            color: colors.ICON_MUTED,
            secondaryColor: colors.ICON_MUTED
          }
        ),
        tooltipColor: Tooltip$1.Colors.PRIMARY,
        label: "Unable to verify",
        description: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, config.name, " was unable to verify this pack. It may contain malicious code, use it at your own risk.")
      },
      {
        value: VerificationStatus.UNVERIFIED,
        icon: (props) => /* @__PURE__ */ BdApi.React.createElement(DangerIcon, { ...props }),
        tooltipColor: Tooltip$1.Colors.RED,
        label: "Unverified",
        description: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "This pack has not been verified and may contain malicious code. ", config.name, " strongly recommends deleting it.")
      },
      {
        value: VerificationStatus.FAILED,
        icon: (props) => /* @__PURE__ */ BdApi.React.createElement(DangerIcon, { ...props }),
        tooltipColor: Tooltip$1.Colors.RED,
        label: "Verification failed",
        description: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "This pack has been verified, but the local copy you have installed differs from the one published in the official Catalog. The contents of this pack may have been modified by malicious code from a third party. ", config.name, " strongly recommends reinstalling it from the official Catalog before using it.")
      },
      {
        value: VerificationStatus.VERIFIED,
        icon: (props) => /* @__PURE__ */ BdApi.React.createElement(
          VerifiedCheckIcon,
          {
            ...props,
            color: "var(--green-360)"
          }
        ),
        tooltipColor: Tooltip$1.Colors.GREEN,
        label: "Verified",
        description: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "This community pack has been verified by ", config.name, " and is safe to use.")
      },
      {
        value: VerificationStatus.OFFICIAL,
        icon: (props) => /* @__PURE__ */ BdApi.React.createElement(
          VerifiedCheckIcon,
          {
            ...props,
            color: "var(--brand-500)"
          }
        ),
        tooltipColor: Tooltip$1.Colors.BRAND,
        label: "Official",
        description: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "This is the official pack from the authors of ", config.name, ".")
      }
    ].map((item) => [item.value, item])
  );
  const verificationIssueResolveMethods = Object.fromEntries(
    [
      {
        value: VerificationIssueResolveMethod.DELETE,
        variant: "critical-primary",
        icon: TrashIcon,
        label: (past) => `${past ? "Deleted" : "Delete"} permanently`
      },
      {
        value: VerificationIssueResolveMethod.UNINSTALL,
        variant: "critical-primary",
        icon: TrashIcon,
        label: (past) => past ? "Uninstalled" : "Uninstall"
      },
      {
        value: VerificationIssueResolveMethod.REINSTALL,
        variant: "primary",
        icon: DownloadIcon,
        label: (past) => past ? "Reinstalled" : "Reinstall"
      },
      {
        value: VerificationIssueResolveMethod.UPDATE,
        variant: "primary",
        icon: DownloadIcon,
        label: (past) => past ? "Updated" : "Update"
      },
      {
        value: VerificationIssueResolveMethod.ALLOW_ONCE,
        variant: "critical-primary",
        label: (past) => `${past ? "Allowed" : "Allow"} once`,
        confirmation: {
          text: (pack) => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("p", null, "By selecting this option, you grant the pack ", /* @__PURE__ */ BdApi.React.createElement("b", null, pack.name), " full access to your Discord client during the current session. Animations of this pack may try to execute malicious code to harm the client or compromise your Discord account."), /* @__PURE__ */ BdApi.React.createElement("p", null, "Only proceed if you know what you're doing or if you are the author of this pack.")),
          confirmText: "Allow once anyway"
        }
      },
      {
        value: VerificationIssueResolveMethod.ALLOW_ALWAYS,
        variant: "critical-primary",
        label: (past) => `${past ? "Allowed" : "Allow"} all the time`,
        confirmation: {
          text: (pack) => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("p", null, "By selecting this option, you grant the pack ", /* @__PURE__ */ BdApi.React.createElement("b", null, pack.name), " full access to your Discord client ", /* @__PURE__ */ BdApi.React.createElement("b", null, "permanently"), ". Animations of this pack may try to execute malicious code to harm the client or compromise your Discord account."), /* @__PURE__ */ BdApi.React.createElement("p", null, "Only proceed if you know what you're doing or if you are the author of this pack."), /* @__PURE__ */ BdApi.React.createElement(Alert, { messageType: AlertTypes.WARNING }, "Note that if the contents of this pack change, ", config.name, " will not ask for confirmation and will automatically grant full access to this pack if you choose to allow it all the time.")),
          confirmText: "Allow all the time anyway"
        }
      }
    ].map((item) => [item.value, item])
  );
  function cyrb53(str, seed = 0) {
    let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
    for (let i = 0, ch; i < str.length; i++) {
      ch = str.charCodeAt(i);
      h1 = Math.imul(h1 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
    h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
    h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
  }
  function getFileHash(fileContent, algorithm = cyrb53) {
    return algorithm(
      fileContent.replaceAll(/\s/g, "")
    );
  }
  const stripBOM = function(fileContent) {
    if (fileContent.charCodeAt(0) === 65279) {
      fileContent = fileContent.slice(1);
    }
    return fileContent;
  };
  class AddonManager {
    constructor() {
      this.timeCache = {};
      this.addonList = [];
      this.toastQueue = [];
    }
    get name() {
      return "";
    }
    get extension() {
      return "";
    }
    get duplicatePattern() {
      return /./;
    }
    get addonFolder() {
      return "";
    }
    get language() {
      return "";
    }
    get prefix() {
      return "addon";
    }
    get forbiddenSlugs() {
      return [];
    }
    emit(event, ...args) {
      return Emitter.emit(`${this.prefix}-${event}`, ...args);
    }
    initialize() {
      this.ensureAddonFolder();
      const errors = this.loadAllAddons();
      Logger.info(this.name, "Initialized.");
      return errors;
    }
    ensureAddonFolder() {
      if (!fs.existsSync(this.addonFolder))
        fs.mkdirSync(this.addonFolder);
    }
    // Subclasses should overload this and modify the addon object as needed to fully load it
    initializeAddon() {
    }
    toast(content, event = "loaded") {
      this.toastQueue.push({ content, event });
      setTimeout(() => {
        const toasts = this.toastQueue.filter((t) => t.event === event);
        if (!toasts.length) return;
        if (toasts.length === 1) Toasts.show(toasts[0].content);
        else Toasts.show(`${event.slice(0, 1).toUpperCase() + event.slice(1)} ${toasts.length} ${this.prefix}s.`);
        this.toastQueue = this.toastQueue.filter((t) => t.event !== event);
      }, 100);
    }
    watchAddons() {
      if (this.watcher) return Logger.err(this.name, `Already watching ${this.prefix} addons.`);
      Logger.log(this.name, `Starting to watch ${this.prefix} addons...`);
      this.watcher = fs.watch(this.addonFolder, { persistent: false }, async (eventType, filename) => {
        if (!eventType || !filename) return;
        const absolutePath = path.resolve(this.addonFolder, filename);
        if (!filename.endsWith(this.extension)) {
          const match = filename.match(this.duplicatePattern);
          if (!match) return;
          const ext = match[0];
          const truncated = filename.replace(ext, "");
          const newFilename = truncated + this.extension;
          if (fs.existsSync(newFilename)) {
            Logger.warn(this.name, `Duplicate files found: ${filename} and ${newFilename}`);
            return;
          }
          try {
            fs.renameSync(absolutePath, path.resolve(this.addonFolder, newFilename));
          } catch (error2) {
            Logger.err(this.name, `Could not rename file: ${filename} ${newFilename}`, error2);
          }
        }
        await new Promise((r) => setTimeout(r, 100));
        try {
          const stats = fs.statSync(absolutePath);
          if (!stats.isFile()) return;
          if (!stats || !stats.mtimeMs) return;
          if (typeof stats.mtimeMs !== "number") return;
          if (this.timeCache[filename] == stats.mtimeMs) return;
          this.timeCache[filename] = stats.mtimeMs;
          if (eventType == "rename") this.loadAddon(filename, true);
          if (eventType == "change") this.reloadAddon(filename, true);
        } catch (err) {
          if (err.code !== "ENOENT" && !err?.message.startsWith("ENOENT")) return;
          delete this.timeCache[filename];
          this.unloadAddon(filename, true);
        }
      });
    }
    unwatchAddons() {
      if (!this.watcher) return Logger.error(this.name, `Was not watching ${this.prefix} addons.`);
      this.watcher.close();
      delete this.watcher;
      Logger.log(this.name, `No longer watching ${this.prefix} addons.`);
    }
    // Subclasses should overload this and modify the addon using the fileContent as needed to "require()"" the file
    requireAddon(filename) {
      const slug2 = path.basename(filename).replace(this.extension, "").replace(/ /g, "-");
      let fileContent = fs.readFileSync(filename, "utf8");
      fileContent = stripBOM(fileContent);
      const stats = fs.statSync(filename);
      let addon, parseError;
      try {
        const { data: data2, pointers } = jsonSourceMapExports.parse(fileContent);
        addon = data2;
        addon.pointers = pointers;
      } catch (e) {
        addon = {};
        parseError = e;
      }
      addon.slug = slug2;
      addon.id = slug2;
      addon.name = addon.name ?? slug2;
      addon.author = addon.author ?? "Unknown";
      addon.version = addon.version ?? "0.0.0";
      addon.filename = path.basename(filename);
      addon.added = stats.atimeMs;
      addon.modified = stats.mtimeMs;
      addon.size = stats.size;
      addon.fileContent = fileContent.split(/\r?\n|\r|\n/g);
      addon.hash = getFileHash(fileContent);
      addon.installed = addon;
      addon.verificationStatus = VerificationStatus.UNKNOWN;
      if (this.forbiddenSlugs.includes(slug2))
        throw new AddonError(this.prefix, addon, `Forbidden ${this.prefix} slug: '${slug2}'`);
      const existingIndex = this.addonList.findIndex((c) => c.id === addon.id);
      if (existingIndex !== -1) this.addonList.splice(existingIndex, 1, addon);
      else this.addonList.push(addon);
      if (parseError)
        throw new AddonError(this.prefix, addon, formatAddonParseError(addon, parseError, fileContent));
      return addon;
    }
    // Subclasses should use the return (if not AddonError) and push to this.addonList
    loadAddon(filename, shouldToast = true) {
      if (typeof filename === "undefined") return;
      let addon;
      try {
        addon = this.requireAddon(path.resolve(this.addonFolder, filename));
      } catch (e) {
        const { addon: partialAddon } = e;
        if (partialAddon) {
          partialAddon.partial = true;
          partialAddon.error = e;
          this.emit("loaded", partialAddon);
        }
        return e;
      }
      const error2 = this.initializeAddon(addon);
      if (error2) {
        addon.partial = true;
        addon.error = error2;
        this.emit("loaded", addon);
        return error2;
      }
      if (shouldToast) this.toast(/* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("b", null, addon.name), " was loaded."), "loaded");
      Logger.log(this.name, `${addon.name} v${addon.version} was loaded.`);
      this.emit("loaded", addon);
    }
    unloadAddon(idOrFileOrAddon, shouldToast = true, isReload = false) {
      const addon = typeof idOrFileOrAddon == "string" ? this.addonList.find((c) => c.id == idOrFileOrAddon || c.filename == idOrFileOrAddon) : idOrFileOrAddon;
      if (!addon) return false;
      this.addonList.splice(this.addonList.indexOf(addon), 1);
      this.emit("unloaded", addon);
      if (shouldToast) this.toast(/* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("b", null, addon.name), " was unloaded."), "unloaded");
      Logger.log(this.name, `${addon.name} was unloaded.`);
      return true;
    }
    reloadAddon(idOrFileOrAddon, shouldToast = true) {
      const addon = typeof idOrFileOrAddon == "string" ? this.addonList.find((c) => c.id == idOrFileOrAddon || c.filename == idOrFileOrAddon) : idOrFileOrAddon;
      const didUnload = this.unloadAddon(addon, false, true);
      if (addon && !didUnload) return didUnload;
      const error2 = this.loadAddon(addon ? addon.filename : idOrFileOrAddon, false);
      if (!error2 && shouldToast) this.toast(/* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("b", null, addon.name), " was reloaded."), "reloaded");
      return error2;
    }
    isLoaded(idOrFile) {
      const addon = this.addonList.find((c) => c.id == idOrFile || c.filename == idOrFile);
      if (!addon) return false;
      return true;
    }
    getAddon(idOrFile) {
      return this.addonList.find((c) => c.id == idOrFile || c.filename == idOrFile);
    }
    loadNewAddons() {
      const files = fs.readdirSync(this.addonFolder);
      const removed = this.addonList.filter((t) => !files.includes(t.filename)).map((c) => c.id);
      const added = files.filter((f) => !this.addonList.find((t) => t.filename == f) && f.endsWith(this.extension) && fs.statSync(path.resolve(this.addonFolder, f)).isFile());
      return { added, removed };
    }
    updateList() {
      const results = this.loadNewAddons();
      for (const filename of results.added) this.loadAddon(filename);
      for (const name2 of results.removed) this.unloadAddon(name2);
    }
    loadAllAddons() {
      const errors = [];
      const files = fs.readdirSync(this.addonFolder);
      for (const filename of files) {
        const absolutePath = path.resolve(this.addonFolder, filename);
        const stats = fs.statSync(absolutePath);
        if (!stats || !stats.isFile()) continue;
        this.timeCache[filename] = stats.mtimeMs;
        if (!filename.endsWith(this.extension)) {
          const match = filename.match(this.duplicatePattern);
          if (!match) continue;
          const ext = match[0];
          const truncated = filename.replace(ext, "");
          const newFilename = truncated + this.extension;
          if (fs.existsSync(newFilename)) {
            Logger.warn("AddonManager", `Duplicate files found: ${filename} and ${newFilename}`);
            continue;
          }
          fs.renameSync(absolutePath, path.resolve(this.addonFolder, newFilename));
        }
        const addon = this.loadAddon(filename, true);
        if (addon instanceof AddonError) errors.push(addon);
      }
      this.watchAddons();
      return errors;
    }
    unloadAllAddons() {
      this.addonList.slice().forEach((addon) => this.unloadAddon(addon, false));
    }
    shutdown() {
      this.unloadAllAddons();
      this.unwatchAddons();
      Logger.info(this.name, "Shutdown.");
    }
    deleteAddon(filename) {
      return fs.unlinkSync(path.resolve(this.addonFolder, filename));
    }
    saveAddon(filename, content) {
      return fs.writeFileSync(path.resolve(this.addonFolder, filename), content);
    }
  }
  class Notices {
    static info(content, options = {}) {
      return this.show(content, Object.assign({}, options, { type: "info" }));
    }
    static warn(content, options = {}) {
      return this.show(content, Object.assign({}, options, { type: "warning" }));
    }
    static error(content, options = {}) {
      return this.show(content, Object.assign({}, options, { type: "error" }));
    }
    static success(content, options = {}) {
      return this.show(content, Object.assign({}, options, { type: "success" }));
    }
    static show(content, options = {}) {
      return UI.showNotice(content, options);
    }
  }
  const SettingsMode = Enum({
    Simple: "simple",
    Advanced: "advanced"
  });
  const DataEvents = {
    FieldUpdated: "fieldUpdated"
  };
  class DataField {
    constructor(name2, defaultValue) {
      this.$name = name2;
      this.$defaultValue = defaultValue;
      this.$parentField = null;
      this.$base = null;
      this.$emitter = null;
    }
    $load() {
      if (this.$parentField) return this.$parentField.$reflect("get", this.$name);
      if (!this.$base) throw new Error("Trying to manipulate root DataField before $base was assigned");
      return this.$base.load(this.$name);
    }
    $save(value) {
      if (this.$parentField) return this.$parentField.$mutationReflect("set", this.$name, value);
      if (!this.$base) throw new Error("Trying to manipulate root DataField before $base was assigned");
      this.$base.save(this.$name, structuredClone(value));
      this.$emitter?.emit(DataEvents.FieldUpdated, this.$name);
    }
    get $value() {
      return this.$load() ?? this.$defaultValue;
    }
    set $value(value) {
      this.$save(value);
    }
  }
  class DataObjectField extends DataField {
    static mutationMethods = [];
    constructor(name2, fields = [], defaultValue = {}) {
      super(name2, defaultValue);
      this.$fields = Object.fromEntries(
        fields.map((field) => {
          field.$parentField = this;
          return [field.$name, field];
        })
      );
      const reflect = (method) => (self2, ...args) => this.$reflect.call(self2, method, ...args);
      const mutationReflect = (method) => (self2, ...args) => this.$mutationReflect.call(self2, method, ...args);
      return new Proxy(this, {
        get(self2, key2) {
          if (key2 in self2) return self2[key2];
          if (key2 in self2.$fields) {
            if (self2.$fields[key2] instanceof DataObjectField) return self2.$fields[key2];
            return self2.$fields[key2].$value;
          }
          const value = self2.$value[key2];
          if (typeof value === "function") return (...args) => {
            const value2 = self2.$value;
            const returnValue = value2[key2](...args);
            if (self2.constructor.mutationMethods.includes(key2)) self2.$value = value2;
            return returnValue;
          };
          return value;
        },
        set(self2, key2, value) {
          if (key2 in self2) self2[key2] = value;
          else if (key2 in self2.$fields) self2.$fields[key2].$value = value;
          else self2.$mutationReflect("set", key2, value);
          return true;
        },
        defineProperty: mutationReflect("defineProperty"),
        deleteProperty: mutationReflect("deleteProperty"),
        has: reflect("has"),
        ownKeys: reflect("ownKeys"),
        getOwnPropertyDescriptor: reflect("getOwnPropertyDescriptor")
      });
    }
    $reflect(method, ...args) {
      return Reflect[method](this.$value, ...args);
    }
    $mutationReflect(method, ...args) {
      const value = this.$value;
      Reflect[method](value, ...args);
      this.$value = value;
      return true;
    }
  }
  class DataArrayField extends DataObjectField {
    static mutationMethods = ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"];
    constructor(name2, defaultValue = []) {
      return super(name2, [], defaultValue);
    }
  }
  class DataSetField extends DataArrayField {
    static mutationMethods = ["add", "delete", "clear"];
    constructor(name2, defaultValue = /* @__PURE__ */ new Set()) {
      return super(name2, Array.from(defaultValue));
    }
    get $value() {
      return new Set(super.$value);
    }
    set $value(value) {
      super.$value = Array.from(value);
    }
  }
  class Data {
    constructor(base, fields = []) {
      this.$base = base;
      this.$emitter = new EventEmitter();
      this.$fields = Object.fromEntries(
        fields.map((field) => {
          field.$base = this.$base;
          field.$emitter = this.$emitter;
          return [field.$name, field];
        })
      );
      return new Proxy(this, {
        get(self2, key2) {
          if (key2 in self2) return self2[key2];
          if (!(key2 in self2.$fields)) self2.$createField(key2);
          if (self2.$fields[key2] instanceof DataObjectField) return self2.$fields[key2];
          return self2.$fields[key2].$value;
        },
        set(self2, key2, value) {
          if (key2 in self2.$fields) self2.$fields[key2].$value = value;
          else self2.$createField(key2).$value = value;
          return true;
        }
      });
    }
    $createField(name2, defaultValue) {
      const field = new DataField(name2, defaultValue);
      field.$base = this.$base;
      this.$fields[name2] = field;
      return field;
    }
    $use(name2) {
      const update = useUpdate();
      require$$0$1.useEffect(() => {
        const onDataFieldUpdated = (updatedName) => {
          if (updatedName === name2) update();
        };
        this.$emitter.on(DataEvents.FieldUpdated, onDataFieldUpdated);
        return () => this.$emitter.off(DataEvents.FieldUpdated, onDataFieldUpdated);
      }, [name2]);
      return [
        this[name2],
        require$$0$1.useCallback((value) => this[name2] = value, [name2])
      ];
    }
  }
  const data = new Data(BDData, [
    new DataObjectField("currentVersionInfo", [
      new DataField("version", version$1),
      new DataField("hasShownChangelog", false)
    ]),
    new DataField("configVersion"),
    new DataField("settings"),
    new DataField("settingsMode", SettingsMode.Simple),
    new DataObjectField("packs"),
    new DataObjectField("preferences", [
      new DataField("module"),
      new DataField("pack"),
      new DataField("sort")
    ]),
    new DataObjectField("catalog", [
      new DataField("visited", false),
      new DataSetField("known"),
      new DataField("cache"),
      new DataField("sort")
    ]),
    new DataObjectField("library", [
      new DataSetField("whitelist"),
      new DataField("sort")
    ]),
    new DataObjectField("prompts"),
    new DataObjectField("dismissibles")
  ]);
  const useData = data.$use.bind(data);
  const useMode = () => useData("settingsMode");
  function useAdvancedMode(force = false) {
    const [mode] = useMode();
    return force || mode === SettingsMode.Advanced;
  }
  const AnimationSettingContainer = Enum({
    Group: "group",
    List: "list"
  });
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  function SetCache(values) {
    var index2 = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function arraySome(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  function cacheHas(cache, key2) {
    return cache.has(key2);
  }
  var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function mapToArray(map) {
    var index2 = -1, result = Array(map.size);
    map.forEach(function(value, key2) {
      result[++index2] = [key2, value];
    });
    return result;
  }
  function setToArray(set) {
    var index2 = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
  var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var COMPARE_PARTIAL_FLAG$1 = 1;
  var objectProto$1 = Object.prototype;
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key2 = objProps[index2];
      if (!(isPartial ? key2 in other : hasOwnProperty$1.call(other, key2))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key2 = objProps[index2];
      var objValue = object[key2], othValue = other[key2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key2 == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }
  function isSame(array, key2) {
    return array.every((item) => isEqual(item?.[key2], array[0]?.[key2]));
  }
  function canMerge(settings) {
    const _isSame = (key2) => isSame(settings, key2);
    if (!_isSame("type")) return false;
    const base = _isSame("animation") && _isSame("value");
    switch (settings[0].type) {
      case AnimationSetting.Position:
        return base && _isSame("preserve");
      case AnimationSetting.Direction:
        return base && _isSame("axis") && _isSame("reverse") && _isSame("towards");
      default:
        return base;
    }
  }
  function mergeFunctions(array) {
    return Object.fromEntries(
      Object.entries(array[0] ?? {}).filter(([, value]) => typeof value === "function").map(([key2]) => [
        key2,
        (...args) => array.forEach((item) => item[key2]?.(...args))
      ])
    );
  }
  function _useAnimationSettings(module2, items2, options = {}) {
    const { hideOverflow = false } = options;
    const isAdvanced = useAdvancedMode();
    const sets = items2.map(({ animation, settings, setSettings: _setSettings, defaults: defaults2 }) => {
      if (!animation) return [];
      const setSettings = (values) => _setSettings({ ...settings, ...values });
      const buildSetting = (setting, props = {}) => {
        const value = settings[setting];
        const defaultValue = defaults2()[setting];
        return {
          module: module2,
          animation,
          type: setting,
          value,
          onChange: (value2) => setSettings({ [setting]: value2 }),
          defaultValue,
          onReset: !isEqual(value, defaultValue) ? () => setSettings({ [setting]: defaults2()[setting] }) : null,
          ...props
        };
      };
      return [
        animation.settings?.[AnimationSetting.Duration] && buildSetting(AnimationSetting.Duration),
        animation.settings?.[AnimationSetting.Variant] && buildSetting(AnimationSetting.Variant),
        animation.settings?.[AnimationSetting.Position] && (() => {
          const keys2 = [AnimationSetting.Position, AnimationSetting.PositionPreserve];
          const values = pick(settings, keys2);
          const defaultValues = pick(defaults2(), keys2);
          return buildSetting(AnimationSetting.Position, {
            preserve: settings[AnimationSetting.PositionPreserve],
            onPreserveChange: (value) => setSettings({ [AnimationSetting.PositionPreserve]: value }),
            onReset: !isEqual(values, defaultValues) ? () => setSettings(defaultValues) : null
          });
        })(),
        animation.settings?.[AnimationSetting.Direction] && (() => {
          const keys2 = [AnimationSetting.Direction, AnimationSetting.DirectionAxis, AnimationSetting.DirectionReverse, AnimationSetting.DirectionTowards];
          const values = pick(settings, keys2);
          const defaultValues = pick(defaults2(), keys2);
          return buildSetting(AnimationSetting.Direction, {
            axis: settings[AnimationSetting.DirectionAxis],
            onAxisChange: (value) => setSettings({ [AnimationSetting.DirectionAxis]: value }),
            reverse: settings[AnimationSetting.DirectionReverse],
            onReverseChange: (value) => setSettings({ [AnimationSetting.DirectionReverse]: value }),
            towards: settings[AnimationSetting.DirectionTowards],
            onTowardsChange: (value) => setSettings({ [AnimationSetting.DirectionTowards]: value }),
            onReset: !isEqual(values, defaultValues) ? () => setSettings(defaultValues) : null
          });
        })(),
        isAdvanced && animation.settings?.[AnimationSetting.Easing] && buildSetting(AnimationSetting.Easing),
        isAdvanced && !hideOverflow && !module2.meta?.settings?.hideOverflow && buildSetting(AnimationSetting.Overflow, {
          forced: animation.settings?.[AnimationSetting.Overflow] === false
        })
      ].filter(Boolean);
    });
    if (!isSame(items2, "animation"))
      return [{
        type: AnimationSettingContainer.Group,
        children: sets.map((settings) => ({
          type: AnimationSettingContainer.List,
          children: settings
        }))
      }];
    return Array(Math.max(...sets.map((s) => s.length), 0)).fill(null).map((_, i) => {
      const settings = sets.map((s) => s[i] ?? null);
      const shouldMerge = !isAdvanced && module2.meta?.type === ModuleType.Switch && isSame(items2, "enabled") && canMerge(settings);
      if (!shouldMerge) return {
        type: AnimationSettingContainer.Group,
        children: settings
      };
      return {
        ...settings[0],
        defaultValue: isSame(settings, "defaultValue") ? settings[0].defaultValue : null,
        ...mergeFunctions(settings)
      };
    });
  }
  function useAnimationSettingsHeaders(module2, items2, settings = _useAnimationSettings(module2, items2)) {
    const typeLabel = (type) => ({
      [AnimationType.Enter]: "Enter",
      [AnimationType.Exit]: "Exit"
    })[type];
    const headers = items2.map(({
      animation,
      type,
      enabled,
      setEnabled,
      settings: settings2,
      defaults: defaults2,
      onReset,
      title,
      subtitle,
      headerAfter,
      switchTooltip
    }) => ({
      key: type,
      title: title || typeLabel(type) || animation.name,
      subtitle: title && subtitle ? subtitle === true ? typeLabel(type) : subtitle : null,
      headerAfter,
      enabled,
      setEnabled,
      switchTooltip,
      onReset: onReset && !isEqual(settings2, defaults2()) ? onReset : null
    }));
    if (!settings.some((s) => s.type === AnimationSettingContainer.Group)) return [{
      key: "both",
      title: items2[0]?.animation?.name || "No animations selected",
      enabled: items2.every((i) => i.enabled),
      ...mergeFunctions(headers)
    }];
    return headers;
  }
  function useAnimationSettings(module2, items2, options = {}) {
    const settings = _useAnimationSettings(module2, items2, options);
    return {
      headers: useAnimationSettingsHeaders(module2, items2, settings),
      settings
    };
  }
  const SuppressErrors = Enum({
    All: "all",
    Animation: "animation",
    None: "none"
  });
  const CONFIG_VERSION = 2;
  const packConfigDefaults = {
    entries: []
  };
  const configDefaults = {
    modules: {
      [ModuleKey.Servers]: {
        enabled: true,
        enhanceLayout: true,
        enter: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slide"
        },
        exit: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slide"
        }
      },
      [ModuleKey.Channels]: {
        enabled: true,
        enter: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slip"
        },
        exit: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slip"
        }
      },
      [ModuleKey.Settings]: {
        enabled: true,
        enter: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slip"
        },
        exit: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slip"
        }
      },
      [ModuleKey.Layers]: {
        enabled: true,
        enter: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "scale"
        },
        exit: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "scale"
        }
      },
      [ModuleKey.Tooltips]: {
        enabled: true,
        enter: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slip"
        },
        exit: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slip"
        }
      },
      [ModuleKey.Popouts]: {
        enabled: true,
        enter: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slip"
        },
        exit: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slip"
        }
      },
      [ModuleKey.ContextMenu]: {
        enabled: true,
        enter: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "scale"
        },
        exit: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "scale"
        }
      },
      [ModuleKey.Messages]: {
        enabled: true,
        enter: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "fade"
        },
        exit: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "fade"
        }
      },
      [ModuleKey.ChannelList]: {
        enabled: true,
        enter: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slip"
        },
        exit: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slip"
        }
      },
      [ModuleKey.Modals]: {
        enabled: true,
        enter: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slip"
        },
        exit: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "slip"
        }
      },
      [ModuleKey.ModalsBackdrop]: {
        enabled: true,
        enter: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "backdropSolid"
        },
        exit: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "backdropSolid"
        }
      },
      [ModuleKey.MembersSidebar]: {
        enabled: true,
        enter: {
          packSlug: null,
          animationKey: null
        },
        exit: {
          packSlug: null,
          animationKey: null
        }
      },
      [ModuleKey.ThreadSidebar]: {
        enabled: true,
        enter: {
          packSlug: null,
          animationKey: null
        },
        exit: {
          packSlug: null,
          animationKey: null
        }
      },
      [ModuleKey.ThreadSidebarSwitch]: {
        enabled: true,
        enter: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "fade"
        },
        exit: {
          packSlug: PREINSTALLED_PACK_SLUG,
          animationKey: "fade"
        }
      }
    },
    general: {
      quickPreview: true,
      disableHints: false,
      suppressErrors: SuppressErrors.None,
      prioritizeAnimationSmoothness: true,
      cacheUserSettingsSections: true,
      preloadLayers: true,
      switchCooldownDuration: 1e3
    }
  };
  const ExternalPackDataStore = new class {
    constructor() {
      this.cache = {};
    }
    _getFile(slug2) {
      return path.resolve(PackManager.addonFolder, `${slug2}.config.json`);
    }
    _ensureData(slug2) {
      if (typeof this.cache[slug2] !== "undefined") return;
      if (!fs.existsSync(this._getFile(slug2))) return this.cache[slug2] = {};
      try {
        this.cache[slug2] = JSON.parse(fs.readFileSync(this._getFile(slug2)).toString());
      } catch {
        return this.cache[slug2] = {};
      }
    }
    _saveData(slug2) {
      fs.writeFileSync(this._getFile(slug2), JSON.stringify(this.cache[slug2], null, 4));
    }
    getData(slug2, key2) {
      this._ensureData(slug2);
      return this.cache[slug2][key2];
    }
    setData(slug2, key2, value) {
      if (value === void 0) return;
      this._ensureData(slug2);
      this.cache[slug2][key2] = value;
      this._saveData(slug2);
    }
    deleteData(slug2, key2) {
      this._ensureData(slug2);
      delete this.cache[slug2][key2];
      this._saveData(slug2);
    }
  }();
  class BaseExternalPackData {
    constructor(slug2) {
      this.slug = slug2;
    }
    save(key2, value) {
      return ExternalPackDataStore.setData(this.slug, key2, value);
    }
    load(key2) {
      return ExternalPackDataStore.getData(this.slug, key2);
    }
  }
  class BaseInternalPackData {
    constructor(slug2) {
      this.slug = slug2;
    }
    save(key2, value) {
      data.packs[this.slug] = {
        ...data.packs[this.slug],
        [key2]: value
      };
    }
    load(key2) {
      return data.packs[this.slug]?.[key2];
    }
  }
  class PackData {
    get name() {
      return "PackData";
    }
    constructor() {
      this.internalInstances = new Map(
        internalPackSlugs.map((slug2) => [
          slug2,
          this.create(slug2, new BaseInternalPackData(slug2))
        ])
      );
      this.externalInstances = /* @__PURE__ */ new Map();
      this.onPackLoaded = (pack) => this.externalInstances.set(pack.slug, this.create(pack.slug));
      this.onPackUnloaded = (pack) => this.externalInstances.delete(pack.slug);
    }
    create(slug2, base = new BaseExternalPackData(slug2)) {
      return new Data(base, [
        new DataField("configVersion"),
        new DataField("currentVersion"),
        new DataField("settings")
      ]);
    }
    pack(slug2) {
      return this.internalInstances.get(slug2) ?? this.externalInstances.get(slug2) ?? this.create(slug2);
    }
    initialize() {
      Emitter.on(Events.PackLoaded, this.onPackLoaded);
      Emitter.on(Events.PackUnloaded, this.onPackUnloaded);
      Logger.info(this.name, "Initialized.");
    }
    shutdown() {
      Emitter.off(Events.PackLoaded, this.onPackLoaded);
      Emitter.off(Events.PackUnloaded, this.onPackUnloaded);
      this.externalInstances.clear();
      Logger.info(this.name, "Shutdown.");
    }
  }
  const PackData$1 = new PackData();
  function MigratorModal({ migrator, ...props }) {
    const {
      isActive,
      message,
      actions
    } = migrator.use();
    require$$0$1.useEffect(() => {
      if (!isActive) props.onClose?.();
    }, [isActive]);
    return /* @__PURE__ */ BdApi.React.createElement(
      Modal$2,
      {
        ...props,
        title: Messages.SETTINGS_MIGRATOR,
        footer: /* @__PURE__ */ BdApi.React.createElement(ButtonGroup$1, { direction: "horizontal-reverse" }, actions.map((props2) => /* @__PURE__ */ BdApi.React.createElement(Button$1, { ...props2 })))
      },
      /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-md/normal" }, message)
    );
  }
  function MigratorAlert({ migrator, ...props }) {
    const {
      message,
      actions
    } = migrator.use();
    return /* @__PURE__ */ BdApi.React.createElement(
      Alert,
      {
        ...props,
        messageType: AlertTypes.WARNING
      },
      message,
      /* @__PURE__ */ BdApi.React.createElement(
        ButtonGroup$1,
        {
          className: DiscordClasses.Margins.marginTop8,
          size: "sm"
        },
        actions.map((props2) => /* @__PURE__ */ BdApi.React.createElement(Button$1, { ...props2, size: "sm" }))
      )
    );
  }
  function MigratorContainer({ migrator, children: children2, className, contentClassName }) {
    const { isActive } = migrator.use();
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        className: classNames({
          "BA__migratorContainer": true,
          "BA__migratorContainer--blocked": isActive
        }, className)
      },
      isActive && /* @__PURE__ */ BdApi.React.createElement(MigratorAlert, { migrator }),
      /* @__PURE__ */ BdApi.React.createElement("div", { className: classNames("BA__migratorContainerContent", contentClassName) }, children2)
    );
  }
  css`.BA__migratorContainer {
    display: flex;
    flex-direction: column;
    gap: 16px;
}
.BA__migratorContainer--blocked .BA__migratorContainerContent {
    pointer-events: none;
    opacity: .4;
}``Migrator Components`;
  const AbortSymbol = Symbol("Abort");
  class Migrator {
    static IDLE = 0;
    static BUSY = 1;
    static ERROR = 2;
    get name() {
      return "Migrator";
    }
    constructor(config2, migrations2 = {}) {
      this.config = config2;
      this.migrations = migrations2;
      this._status = Migrator.IDLE;
      this._abortController = null;
      this._schedulerCallbackId = null;
      this.error = null;
    }
    get status() {
      return this._status;
    }
    set status(value) {
      this._status = value;
      if (value !== Migrator.ERROR) this.error = null;
      Emitter.emit(Events.MigratorUpdated);
    }
    get configs() {
      return this.config.getAll();
    }
    getOutdatedConfigs(configs = this.configs) {
      return configs.filter((config2) => config2.isOutdated);
    }
    hasOutdatedConfigs(configs = this.configs) {
      return configs.some((config2) => config2.isOutdated);
    }
    get isActive() {
      return this.hasOutdatedConfigs();
    }
    getMinVersion(configs, latestVersion = CONFIG_VERSION) {
      return configs.reduce((minVersion, config2) => Math.min(minVersion, config2.configVersion), latestVersion);
    }
    buildPromptMessage(configs = this.getOutdatedConfigs()) {
      return this.config.buildMigrationPromptMessage(configs);
    }
    useEffect() {
      useEmitterEffect(Events.MigratorUpdated);
    }
    useMessage() {
      this.useEffect();
      switch (this.status) {
        case Migrator.IDLE: {
          if (!this.hasOutdatedConfigs()) return /* @__PURE__ */ BdApi.React.createElement("p", null, "Your settings are up to date.");
          return this.buildPromptMessage();
        }
        case Migrator.BUSY:
          return /* @__PURE__ */ BdApi.React.createElement("p", null, "Your settings are being migrated to the latest version...");
        case Migrator.ERROR:
          return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("p", null, "An error occurred while trying to migrate your settings to the latest version."), /* @__PURE__ */ BdApi.React.createElement("p", null, "Contact the support if you don't want to lose your settings."));
      }
    }
    useActions() {
      this.useEffect();
      switch (this.status) {
        case Migrator.IDLE: {
          if (!this.hasOutdatedConfigs()) return [];
          return [
            {
              text: "Migrate",
              onClick: () => this.migrate(true)
            },
            {
              variant: "secondary",
              text: "Cancel",
              onClick: () => this.promptCancel()
            }
          ];
        }
        case Migrator.BUSY:
          return [
            {
              text: "Migrate",
              disabled: true,
              loading: true
            },
            {
              variant: "secondary",
              text: "Abort",
              onClick: () => this.abort()
            }
          ];
        case Migrator.ERROR:
          return [
            {
              text: "View",
              onClick: () => ErrorManager.showModal([this.error])
            },
            {
              variant: "secondary",
              text: "Try again",
              onClick: () => this.migrate(true)
            },
            {
              variant: "secondary",
              text: "Cancel",
              onClick: () => this.promptCancel()
            }
          ];
      }
    }
    use() {
      this.useEffect();
      return {
        isActive: this.isActive,
        status: this.status,
        loading: this.status === Migrator.BUSY,
        error: this.error,
        message: this.useMessage(),
        actions: this.useActions()
      };
    }
    prompt() {
      ModalActions.openModal((props) => /* @__PURE__ */ BdApi.React.createElement(
        MigratorModal,
        {
          ...props,
          migrator: this
        }
      ), { modalKey: "BA__migratorModal" });
    }
    promptIfNeeded(versionOrConfigs = this.configs) {
      if (Array.isArray(versionOrConfigs)) return this.promptIfNeeded(this.getMinVersion(versionOrConfigs));
      for (let v = versionOrConfigs + 1; v <= CONFIG_VERSION; v++) {
        if (!this.migrations[v].prompt) continue;
        this.prompt();
        return true;
      }
      return false;
    }
    applyMutations(mutations) {
      const incompleteMutations = mutations.filter((mutation) => mutation.version !== CONFIG_VERSION);
      if (incompleteMutations.length) {
        Logger.error(this.name, "Found incomplete mutations after migration:", incompleteMutations);
        throw new Error("Found incomplete mutations");
      }
      this.config.applyMutations(mutations);
    }
    async migrate(confirmed = false) {
      if (this.status === Migrator.BUSY || !this.hasOutdatedConfigs()) return;
      const version2 = this.getMinVersion(this.configs);
      if (!confirmed && this.promptIfNeeded(version2)) return;
      this.status = Migrator.BUSY;
      this._abortController = new AbortController();
      const signal = this._abortController.signal;
      try {
        const configs = this.configs.map((config2) => ({
          slug: config2.slug,
          version: config2.configVersion,
          data: config2.data.settings
        }));
        const mutations = [];
        for (let v = version2 + 1; v <= CONFIG_VERSION; v++) {
          const migration = this.migrations[v];
          if (!migration) throw new Error(`Migration for version ${v} doesn't exist`);
          const result = await migration.handler(
            mutations.concat(configs).filter((config2) => config2.version === v - 1).map((config2) => structuredClone(config2)),
            signal
          );
          if (result === false || signal.aborted) throw AbortSymbol;
          for (const mutation of result) {
            const existing = mutations.find((m) => m.slug === mutation.slug);
            if (existing) Object.assign(existing, mutation);
            else mutations.push(mutation);
          }
        }
        this.applyMutations(mutations);
        if (confirmed) Toasts.success("Settings successfully migrated.");
        this.status = Migrator.IDLE;
      } catch (error2) {
        if (error2 === AbortSymbol) {
          Logger.warn(this.name, "Migration aborted.");
          this.status = Migrator.IDLE;
          return;
        }
        Logger.error(this.name, "Migration failed:", error2);
        error2 = new InternalError(`${this.name}: ${error2.stack ?? error2.message}`);
        this.prompt();
        this.error = error2;
        this.status = Migrator.ERROR;
      }
    }
    schedule() {
      cancelIdleCallback(this._schedulerCallbackId);
      this._schedulerCallbackId = requestIdleCallback(() => this.migrate());
    }
    validate(configs = this.configs) {
      if (!this.hasOutdatedConfigs(configs)) return;
      if (!this.promptIfNeeded(configs)) this.schedule();
      Emitter.emit(Events.MigratorUpdated);
    }
    abort() {
      this._abortController?.abort(AbortSymbol);
    }
    cancel() {
      for (const config2 of this.configs) {
        if (config2.isOutdated) config2.reset();
      }
    }
    promptCancel() {
      ModalActions.openModal((props) => /* @__PURE__ */ BdApi.React.createElement(
        Modal$2,
        {
          ...props,
          title: Messages.SETTINGS_MIGRATOR,
          confirmText: "Confirm cancellation",
          confirmButtonVariant: "critical-primary",
          cancelText: "Back to migration",
          onConfirm: () => this.cancel()
        },
        /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-md/normal" }, /* @__PURE__ */ BdApi.React.createElement("p", null, "Are you sure you want to cancel migration? Your configuration will be deleted ", /* @__PURE__ */ BdApi.React.createElement("b", null, "permanently"), "."), /* @__PURE__ */ BdApi.React.createElement("p", null, "This means that you will lose all your settings from the previous version and it will be replaced with the default settings. ", /* @__PURE__ */ BdApi.React.createElement("b", null, "This action cannot be undone.")))
      ));
    }
  }
  function IconButton({ children: children2, tooltip, disabled = false, active = false, className, ...props }) {
    const button = (_props) => /* @__PURE__ */ BdApi.React.createElement("div", { className, ..._props }, /* @__PURE__ */ BdApi.React.createElement(
      Clickable,
      {
        tag: "button",
        className: classNames(
          "BA__iconButton",
          { "BA__iconButton--active": active }
        ),
        disabled,
        ...props
      },
      children2
    ));
    if (!tooltip) return button({});
    const tooltipProps = typeof tooltip === "string" ? { text: tooltip } : tooltip;
    return /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { ...tooltipProps }, button);
  }
  css`.BA__iconButton {
    display: block;
    color: var(--interactive-normal);
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
}
.BA__iconButton:hover {
    color: var(--interactive-hover);
}
.BA__iconButton:active,
.BA__iconButton--active {
    color: var(--interactive-active);
}
.BA__iconButton:disabled {
    color: var(--interactive-muted);
    cursor: not-allowed;
}

.BA__iconButton svg {
    display: block;
    fill: currentColor;
}``IconButton`;
  function CheckIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M18.7 7.3a1 1 0 0 1 0 1.4l-8 8a1 1 0 0 1-1.4 0l-4-4a1 1 0 1 1 1.4-1.4l3.3 3.29 7.3-7.3a1 1 0 0 1 1.4 0Z",
          clipRule: "evenodd"
        }
      )
    );
  }
  function CircleQuestionIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL, secondaryColor = "transparent" }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "circle",
        {
          cx: "12",
          cy: "12",
          r: "10",
          fill: typeof secondaryColor === "string" ? secondaryColor : secondaryColor.css
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M12 23a11 11 0 1 0 0-22 11 11 0 0 0 0 22Zm-.28-16c-.98 0-1.81.47-2.27 1.14A1 1 0 1 1 7.8 7.01 4.73 4.73 0 0 1 11.72 5c2.5 0 4.65 1.88 4.65 4.38 0 2.1-1.54 3.77-3.52 4.24l.14 1a1 1 0 0 1-1.98.27l-.28-2a1 1 0 0 1 .99-1.14c1.54 0 2.65-1.14 2.65-2.38 0-1.23-1.1-2.37-2.65-2.37ZM13 17.88a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z",
          clipRule: "evenodd"
        }
      )
    );
  }
  function CircleDollarSignIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "1 1 22 22"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2S2 6.477 2 12s4.477 10 10 10m.75-16a.75.75 0 0 0-1.5 0v.317c-1.63.292-3 1.517-3 3.183c0 1.917 1.813 3.25 3.75 3.25c1.377 0 2.25.906 2.25 1.75s-.873 1.75-2.25 1.75c-1.376 0-2.25-.906-2.25-1.75a.75.75 0 0 0-1.5 0c0 1.666 1.37 2.891 3 3.183V18a.75.75 0 0 0 1.5 0v-.317c1.63-.292 3-1.517 3-3.183c0-1.917-1.813-3.25-3.75-3.25c-1.376 0-2.25-.906-2.25-1.75s.874-1.75 2.25-1.75c1.377 0 2.25.906 2.25 1.75a.75.75 0 0 0 1.5 0c0-1.666-1.37-2.891-3-3.183z",
          clipRule: "evenodd"
        }
      )
    );
  }
  function SquircleMask({ children: children2, size = 40, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...props,
        height: size,
        width: size,
        viewBox: `0 0 ${size} ${size}`
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "foreignObject",
        {
          x: 0,
          y: 0,
          height: size,
          width: size,
          overflow: "visible",
          mask: "url(#svg-mask-squircle)"
        },
        children2
      )
    );
  }
  function LinkIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M16.32 14.72a1 1 0 0 1 0-1.41l2.51-2.51a3.98 3.98 0 0 0-5.62-5.63l-2.52 2.51a1 1 0 0 1-1.41-1.41l2.52-2.52a5.98 5.98 0 0 1 8.45 8.46l-2.52 2.51a1 1 0 0 1-1.41 0ZM7.68 9.29a1 1 0 0 1 0 1.41l-2.52 2.51a3.98 3.98 0 1 0 5.63 5.63l2.51-2.52a1 1 0 0 1 1.42 1.42l-2.52 2.51a5.98 5.98 0 0 1-8.45-8.45l2.51-2.51a1 1 0 0 1 1.42 0Z"
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M14.7 10.7a1 1 0 0 0-1.4-1.4l-4 4a1 1 0 1 0 1.4 1.4l4-4Z"
        }
      )
    );
  }
  function ArrowSmallRightIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M20.7 12.7a1 1 0 0 0 0-1.4l-5-5a1 1 0 1 0-1.4 1.4l3.29 3.3H4a1 1 0 1 0 0 2h13.59l-3.3 3.3a1 1 0 0 0 1.42 1.4l5-5Z"
        }
      )
    );
  }
  function CircleWarningIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL, secondaryColor = "transparent", ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        ...props
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "circle",
        {
          cx: "12",
          cy: "12",
          r: "10",
          fill: typeof secondaryColor === "string" ? secondaryColor : secondaryColor.css
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M12 23a11 11 0 1 0 0-22 11 11 0 0 0 0 22Zm1.44-15.94L13.06 14a1.06 1.06 0 0 1-2.12 0l-.38-6.94a1 1 0 0 1 1-1.06h.88a1 1 0 0 1 1 1.06Zm-.19 10.69a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0Z",
          clipRule: "evenodd"
        }
      )
    );
  }
  function usePackRegistry() {
    useEmitterEffect([
      Events.PackLoaded,
      Events.PackUnloaded,
      Events.PackUpdated,
      Events.PackRegistryUpdated
    ]);
    return PackRegistry;
  }
  function stop(callback) {
    return (event) => {
      event.stopPropagation();
      callback?.(event);
    };
  }
  function prevent(callback) {
    return (event) => {
      event.preventDefault();
      callback?.(event);
    };
  }
  function JSONIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 512 512"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M284.096 382.755c126.41-96.067 39.609-294.896-69.513-277.86C9.315 136.94 60.658 422.223 129.047 475.258C22.042 422.39-22.426 291.217 10.82 179.74C37.161 91.427 119.287 3.962 243.708.61c196.367-17.91 254.873 364.165 40.388 382.145M219.247 130.2c-112.3 5.728-136.522 119.158-127.29 201.114c13.467 119.577 89.242 197.216 207.553 177.684c181.777-30.01 331.904-318.726 76.441-480.015c94.11 109.624 94.983 331.713-59.624 371.13c-142.981 43.102-208.076-187.725-97.08-269.913"
        }
      )
    );
  }
  function Skeleton({ className, rounded = true, animated = true, width, height, style: style2, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        className: classNames({
          "BA__skeleton": true,
          "BA__skeleton--rounded": rounded,
          "BA__skeleton--animated": animated
        }, className),
        style: { width, height, ...style2 },
        ...props
      }
    );
  }
  css`.BA__skeleton {
    display: inline-block;
    height: 1em;
    width: 100px;
    background-color: var(--text-default);
    opacity: .15;
}
.BA__skeleton--rounded {
    border-radius: 999px;
}
.BA__skeleton--animated {
    animation: BA__skeletonAnimation 1.5s ease infinite;
}

@keyframes BA__skeletonAnimation {
    0%, 100% { opacity: .15; }
    50% { opacity: .075; }
}``Skeleton`;
  function isInviteInvalid(invite2) {
    return [InviteStates.EXPIRED, InviteStates.BANNED, InviteStates.ERROR].includes(invite2?.state);
  }
  function isDismissed(name2) {
    return data.dismissibles[name2] === true;
  }
  function useDismissible(name2) {
    const [dismissibles] = useData("dismissibles");
    return [
      dismissibles[name2] === true,
      require$$0$1.useCallback((value) => dismissibles[name2] = value, [name2])
    ];
  }
  function DismissibleModal({ name: name2, ...props }) {
    const [, setIsDismissed] = useDismissible(name2);
    const [shouldDismiss, setShouldDismiss] = require$$0$1.useState(false);
    const onConfirm = (...args) => {
      props.onConfirm?.(...args);
      if (shouldDismiss) setIsDismissed(true);
    };
    return /* @__PURE__ */ BdApi.React.createElement(
      Modal$2,
      {
        ...props,
        onConfirm,
        footerLeading: /* @__PURE__ */ BdApi.React.createElement(
          Checkbox,
          {
            value: shouldDismiss,
            onChange: (_, value) => setShouldDismiss(value)
          },
          /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-sm/normal" }, "Don't show again")
        )
      }
    );
  }
  function MoreIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M4 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm10-2a2 2 0 1 1-4 0 2 2 0 0 1 4 0Zm8 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z",
          clipRule: "evenodd"
        }
      )
    );
  }
  function useResolveMethods(pack) {
    const registry = usePackRegistry();
    const hasUpdate = registry.hasUpdate(pack);
    return require$$0$1.useMemo(() => {
      const additional = [
        verificationIssueResolveMethods[VerificationIssueResolveMethod.ALLOW_ONCE],
        verificationIssueResolveMethods[VerificationIssueResolveMethod.ALLOW_ALWAYS]
      ];
      switch (pack.verificationStatus) {
        case VerificationStatus.UNKNOWN:
          return {
            main: [verificationIssueResolveMethods[VerificationIssueResolveMethod.ALLOW_ONCE]],
            additional: [verificationIssueResolveMethods[VerificationIssueResolveMethod.ALLOW_ALWAYS]]
          };
        case VerificationStatus.UNVERIFIED:
          return {
            main: [verificationIssueResolveMethods[VerificationIssueResolveMethod.DELETE]],
            additional
          };
        case VerificationStatus.FAILED:
          return {
            main: [
              hasUpdate ? verificationIssueResolveMethods[VerificationIssueResolveMethod.UPDATE] : verificationIssueResolveMethods[VerificationIssueResolveMethod.REINSTALL]
            ],
            additional: [
              verificationIssueResolveMethods[VerificationIssueResolveMethod.UNINSTALL],
              ...additional
            ]
          };
        default:
          return {
            main: [],
            additional
          };
      }
    }, [pack.verificationStatus, hasUpdate]);
  }
  function VerificationIssueActions({ pack, onSelect, size = "sm", disabled = false, ...props }) {
    const additionalButtonRef = require$$0$1.useRef();
    const { main, additional } = useResolveMethods(pack);
    const selectMethod = require$$0$1.useCallback((method) => {
      const dismissibleName = `verificationIssueResolveMethodConfirmation:${method.value}`;
      if (!method.confirmation || isDismissed(dismissibleName)) return onSelect(method);
      ModalActions.openModal((props2) => /* @__PURE__ */ BdApi.React.createElement(
        DismissibleModal,
        {
          ...props2,
          name: dismissibleName,
          size: ModalSize.MEDIUM,
          title: method.label(),
          cancelText: "Cancel",
          confirmText: method.confirmation.confirmText,
          confirmButtonVariant: "critical-primary",
          onConfirm: () => onSelect(method)
        },
        /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-md/normal" }, method.confirmation.text(pack))
      ));
    }, [pack, onSelect]);
    return /* @__PURE__ */ BdApi.React.createElement(
      ButtonGroup$1,
      {
        ...props,
        size
      },
      main.map((method) => /* @__PURE__ */ BdApi.React.createElement(
        Button$1,
        {
          variant: method.variant,
          icon: method.icon,
          text: method.label(),
          size,
          onClick: () => selectMethod(method),
          disabled
        }
      )),
      /* @__PURE__ */ BdApi.React.createElement(
        Popout,
        {
          targetElementRef: additionalButtonRef,
          position: "bottom",
          align: "right",
          renderPopout: ({ closePopout, ...props2 }) => /* @__PURE__ */ BdApi.React.createElement(
            ContextMenu$1.Menu,
            {
              ...props2,
              onClose: closePopout
            },
            additional.map((method) => /* @__PURE__ */ BdApi.React.createElement(
              ContextMenu$1.Item,
              {
                key: method.value,
                id: method.value,
                label: method.label(),
                icon: method.icon,
                color: method.variant === "critical-primary" ? "danger" : void 0,
                action: () => selectMethod(method)
              }
            ))
          )
        },
        (props2) => /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            ...props2,
            buttonRef: additionalButtonRef,
            variant: "secondary",
            size,
            icon: MoreIcon,
            disabled
          }
        )
      )
    );
  }
  function RedoIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "g",
        {
          fill: "none",
          stroke: typeof color === "string" ? color : color.css,
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "2"
        },
        /* @__PURE__ */ BdApi.React.createElement("path", { d: "m15 14l5-5l-5-5" }),
        /* @__PURE__ */ BdApi.React.createElement("path", { d: "M20 9H9.5A5.5 5.5 0 0 0 4 14.5A5.5 5.5 0 0 0 9.5 20H13" })
      )
    );
  }
  function VerificationIssueSelection({ variant, icon: Icon2, label, onUndo, size = "sm", disabled = false, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      ButtonGroup$1,
      {
        ...props,
        size
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "div",
        {
          className: classNames([
            "BA__verificationIssueSelection",
            `BA__verificationIssueSelection--${variant}`
          ])
        },
        Icon2 && /* @__PURE__ */ BdApi.React.createElement(
          Icon2,
          {
            size,
            color: "currentColor"
          }
        ),
        /* @__PURE__ */ BdApi.React.createElement(
          Text$1,
          {
            variant: "text-md/semibold",
            color: "currentColor"
          },
          typeof label === "function" ? label() : label
        )
      ),
      onUndo && /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: "Undo" }, (props2) => /* @__PURE__ */ BdApi.React.createElement(
        Button$1,
        {
          ...props2,
          variant: "secondary",
          size,
          icon: RedoIcon,
          onClick: onUndo,
          disabled
        }
      ))
    );
  }
  css`.BA__verificationIssueSelection {
    display: flex;
    align-items: center;
    gap: 4px;
}
.BA__verificationIssueSelection--primary {
    color: var(--text-brand);
}
.BA__verificationIssueSelection--critical-primary {
    color: var(--text-feedback-critical);
}``VerificationIssueSelection`;
  function BadgePopout({ pack, onClose }) {
    const registry = usePackRegistry();
    const { icon, label, description } = verificationStatuses[pack.verificationStatus];
    const resolveMethod = verificationIssueResolveMethods[registry.verifier.getResolveMethod(pack)];
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__badgePopout" }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__badgePopoutIcon" }, icon({
      size: "custom",
      width: 64,
      height: 64
    })), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__badgePopoutInfo" }, /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "heading-lg/semibold" }, label), description && /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__badgePopoutDescription",
        variant: "text-sm/normal"
      },
      description
    ), !registry.verifier.check(pack) ? /* @__PURE__ */ BdApi.React.createElement(
      VerificationIssueActions,
      {
        className: "BA__badgePopoutActions",
        pack,
        onSelect: (method) => {
          registry.verifier.resolveIssue({ pack, method: method.value });
          onClose?.();
        },
        size: "sm",
        disabled: registry.hasPending
      }
    ) : resolveMethod && /* @__PURE__ */ BdApi.React.createElement(
      VerificationIssueSelection,
      {
        ...resolveMethod,
        className: "BA__badgePopoutActions",
        label: resolveMethod.label(true),
        onUndo: () => registry.verifier.removeFromWhitelist(pack)
      }
    )));
  }
  function PackVerificationBadge({ pack, size = "sm", popoutType = "popout" }) {
    const { icon, tooltipColor, label } = verificationStatuses[pack.verificationStatus];
    const iconRef = require$$0$1.useRef();
    const [shouldShow2, setShouldShow] = require$$0$1.useState(false);
    const showTimeout = require$$0$1.useMemo(() => new Timeout(), []);
    const hideTimeout = require$$0$1.useMemo(() => new Timeout(), []);
    const handleEnter = require$$0$1.useCallback(() => {
      hideTimeout.stop();
      showTimeout.start(200, () => setShouldShow(true));
    }, [showTimeout, hideTimeout, setShouldShow]);
    const handleLeave = require$$0$1.useCallback(() => {
      showTimeout.stop();
      hideTimeout.start(200, () => setShouldShow(false));
    }, [showTimeout, hideTimeout, setShouldShow]);
    if (popoutType === "tooltip") return /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: label, color: tooltipColor }, (props) => icon({ ...props, size }));
    return /* @__PURE__ */ BdApi.React.createElement(
      Popout,
      {
        targetElementRef: iconRef,
        shouldShow: shouldShow2,
        onRequestClose: () => setShouldShow(false),
        position: "right",
        align: "center",
        spacing: 0,
        renderPopout: () => /* @__PURE__ */ BdApi.React.createElement(
          "div",
          {
            className: "BA__badgePopoutContainer",
            onMouseEnter: () => hideTimeout.stop(),
            onMouseLeave: handleLeave,
            onClick: stop()
          },
          /* @__PURE__ */ BdApi.React.createElement(
            BadgePopout,
            {
              pack,
              onClose: () => setShouldShow(false)
            }
          )
        )
      },
      () => icon({
        ref: iconRef,
        onMouseEnter: handleEnter,
        onMouseLeave: handleLeave,
        size
      })
    );
  }
  css`.BA__badgePopoutContainer {
    padding: 8px;
}
.BA__badgePopout {
    box-shadow: var(--shadow-high);
    background-color: var(--background-surface-high);
    border-radius: 8px;
    border: 1px solid var(--border-subtle);
    max-width: 400px;
    padding: 16px;
    display: flex;
    align-items: stretch;
    gap: 8px;
}
.BA__badgePopoutIcon {
    width: 64px;
    flex-shrink: 0;
    display: flex;
    align-items: flex-start;
}
.BA__badgePopoutInfo {
    display: flex;
    flex-direction: column;
    justify-content: center;
}
.BA__badgePopoutDescription {
    margin-top: 2px;
}
.BA__badgePopoutActions {
    margin-top: 8px;
}``PackVerificationBadge`;
  function PackHeader({ pack, icon, popoutType, size = "sm" }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packHeader" }, icon ?? /* @__PURE__ */ BdApi.React.createElement(
      PackVerificationBadge,
      {
        pack,
        popoutType,
        size
      }
    ), /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        tag: "h2",
        variant: size === "md" ? "heading-lg/bold" : "heading-md/bold",
        color: "header-primary",
        lineClamp: 2
      },
      pack.name
    ));
  }
  css`.BA__packHeader {
    display: flex;
    align-items: flex-start;
    gap: 4px;
}
.BA__packHeader svg {
    flex-shrink: 0;
}
.BA__packHeader h2 {
    word-break: break-word;
}``PackHeader`;
  const thumbnailPlaceholder = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAV4AAADFCAMAAAArI2ocAAAAS1BMVEUlJysjJSggIiUnKS0ZGx0yNTo0Nz0pLDAdHyI2Oj8wMzgsLzM5PEAVFhgTFBZER0tHSk5JTFA7PkIuMTU/QkdhY2ZmaGtcXmFTVVnFOwe6AAAMQUlEQVR42uzY24KaMBCA4YGcE8IuRBff/0kLwS5ylAnSBvHzukv5HZMAkBWM8rjxWLHkYjynPE5W0IpEzPEZhA6NY8aQ12gSL6HmcJsPUNIXR14iSLyYmiXyoYT0RJI3YkYtkE/G95P3Ga4WuHwoJT1752Xk2IxalOYDttfzk/cJtYzZfECSnpC830veKq9WT0A+BKSDzCu8J3mF9xZ5hXqKLu1un7xrDmVFVd1KNc0sHc6C8uqz5DXKu/00yrWHM0t+nSevCD6UXX68m5qmFw5nJ8lrmlCOIDnlFT9epWYk87vbOfIa5WmCw9fl5UuHM4D1OyhD5DUR5eWqJYIOZdnC4uCRhfEFuj4v1x6/LCm1x+LJK9SdDjuUffvhzYIOZ5CniEshRJiXBb4pK4vbl/LQhzPI7Wnyus0vG9CHM8hz+eZ5g9ZersYut3oJLucPZ1IrLmxvd4M6NUSS121hyCzRtjKoQ9lYdv2pXbO5Vw/yYaWw8Js3p5Hk/driQuYJzZjGzK7gaqz48Yq5w5l43OholzeHp1cLhcv7veFzIS/k+ISqHt36U/AJTUbDvST34GF6I8m7RUlw8Dd8+/Em89IurxxMrwXU1WTLvXNeovlY2U5vycdEXkt5Qw/XXon7MvOW4QPNa7vLu+QVfML3tfbFx5jNG9DUpYOTg4WX5L1dG8O++qB5ieNTLhc+BfKWlW3crmn71LY9b3m9Nj+d27vkJYwvUL3OC+8kgcJzK/Jerq1hXkDYlhewSG3lPU/8UqsusMwHHpom6/J2rfJWCjUzzFttyVs2LnhlQ6HrigbM0nzOV/9WJ145AIqY+zvAf1XXRjHKiyU4GoQgohXwH6muvX2Gjof39XnL5qI3fpS8RNwRmOPW5YV8wEJgXjsEvKPq9Y//j7xsp7yEzS69Xnk/lA3JXfJ62/MSjqV3yguGd8bb+I176TjKrnnL+sutypBbT6mtcSzjRyZ9fV5gc32ra1Uo3nB2KNk1r6r8tpqh80rb4lgi6L7E3caFStoBCqF5nWzYFpU1MfXk6BXYvNTeOY4EQYse6YZ3nl771XYAT7AHtmXYtKLybswz6LrWMCQI3FSIj7uIsGWa2gG5c97v6tp8ClxeasPzJvZXCi9m1n2zHdg5r6q8jHkCVkkfVhyBziulDL67TeOr7VC6d15WVrULaxFY5XFzMgxJQE3if5vbxzdF72v4vGNZxu40angTCM3b/Q14Nc1mGTuUBOYNZDBnsjTwYgQ8unH1xd87Yl/bJa9GbWyhF4NWgrhDDMdmCDoE/zavAcTSSzfmhXve48HnRQzvMAxhSIMv6XjC8moC65B+GIajTzq9AvlAHJjXQSs9V14Bq8leGR2Wl96PRscj9lsZvKT3yOOC8srDLr0BeR0BDGo9GZLXQC2h9rBrAzqvE4CT2IeXDoahECllHfe4w4vLqw0BNGk7CUNJrHfYlReAmLW6V6jhfRONktpfKXzMkKF55afuGim1LYnNe+Bd7V9KJKX4vM0/oVQec9n9D4hGgQ+cT95daQwHHzhOIxj4wBEaQcBHyN72WXr3YvRqBrYRTnPlaXeaH4Jey8EGxKmyT51jrRF6JQLBHC+nZI7A2xN772smK+dkJ1jPhdNPhc+ZyMol2QkO0+ZZXAGhePmMev81mAjjZtsaATuMbic7y+MKGYFNTLnOCVbgHfKabC0GZ0BGNtY9bl9SizpvXfewfUkr4rwiQ4nrBEzuos1LMqyYzme75PXkXwlswTM0iAbZLy+l1PrPprwu8466/O6a19uWV9W5Drw8RD69OgvBIRrYuvjpTWGHfU01shlneDr+nd705cOrmGtprmIf305806sm42r3gGdT3v/1OiIv6nmNuz6tYn+28CLMq9UYc0NaTYB9JEmaSi9NE8CIMO9i3eW+AnaQpLLnfxaWm/MKNcLdL66X+jp4uVROQASObXrdRLW77Ksoiu+Ldi2uhhi8WCKnpbBWbNP7h7074E4TBgI4fndBQ43v6dTv/1lnAnqUw8AlhDHkT+e61U3ze2e01W4HieZCd4/ru55d6CTHHKDs6OYPsHUiuyTvUQ4v67b9uJA8a2ndfN/HH9Fj+rfMWNNmXRsosyIXuv3hrncXsv1MMV0/N3P4Pq6ih37kOcjNNsP7vB4v3Pf2ACWjLm3g7RljGu+fXqvgPV49q8///CjPS4zbi32zpzesZg28N39Nwuj6owAvhogIm7q6nZOuL6G+oc0BxzLuY6jpM+/52i3Ci5rYFBCpfo0ndXVl9ZDv/817KMLLpkA9QcbtnPQ/jFxBXijJa9rHZddOP85ns3nZFKqpvHXW9nD7TXt5vt1w3PdjqAkASOTeu8PldY3uzifPizreioMh3epzieMLN78APvzbDRdMrqkd30egDdfo6ELyrISaqgm8gyd8DkJlt4vogQtG0sy1vpe2VtdUIq1unLeKpeY1odvjcekdN83NPJ9XZF3TMQDf7q6pzuOtBK8c3sG9N3F3OL469I6mEy6TRKvdUDBwRu0mpOflEy3v4dWRf/iTtsV5OXQyU8ko/WJAuTfod4f3uIYT/rk5FuMdWhbEdLmMS5G88bs2/X1bd2BfvjzGi/HiEBwJ3UzeavHpHdoROtp3XKjhxRjHWaqqvL2BJvHG91799LJnZ2cIHZfjpQ/TAtaFQJwhb2+QvCR45R6hn95oy/Fi9AbJMDl3bLT45sBfm7EuZNu3ZwaXjKqkcObpFRMrZjeF1/rDus5hi/PKxeuj+XhZd+7ptdYOAI/xrmB8ayzAK+7QxPyiljfkffndcd5/P760MG+dxMu4vDfMxwuA06oL6Kp559wbmFe2PC8qdWvUFeetJty1rZBX8WwCFdCN8tKvxuY3Z2/I983nRSqoC4b6wambK/FkENhIEZcivEjlZteeRIGXw2m8qIhHt9AAA+h983WTeO9zPxEPlisywAlP5vLaEh8zaHk50/Xtnih05egWG2DgZt2Ao2vU83JYvxNfKdNuDWC5IgMMnHaAI0cEV83relliRzG6iuHl0S06wDpcjurcXVdmnAjkSqmWJejCJ0kz8w7MtqoocXJV4wRW5Zuvi3VNZn5fTIn69+C8vJQgzsu+ClzlzgDhb1kJr4/4m8tUtHpeDkijq+HF2pfJK31xDY3xcgZrkgcqik7vt/NaQCIxuZpMbO/9Ml7/zfiHocUGYyLUxrwiA8MfWgdRapL34E3Db/2cfT9isZCxeDaUfQNvYwrGmNO56WC4hte80/Nq2wCv4Q7nN6+HDhXgHf+DsEneM/OeY7zwTP8qXOaleiTaOu9ren96vCEvgPqYd6xt8nrTyN6Lr6qdd3LDe689nn1HK3n36U3kbU0hvH/y/y1GVxcKT2+4WNwaL5gmNoX4o6RC0wsmhBvmbfrAi21leNG0bYwXJ/JCPi9EeGGrvCAg47o7ry6YwotcOu83bg6IE3ixMC+Lbo8XR3mxMC+P79YemIXivIAFeTkEwM19WtEEXU2IjS5m8H7hZ20SGHq/6LXzpgLzompqGmDM4G2j0SC0kufLZolNA+8rlFHav0y08zaN8dY7byQdL4lYXdfO2+GNR6hPw7tFXcE7r+7Oy7wFdJfghbSwWPq9NxV3CV6bFhYszovzVZ4XbNM6Xw30tbwGy8e8hW495XnNUyrpwLLZbmBEOEPMizQSpvK2re3FbKNf76U5QlCGpAr4+tYhMMPDKoYcNKtoIkXjvDMcSbyoOIzkHcq6+92Z3ykuJfjqFr6N6Z3I60LJC0QKvJrsWqdXdUzjtS5kTTeg6dNLXvf7phf0vBxNztMqPcbuRolo9XsvdSahbmo4opuD/vb5DLUc3YBS+ufTix9emy14LetyQIqQMirHq21eXs5ak8VLq+QtG8R4x0P60M7Lw6vktTuvcmOXvPAp64NX9KGd1wdqXmNDO6+GN4RSVmabRh+m7LxEqOc1O28pXh5fM7b57rzPIIHXsG5sfHfev+3Xuw6AIBBEUWf+/6MtMNGsuDzCmgBzKxMs4BRkIRxeP/F28KYO8Qbw9sZs4iUxJOYSL30xC/gfL7A0r10u/B6yq/V5WcmLkE1Nz1vksgcV7/S82I4XTEG8I3nTZwUvdDm8g9OtSzOYxfMuMjkgnzfvspF352fFJ5U3/4q3Ll/KmF0r4q0PzVJNvuLNRfFumXifiXeuxPtMvHMl3tBOXtMiDrLwEWYAAAAASUVORK5CYII=";
  function PackSplash({ pack, showAuthor = false, className }) {
    const registry = usePackRegistry();
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: classNames("BA__packSplash", className) }, /* @__PURE__ */ BdApi.React.createElement(
      "img",
      {
        className: "BA__packSplashImage",
        src: registry.getThumbnailSrc(pack) ?? thumbnailPlaceholder,
        onError: (event) => event.currentTarget.src = thumbnailPlaceholder,
        alt: pack.name,
        loading: "lazy",
        draggable: "false"
      }
    ), showAuthor && /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: pack.author }, (props) => /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        ...props,
        className: "BA__packSplashAuthor"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "img",
        {
          className: "BA__packAuthorAvatar",
          src: registry.getAuthorAvatarSrc(pack),
          alt: pack.author,
          draggable: "false"
        }
      )
    )));
  }
  css`.BA__packSplash {
    background: linear-gradient(180deg, rgba(68, 70, 73, 0), rgba(68, 70, 73, .4));
    aspect-ratio: 16 / 9;
    position: relative;
}
.BA__packSplashImage {
    position: absolute;
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
}
.BA__packSplashAuthor {
    position: absolute;
    right: 20px;
    bottom: -16px;
    z-index: 2;
    border-radius: 50%;
    box-shadow: 0 0 0 5px currentColor;
}``PackSplash`;
  const PackContentLocation = {
    CATALOG: 0,
    LIBRARY: 1
  };
  function PackVersion({ version: version2, from }) {
    return /* @__PURE__ */ BdApi.React.createElement("span", { className: "BA__packVersion" }, from && /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("span", null, from), /* @__PURE__ */ BdApi.React.createElement(ArrowSmallRightIcon, { size: "xs", color: "currentColor" })), /* @__PURE__ */ BdApi.React.createElement("span", null, version2));
  }
  function PackField({ icon, title, titleColor, subtitle, children: children2 }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packField" }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packFieldInfo" }, icon, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packFieldInfoContent" }, /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__packFieldTitle",
        variant: "text-md/semibold",
        lineClamp: 1,
        color: titleColor
      },
      title
    ), subtitle && /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__packFieldSubtitle",
        variant: "text-sm/normal",
        color: "text-muted"
      },
      subtitle
    ))), children2 && /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packFieldActions" }, children2));
  }
  function PackAction({ pack, size, location }) {
    const registry = usePackRegistry();
    const isInstalled = !!pack.installed;
    const hasUpdate = isInstalled && registry.hasUpdate(pack.installed);
    const pending = registry.isPending(pack.filename);
    const props = {
      size,
      fullWidth: size === "md",
      loading: pending,
      disabled: pending
    };
    if (hasUpdate) return /* @__PURE__ */ BdApi.React.createElement(
      Button$1,
      {
        ...props,
        icon: DownloadIcon,
        text: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("span", null, "Update"), size === "md" && /* @__PURE__ */ BdApi.React.createElement(
          PackVersion,
          {
            from: pack.installed.version,
            version: registry.getPack(pack.filename).version
          }
        )),
        onClick: stop(() => registry.update(pack.filename))
      }
    );
    if (isInstalled) {
      if (location === PackContentLocation.LIBRARY && size === "sm") return null;
      return /* @__PURE__ */ BdApi.React.createElement(
        Button$1,
        {
          ...props,
          icon: CheckIcon,
          variant: "active",
          disabled: true,
          text: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("span", null, location === PackContentLocation.LIBRARY && registry.hasPack(pack.filename) ? "Up to date" : "Installed"), size === "md" && /* @__PURE__ */ BdApi.React.createElement(PackVersion, { version: pack.version }))
        }
      );
    }
    return /* @__PURE__ */ BdApi.React.createElement(
      Button$1,
      {
        ...props,
        icon: DownloadIcon,
        text: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("span", null, "Install"), size === "md" && /* @__PURE__ */ BdApi.React.createElement(PackVersion, { version: pack.version })),
        onClick: stop(() => registry.install(pack.filename))
      }
    );
  }
  function PackInvite({ code }) {
    const invite2 = useStateFromStores([InviteStore], () => InviteStore.getInvite(code));
    const guild = useStateFromStores([GuildStore], () => GuildStore.getGuild(invite2?.guild?.id), [invite2]);
    require$$0$1.useEffect(() => {
      if (!invite2) InviteActions.resolveInvite(code);
    }, [code, invite2]);
    const pending = !invite2 || invite2.state === InviteStates.RESOLVING;
    const invalid = isInviteInvalid(invite2);
    const join = require$$0$1.useCallback(() => {
      if (guild) {
        ModalActions.closeAllModals();
        LayerActions.popAllLayers();
      }
      UI.showInviteModal(code);
    }, [code, guild]);
    return /* @__PURE__ */ BdApi.React.createElement(
      PackField,
      {
        icon: /* @__PURE__ */ BdApi.React.createElement(SquircleMask, { size: 48 }, pending || invalid || !invite2?.guild ? /* @__PURE__ */ BdApi.React.createElement(
          Skeleton,
          {
            width: 48,
            height: 48,
            rounded: false,
            animated: pending
          }
        ) : /* @__PURE__ */ BdApi.React.createElement(
          GuildIcon,
          {
            className: "BA__packServerIcon",
            guild: invite2.guild,
            active: true
          }
        )),
        title: pending ? /* @__PURE__ */ BdApi.React.createElement(Skeleton, { width: 130 }) : invalid ? "Invalid Invite" : invite2?.guild?.name,
        titleColor: invalid ? "text-danger" : void 0,
        subtitle: "Support Server"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        Button$1,
        {
          variant: "secondary",
          size: "sm",
          text: guild ? "Open" : "Join",
          loading: pending,
          disabled: pending || invalid,
          onClick: join
        }
      )
    );
  }
  function PackBadge({ pack, location }) {
    const registry = usePackRegistry();
    const isUnknown = require$$0$1.useMemo(() => registry.isUnknown(pack), []);
    if (pack.installed && registry.hasUpdate(pack.installed)) return /* @__PURE__ */ BdApi.React.createElement(
      TextBadge,
      {
        className: "BA__packBadge",
        text: "Update available",
        color: "var(--bg-brand)"
      }
    );
    if (location === PackContentLocation.CATALOG && isUnknown) return /* @__PURE__ */ BdApi.React.createElement(
      TextBadge,
      {
        className: "BA__packBadge",
        text: "New"
      }
    );
    return null;
  }
  function PackMeta$1({ pack, onShowSource = () => PackManager.showInFolder(pack.filename) }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packMeta" }, /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        tooltip: "Source",
        onClick: stop(onShowSource)
      },
      /* @__PURE__ */ BdApi.React.createElement(JSONIcon, { size: "sm", color: "currentColor" })
    ), pack.invite && /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        tooltip: "Support Server",
        onClick: stop(() => UI.showInviteModal(pack.invite))
      },
      /* @__PURE__ */ BdApi.React.createElement(CircleQuestionIcon, { size: "sm", color: "currentColor" })
    ));
  }
  function PackContent({ pack, className, size = "sm", location = PackContentLocation.CATALOG }) {
    const registry = usePackRegistry();
    const isPublished = registry.hasPack(pack.filename);
    const authorAvatarSrc = registry.getAuthorAvatarSrc(pack);
    const showSource = require$$0$1.useCallback(() => {
      if (location === PackContentLocation.CATALOG) handleClick({ href: registry.getSourceURL(pack.filename) });
      else PackManager.showInFolder(pack.filename);
    }, [pack, location]);
    const uninstall = require$$0$1.useCallback(() => {
      if (!pack.installed) return;
      const affectedModules = Core.getModulesUsingPack(pack);
      ModalActions.openModal((props) => /* @__PURE__ */ BdApi.React.createElement(
        Modal$2,
        {
          ...props,
          title: "Uninstall Pack",
          confirmText: isPublished ? "Uninstall" : "Delete permanently",
          confirmButtonVariant: "critical-primary",
          cancelText: "Cancel",
          onConfirm: () => registry.delete(pack.filename)
        },
        /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-md/normal" }, "Are you sure you want to delete pack ", /* @__PURE__ */ BdApi.React.createElement("b", null, pack.name), "?", isPublished ? " It can always be reinstalled from the Catalog." : " It is not published in the Catalog, so it cannot be reinstalled."),
        affectedModules.length > 0 && /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-md/normal", className: DiscordClasses.Margins.marginTop8 }, "Animations of this pack are currently applied for: ", affectedModules.map((module2, i, { length }) => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("b", null, module2.name), i < length - 1 ? ", " : ".")), " They will be automatically deselected.")
      ));
    }, [pack]);
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        className: classNames(
          "BA__packContent",
          `BA__packContent--${size}`,
          className
        )
      },
      /* @__PURE__ */ BdApi.React.createElement(
        PackBadge,
        {
          pack,
          location
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        PackSplash,
        {
          pack,
          showAuthor: size === "sm"
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packContentContainer" }, /* @__PURE__ */ BdApi.React.createElement(
        PackHeader,
        {
          pack,
          size
        }
      ), pack.description && /* @__PURE__ */ BdApi.React.createElement(
        Text$1,
        {
          className: classNames("BA__packDescription", DiscordClasses.Scroller.thin),
          variant: "text-sm/medium",
          color: "text-muted",
          lineClamp: size === "sm" && 2
        },
        pack.description
      ), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packContentSpacer" }), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packFooter" }, size === "md" ? /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("div", null, /* @__PURE__ */ BdApi.React.createElement(
        PackField,
        {
          icon: /* @__PURE__ */ BdApi.React.createElement(
            "img",
            {
              className: "BA__packAuthorAvatar",
              src: authorAvatarSrc,
              alt: pack.author
            }
          ),
          title: pack.author,
          subtitle: "Author"
        },
        pack.authorLink && /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: "Author's Page" }, (props) => /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            ...props,
            variant: "secondary",
            size: "sm",
            icon: LinkIcon,
            onClick: () => handleClick({ href: pack.authorLink })
          }
        )),
        pack.donate && /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: "Donate" }, (props) => /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            ...props,
            variant: "active",
            size: "sm",
            icon: CircleDollarSignIcon,
            onClick: () => handleClick({ href: pack.donate })
          }
        ))
      ), pack.invite && /* @__PURE__ */ BdApi.React.createElement(PackInvite, { code: pack.invite })), /* @__PURE__ */ BdApi.React.createElement(Divider$2, null), /* @__PURE__ */ BdApi.React.createElement(
        Button$1,
        {
          variant: "icon-only",
          icon: JSONIcon,
          text: pack.filename,
          fullWidth: true,
          onClick: showSource
        }
      )) : /* @__PURE__ */ BdApi.React.createElement(
        PackMeta$1,
        {
          pack,
          onShowSource: showSource
        }
      ), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packActions" }, pack.partial && /* @__PURE__ */ BdApi.React.createElement(
        IconButton,
        {
          tooltip: "An error occurred",
          onClick: stop(() => ErrorManager.showModal([pack.error]))
        },
        /* @__PURE__ */ BdApi.React.createElement(
          CircleWarningIcon,
          {
            size: "md",
            color: colors.STATUS_DANGER,
            secondaryColor: "var(--white-400)"
          }
        )
      ), /* @__PURE__ */ BdApi.React.createElement(
        PackAction,
        {
          pack,
          size,
          location
        }
      ), pack.installed && /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: "Uninstall" }, (props) => /* @__PURE__ */ BdApi.React.createElement(
        Button$1,
        {
          ...props,
          variant: "critical-primary",
          size,
          icon: TrashIcon,
          disabled: registry.isPending(pack.filename),
          onClick: stop(uninstall)
        }
      )))))
    );
  }
  PackContent.Location = PackContentLocation;
  css`.BA__packContent {
    position: relative;
    display: flex;
    flex-direction: column;
    min-height: 0;
}
.BA__packBadge {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 10;
}
.BA__packContentContainer {
    display: flex;
    flex-direction: column;
    padding: 16px;
    flex: 1;
    min-height: 0;
}
.BA__packContent .BA__packHeader {
    margin-bottom: 6px;
}
.BA__packDescription {
    word-break: break-word;
}
.BA__packContentSpacer {
    flex: 1;
}
.BA__packFooter {
    margin-top: 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
}
.BA__packMeta {
    display: flex;
    align-items: center;
    gap: 8px;
}
.BA__packActions {
    display: flex;
    align-items: center;
    gap: 8px;
}

.BA__packField {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 16px;
    padding: 8px 0;
}
.BA__packFieldInfo {
    flex: 1;
    min-width: 0;
    display: flex;
    align-items: center;
    gap: 12px;
}
.BA__packFieldInfo > * {
    flex-shrink: 0;
}
.BA__packFieldInfoContent {
    min-width: 0;
    flex: 1;
}
.BA__packFieldActions {
    display: flex;
    align-items: center;
    gap: 4px;
}
.BA__packAuthorAvatar,
.BA__packServerIcon {
    display: block;
    width: 48px;
    height: 48px;
    object-fit: cover;
    background-color: var(--background-base-low);
    border-radius: 0;
}
.BA__packAuthorAvatar {
    border-radius: 50%;
}
.BA__packVersion {
    opacity: .8;
    padding: 0 4px;
    display: inline-flex;
    align-items: center;
    gap: 2px;
    font-weight: 400;
}

.BA__packContent--sm .BA__packHeader {
    padding-right: 56px;
}
.BA__packContent--md .BA__packFooter {
    flex-direction: column;
    align-items: stretch;
}
.BA__packContent--md .BA__packDescription {
    overflow: hidden auto;
}``PackContent`;
  const ModuleContext = require$$0$1.createContext();
  function Block({ className, children: children2, relative, absolute, x, y, w, h, p, px, py, pt, pr, pb, pl, m, mx, my, mt, mr, mb, ml, bg, radius, style: style2, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        className,
        style: {
          position: relative ? "relative" : absolute ? "absolute" : void 0,
          top: y,
          left: x,
          width: w,
          height: h,
          paddingTop: pt ?? py ?? p,
          paddingRight: pr ?? px ?? p,
          paddingBottom: pb ?? py ?? p,
          paddingLeft: pl ?? px ?? p,
          marginTop: mt ?? my ?? m,
          marginRight: mr ?? mx ?? m,
          marginBottom: mb ?? my ?? m,
          marginLeft: ml ?? mx ?? m,
          background: bg && `var(--bap-${bg})`,
          borderRadius: radius,
          ...props,
          ...style2
        }
      },
      children2
    );
  }
  function Rect({ className, width, height, radius, color, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      Block,
      {
        ...props,
        className: classNames("BAP__rect", className),
        style: {
          width,
          height,
          borderRadius: radius,
          background: color && `var(--bap-${color})`
        }
      }
    );
  }
  function Text({ length, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      Rect,
      {
        ...props,
        className: "BAP__text",
        width: length
      }
    );
  }
  function Icon({ size, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      Rect,
      {
        ...props,
        className: "BAP__icon",
        width: size,
        height: size
      }
    );
  }
  function Divider$1({ vertical = false, length, ...props }) {
    const params = vertical ? { height: length } : { width: length };
    return /* @__PURE__ */ BdApi.React.createElement(
      Rect,
      {
        ...props,
        className: "BAP__divider",
        ...params
      }
    );
  }
  function Button({ color = "brand-primary", ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      Rect,
      {
        ...props,
        className: "BAP__button",
        color
      }
    );
  }
  css`.BAP__rect {
    background: var(--bap-text-primary);
    width: 20px;
    height: 20px;
    border-radius: 8px;
    flex-shrink: 0;
}
.BAP__text {
    width: 40px;
    height: 16px;
    border-radius: 999px;
}
.BAP__icon {
    width: 22px;
    height: 22px;
}
.BAP__divider {
    width: 1px;
    height: 1px;
    background: var(--bap-border-subtle);
}
.BAP__button {
    width: 80px;
    height: 30px;
    border-width: 1px !important;
    border-radius: 8px;
}``Preview: Rect`;
  function Flex({ className, children: children2, column, justify, align, wrap: wrap2, center, gap, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      Block,
      {
        ...props,
        className: classNames("BAP__flex", className),
        style: {
          flexDirection: column && "column",
          justifyContent: justify ?? (center && "center"),
          alignItems: align ?? (center && "center"),
          flexWrap: wrap2 && "wrap",
          gap
        }
      },
      children2
    );
  }
  css`.BAP__flex {
    display: flex;
    flex-shrink: 0;
    min-height: 0;
    min-width: 0;
}``Preview: Flex`;
  function SystemBar() {
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { relative: true, h: 32, justify: "flex-end" }, /* @__PURE__ */ BdApi.React.createElement(Flex, { absolute: true, inset: 0, center: true, gap: 8 }, /* @__PURE__ */ BdApi.React.createElement(Icon, { size: 20, radius: 4, color: "text-heading" }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 140, color: "text-heading" })), /* @__PURE__ */ BdApi.React.createElement(Flex, { align: "center", gap: 18, pr: 12 }, /* @__PURE__ */ BdApi.React.createElement(Icon, null), /* @__PURE__ */ BdApi.React.createElement(Icon, null)));
  }
  const PreviewContext = require$$0$1.createContext({
    store: null,
    id: null,
    modules: [],
    active: true,
    pack: null,
    animation: null,
    data: null,
    viewportRef: { current: null },
    serverListIconRefs: { current: [] },
    userPanelActionRefs: { current: [] },
    channelHeaderItemRefs: { current: [] },
    memberListItemRefs: { current: [] },
    serverList: {},
    setServerList: () => {
    },
    userPanel: {},
    setUserPanel: () => {
    },
    memberListShown: true,
    setMemberListShown: () => {
    },
    memberList: {},
    setMemberList: () => {
    },
    threadPopoutShown: false,
    setThreadPopoutShown: () => {
    }
  });
  function useModule$1(id) {
    const { id: activeId, modules: modules2, active } = require$$0$1.use(PreviewContext);
    return [modules2.find((m) => m.id === id), active && id === activeId];
  }
  function sfc32(a, b, c, d) {
    return () => {
      a |= 0;
      b |= 0;
      c |= 0;
      d |= 0;
      let t = (a + b | 0) + d | 0;
      d = d + 1 | 0;
      a = b ^ b >>> 9;
      b = c + (c << 3) | 0;
      c = c << 21 | c >>> 11;
      c = c + t | 0;
      return (t >>> 0) / 4294967296;
    };
  }
  function int(rng, min, max2) {
    return min + Math.floor(rng() * (max2 - min));
  }
  function stream(rng, count, fnOrMin, max2 = -1) {
    return Array(count).fill(null).map(
      typeof fnOrMin === "function" ? (_, i) => fnOrMin(rng, i) : () => int(rng, fnOrMin, max2)
    );
  }
  const STAGE_DEFAULT_DURATION = 500;
  function useStages(stages, isActive = true) {
    if (typeof stages === "number") stages = stages === Infinity ? new Proxy({ length: Infinity }, { get: (target, key2) => target[key2] ?? STAGE_DEFAULT_DURATION }) : Array(stages).fill(STAGE_DEFAULT_DURATION);
    const { store } = require$$0$1.use(PreviewContext);
    const [stage, setStage] = require$$0$1.useState(0);
    const timeoutId = require$$0$1.useRef();
    const callback = require$$0$1.useCallback(() => {
      clearTimeout(timeoutId.current);
      if (!isActive) return;
      timeoutId.current = setTimeout(
        () => setStage((stage2) => (stage2 + 1) % stages.length),
        stages[stage]
      );
    }, [stage, isActive]);
    require$$0$1.useEffect(() => store.watch((animations2) => {
      if (!animations2.length) callback();
    }), []);
    require$$0$1.useEffect(() => {
      const tid = setTimeout(() => {
        if (!store.animations.length) callback();
      }, 100);
      return () => clearTimeout(tid);
    }, [stage]);
    require$$0$1.useEffect(() => () => clearTimeout(timeoutId.current), []);
    return stage;
  }
  const infiniteThenable = { then() {
  } };
  function Suspender({ freeze, children: children2 }) {
    if (freeze) {
      throw infiniteThenable;
    }
    return /* @__PURE__ */ BdApi.React.createElement(require$$0$1.Fragment, null, children2);
  }
  function Freeze({ freeze, children: children2, placeholder = null, nodeRef }) {
    require$$0$1.useEffect(() => {
      if (freeze && nodeRef?.current) {
        nodeRef.current.style.display = "";
        [].forEach.call(nodeRef.current.children, (n) => n.style.display = "");
      }
    }, [freeze]);
    return /* @__PURE__ */ BdApi.React.createElement(require$$0$1.Suspense, { fallback: placeholder }, /* @__PURE__ */ BdApi.React.createElement(Suspender, { freeze }, children2));
  }
  function createAwaitableRef() {
    return new class {
      constructor() {
        this._current = null;
        this._callbacks = [];
      }
      get current() {
        return this._current;
      }
      set current(value) {
        this._current = value;
        this._callbacks.forEach((callback) => callback(value));
        this._callbacks = [];
      }
      await(callback) {
        this._callbacks.push(callback);
      }
    }();
  }
  function getRef$1(refLike) {
    return typeof refLike === "function" ? refLike() : "current" in (refLike ?? {}) ? refLike.current : refLike;
  }
  function isLazyLoaded(component) {
    return component._payload._status !== -1;
  }
  function loadLazy(component) {
    try {
      return Promise.resolve(
        component._init(component._payload)
        // Throws Promise or returns module
      );
    } catch (promise) {
      return promise;
    }
  }
  class Animation {
    constructor(store, { module: module2, data: data2, type, container, element: element2, viewport, window: window2, mouse, anchor, auto: auto2, doneCallbackRef, onError }) {
      this.store = store;
      this.module = module2;
      this.data = data2 ?? module2.animations[type];
      this.type = type;
      this.container = container;
      this.element = element2;
      this.viewport = viewport;
      this.window = window2;
      this.mouse = mouse;
      this.anchor = anchor;
      this.auto = auto2;
      this.doneCallbackRef = doneCallbackRef;
      this.onError = onError ?? ErrorManager.registerAnimationError;
      this.context = null;
      this.timeout = null;
      this.cancelled = false;
      this.cleared = false;
    }
    applyAttributes() {
      this.container.setAttribute("data-baa-type", this.type);
      if ("overflow" in (this.context ?? {})) this.container.setAttribute("data-baa-overflow", this.context.overflow);
      if (this.module.type) this.container.setAttribute(`data-baa-${this.module.type}`, "");
    }
    initialize(callback, allowed, intersectWith = null) {
      if (!allowed || !this.element || intersectWith && !intersectWith.instances || this.window.document.hidden) {
        this.doneCallbackRef.await((done) => {
          done?.();
          callback?.();
        });
        return false;
      }
      if (!intersectWith) {
        callback?.();
        if (this.cancelled) return false;
      }
      this.applyAttributes();
      const mouseAnchor = this.mouse.getAnchor();
      this.window.requestAnimationFrame(() => {
        if (this.cancelled) {
          if (intersectWith) callback?.();
          return;
        }
        const anchor = getRef$1(this.anchor);
        const { animate: animate2, context } = this.module.getAnimation(
          this.data,
          this.type,
          {
            auto: Object.assign(
              { mouse: mouseAnchor },
              this.auto?.current
            )
          },
          {
            instance: this,
            container: this.container,
            containerRect: getRect(this.container, this.viewport),
            element: this.element,
            viewport: this.viewport,
            window: this.window,
            document: this.window.document,
            mouse: this.mouse,
            anchor,
            anchorRect: isElement(anchor) ? getRect(anchor, this.viewport) : anchor,
            intersectWith,
            isIntersected: !!intersectWith,
            onError: this.onError
          }
        );
        this.context = context;
        const { wrapper, onBeforeBegin, accordion, instances, finished } = parse(animate2, context, this.module.buildOptions(this.data, this.type));
        this.wrapper = wrapper;
        this.accordion = accordion;
        this.instances = instances;
        if (intersectWith && callback) {
          callback(false);
          if (this.cancelled) return;
        }
        this.applyAttributes();
        onBeforeBegin?.();
        if (this.cancelled) return;
        if (wrapper) this.element.before(wrapper);
        this.ensureTimeLimit();
        finished.then(() => this.module.meta.waitUntilSafe ? this.store.untilSafe() : null).then(() => this.cancel());
      });
      return true;
    }
    cancel(dueToError = false, provideCallback = false) {
      if (this.cancelled) {
        if (dueToError) return this.callback?.();
        if (provideCallback) {
          this.destroy(dueToError);
          return this.callback;
        }
        return;
      }
      this.cancelled = true;
      this.onBeforeDestroy?.();
      this.instances?.pause();
      this.doneCallbackRef.current?.();
      const callback = (revert = true) => {
        if (this.cleared) return;
        this.cleared = true;
        this.wrapper?.remove();
        [].filter.call(this.container.attributes, (a) => a.name?.startsWith("data-baa")).forEach((a) => this.container.removeAttribute(a.name));
        if (revert && ((this.context?.module.meta.revert ?? true) || this.context?.meta.revert)) this.instances?.revert();
        else this.instances?.cancel();
        this.destroy(dueToError);
        this.onDestroyed?.();
      };
      if (dueToError) return callback();
      if (provideCallback) {
        this.destroy(dueToError);
        return callback;
      }
      this.callback = callback;
    }
    computeTimeLimit() {
      return 5e3 + (this.context.duration ?? 0);
    }
    ensureTimeLimit(limit = this.computeTimeLimit()) {
      this.timeout = this.window.setTimeout(() => {
        const { animation, module: module2, pack, type, onError } = this.context;
        onError(
          new AnimationError(
            animation,
            `Animation exceeded the execution time limit (${(limit / 1e3).toFixed(1)}s)`,
            { module: module2, pack, type, context: this.context }
          )
        );
        this.cancel(true);
      }, limit);
    }
    destroy(dueToError = false) {
      this.window.clearTimeout(this.timeout);
      this.store.destroyAnimation(this, dueToError);
    }
  }
  let AnimationStore$2 = class AnimationStore {
    get name() {
      return "AnimationStore";
    }
    get switchCooldownDuration() {
      return 1e3;
    }
    constructor() {
      this.animations = [];
      this.switchCooldownUntil = 0;
      this.shouldPauseEmitter = false;
      this.shouldInterceptEvents = false;
      this.isSafe = true;
      this._watchers = [];
      this.onDocumentVisibilityChange = () => {
        if (document.hidden) {
          engine.pause();
          this.cancelAllAnimations();
        } else {
          engine.resume();
          this.trigger();
        }
      };
    }
    initialize() {
      document.addEventListener("visibilitychange", this.onDocumentVisibilityChange);
    }
    shutdown() {
      document.removeEventListener("visibilitychange", this.onDocumentVisibilityChange);
      this.cancelAllAnimations();
    }
    cooldown() {
      this.switchCooldownUntil = Date.now() + this.switchCooldownDuration;
    }
    isCooldown() {
      return this.switchCooldownUntil > Date.now();
    }
    cancelAnimations(animations2, provideCallback = true) {
      const list = typeof animations2 === "function" ? this.animations.filter(animations2) : [].concat(animations2);
      const callbacks = list.map((animation) => animation.cancel(false, provideCallback)).filter((c) => typeof c === "function");
      const callback = (...args) => callbacks.forEach((c) => c(...args));
      if (provideCallback) return callback;
      else callback();
    }
    cancelAllAnimations() {
      return this.cancelAnimations(this.animations, false);
    }
    processAnimation(animation) {
      switch (animation.module.type) {
        case ModuleType.Reveal:
          const [conflict] = this.animations.filter((a) => a.module.id === animation.module.id && a.element === animation.element);
          const intersect2 = (animation.data?.id ?? null) === (conflict?.data?.id ?? null) && (!animation.data?.id || animation.data.meta?.intersect);
          return [this.cancelAnimations(conflict ?? []), true, intersect2 ? conflict : null];
        case ModuleType.Switch: {
          if (this.isCooldown()) {
            this.cooldown();
            return [() => {
            }, false];
          }
          const conflicts = this.animations.filter((a) => a.module.type === ModuleType.Switch);
          const isOverload = conflicts.some((a) => a.type === animation.type);
          if (!isOverload) return [() => {
          }, true];
          this.cooldown();
          return [this.cancelAnimations(conflicts), false];
        }
      }
    }
    requestAnimation(payload) {
      const animation = new Animation(this, payload);
      const [callback, allowed, intersectWith = null] = this.processAnimation(animation);
      if (!animation.initialize(callback, allowed, intersectWith)) return null;
      this.animations.push(animation);
      this.trigger();
      return animation;
    }
    destroyAnimation(animation, dueToError = false) {
      if (dueToError && animation.module.type === ModuleType.Switch) {
        this.cooldown();
        this.cancelAnimations(this.animations.filter((a) => a.module.type === ModuleType.Switch), false);
      }
      this.removeAnimation(animation);
    }
    removeAnimation(animation) {
      const index2 = this.animations.indexOf(animation);
      if (index2 === -1) return;
      this.animations.splice(index2, 1);
      this.trigger();
    }
    watch(callback) {
      this._watchers.push(callback);
      return () => this._watchers = this._watchers.filter((c) => c !== callback);
    }
    onceSafe(callback) {
      const unwatch = this.watch((animations2, isSafe) => {
        if (!isSafe) return;
        unwatch();
        callback();
      });
      return unwatch;
    }
    untilSafe() {
      return new Promise((resolve) => {
        if (this.isSafe) return resolve();
        this.onceSafe(resolve);
      });
    }
    trigger() {
      this.shouldPauseEmitter = this.animations.some((a) => a.module.type === ModuleType.Switch);
      this.shouldInterceptEvents = this.animations.some((a) => a.module.interceptEvents);
      this.isSafe = !this.animations.some((a) => a.module.type === ModuleType.Switch);
      this._watchers.forEach((callback) => {
        try {
          callback([...this.animations], this.isSafe);
        } catch (error2) {
          Logger.warn(this.name, `Watcher threw an error:`, error2);
        }
      });
    }
  };
  new AnimationStore$2();
  class AnimationStore extends AnimationStore$2 {
    get switchCooldownDuration() {
      return Config.current.general.switchCooldownDuration;
    }
  }
  const AnimationStore$1 = new AnimationStore();
  function AnimeContainer({ ref, id = "", container, children: children2 }) {
    if (!container) return children2;
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        ref,
        "data-ba-container": id,
        ...container
      },
      children2
    );
  }
  function directChild(node) {
    return node && [].find.call(node.children, (e) => !e.getAttribute("data-baa"));
  }
  function pass(props = null) {
    return (e) => require$$0$1.cloneElement(e, props);
  }
  function passAuto(auto2) {
    return pass({ auto: auto2 });
  }
  class Mouse {
    get name() {
      return "Mouse";
    }
    constructor({ x, y } = { x: -1, y: -1 }) {
      this.x = x;
      this.y = y;
      this.onMouseMove = (e) => {
        this.x = e.clientX;
        this.y = e.clientY;
      };
    }
    getAnchor() {
      return {
        x: this.x,
        y: this.y,
        width: 0,
        height: 0
      };
    }
    initialize() {
      if (this.x === -1 && this.y === -1) {
        this.x = window.innerWidth / 2;
        this.y = window.innerHeight / 2;
      }
      document.addEventListener("mousemove", this.onMouseMove);
      Logger.info(this.name, "Initialized.");
      return this;
    }
    shutdown() {
      document.removeEventListener("mousemove", this.onMouseMove);
      Logger.info(this.name, "Shutdown.");
      return this;
    }
  }
  const Mouse$1 = new Mouse();
  const getRef = (ref) => typeof ref === "function" ? ref() : ref.current;
  const injectContainerRefFn = (children2, ref) => {
    if (children2?.props) children2.props.ref = ref;
  };
  const AnimeTransitionContext = require$$0$1.createContext({
    isEnterActive: false,
    isExitActive: false,
    isActive: false,
    state: null,
    module: null,
    instance: require$$0$1.createRef(),
    nodeRef: require$$0$1.createRef(),
    props: null,
    data: {},
    tree: []
  });
  class AnimeTransition extends require$$0$1.Component {
    static contextType = AnimeTransitionContext;
    static defaultProps = {
      container: false,
      freeze: false,
      mountOnEnter: true,
      unmountOnExit: true,
      enter: true,
      exit: true,
      injectContainerRef: false
    };
    constructor(props) {
      super(props);
      this.doneCallback = createAwaitableRef();
      this.containerRef = require$$0$1.createRef();
      this.instance = require$$0$1.createRef();
      this.data = {
        emoji: { 1: 0, 2: 0 }
      };
      const self2 = this;
      this.nodeRef = {
        get current() {
          if (self2.props.containerRef) return getRef(self2.props.containerRef);
          if (self2.props.layerRef) return getRef(self2.props.layerRef)?.elementRef.current;
          return self2.containerRef.current;
        }
      };
    }
    get mouse() {
      return this.props.mouse ?? Mouse$1;
    }
    get store() {
      return this.props.store ?? AnimationStore$1;
    }
    clearCurrentInstance() {
      this.instance.current?.cancel(false, true)?.();
    }
    componentWillUnmount() {
      this.clearCurrentInstance();
    }
    onAnimate(type, fn) {
      return () => {
        const container = this.nodeRef.current;
        container?.setAttribute("data-ba-container", this.props.module.id);
        if (this.props.defaultLayoutStyles === false) container?.setAttribute("data-ba-default-layout-styles", "false");
        this.instance.current = this.store.requestAnimation({
          module: this.props.module,
          data: this.props.data?.[type],
          type,
          container,
          element: directChild(container),
          viewport: this.props.viewportRef?.current,
          window,
          mouse: this.mouse,
          anchor: this.props.anchor,
          auto: this.props.autoRef ?? { current: this.props.auto },
          doneCallbackRef: this.doneCallback,
          onError: this.props.onError ?? ErrorManager.registerAnimationError
        });
        fn?.();
      };
    }
    onCallback(fn) {
      return () => {
        this.clearCurrentInstance();
        fn?.();
      };
    }
    provideContext(state, children2) {
      const isEnterActive = state === Transition.EXITED && this.props.in || state === Transition.ENTERING;
      const isExitActive = state === Transition.ENTERED && !this.props.in || state === Transition.EXITING;
      const isActive = isEnterActive || isExitActive;
      const current = {
        isEnterActive,
        isExitActive,
        isActive,
        state,
        module: this.props.module,
        instance: this.instance,
        nodeRef: this.nodeRef,
        props: this.props,
        data: this.data
      };
      const value = {
        ...isActive ? current : this.context,
        tree: [current, ...this.context.tree]
      };
      return /* @__PURE__ */ BdApi.React.createElement(AnimeTransitionContext, { value }, children2);
    }
    render() {
      const {
        module: module2,
        data: data2,
        children: children2,
        container,
        freeze,
        mountOnEnter,
        unmountOnExit,
        enter,
        exit,
        injectContainerRef: injectContainerRef2,
        onEntering,
        onExiting,
        onEntered,
        onExited,
        ...props
      } = this.props;
      const contents = (state = null) => {
        const _children = typeof children2 === "function" ? children2(state) : children2;
        if (injectContainerRef2) {
          (typeof injectContainerRef2 === "function" ? injectContainerRef2 : injectContainerRefFn)(_children, this.containerRef);
        }
        return this.provideContext(
          state,
          /* @__PURE__ */ BdApi.React.createElement(
            AnimeContainer,
            {
              ref: this.containerRef,
              id: module2.id,
              container: children2 && container
            },
            /* @__PURE__ */ BdApi.React.createElement(Freeze, { freeze: freeze && props.in === false, nodeRef: this.nodeRef }, _children)
          )
        );
      };
      return /* @__PURE__ */ BdApi.React.createElement(
        Transition,
        {
          ...props,
          nodeRef: this.nodeRef,
          enter: (data2 != null || module2.isEnabled(AnimationType.Enter)) && enter,
          exit: (data2 != null || module2.isEnabled(AnimationType.Exit)) && exit,
          mountOnEnter,
          unmountOnExit,
          onEntering: this.onAnimate(AnimationType.Enter, onEntering),
          onExiting: this.onAnimate(AnimationType.Exit, onExiting),
          onEntered: this.onCallback(onEntered),
          onExited: this.onCallback(onExited),
          addEndListener: (done) => this.doneCallback.current = done
        },
        contents
      );
    }
  }
  css`[data-ba-container][data-baa-type], /* Animating Container */
[data-ba-container][data-baa-type] > :not([data-baa]) { /* Animating Element */
    isolation: isolate;
}
[data-ba-container][data-baa-type]:not([data-ba-default-layout-styles="false"]) {
    position: relative;
}

[data-baa] {
    display: contents;
}
[data-baa] > * {
    position: absolute;
}

[data-ba-container][data-baa-overflow="false"] {
    overflow: clip;
}
[data-baa-type="exit"] {
    pointer-events: none;
}

[data-ba-container][data-baa-switch][data-baa-type="exit"] {
    z-index: 1;
}
[data-ba-container][data-baa-switch][data-baa-type="exit"]:not([data-ba-default-layout-styles="false"]) { /* Exiting switch container */
    position: absolute !important;
    inset: 0;
}``AnimeTransition`;
  function useMouse({ x, y } = {}) {
    const { viewportRef } = require$$0$1.use(PreviewContext);
    x ??= (viewportRef.current?.offsetWidth ?? 0) / 2;
    y ??= (viewportRef.current?.offsetHeight ?? 0) / 2;
    const mouse = require$$0$1.useMemo(() => new Mouse({ x, y }), []);
    require$$0$1.useEffect(() => {
      mouse.x = x;
      mouse.y = y;
    }, [x, y]);
    return mouse;
  }
  function PreviewTransition({ module: module2, anchor, ...props }) {
    const { store, id, data: data2, viewportRef, onError } = require$$0$1.use(PreviewContext);
    const [mouseCoords, setMouseCoords] = require$$0$1.useState();
    const mouse = useMouse(mouseCoords);
    const onStart = () => {
      const anchorRef = getRef$1(anchor);
      if (!anchorRef || !viewportRef.current) return setMouseCoords(void 0);
      const [x, y] = getCenter(getRect(anchorRef, viewportRef.current));
      setMouseCoords({ x, y });
    };
    return /* @__PURE__ */ BdApi.React.createElement(
      AnimeTransition,
      {
        store,
        module: module2,
        data: module2.id === id ? data2 : void 0,
        mouse,
        viewportRef,
        anchor,
        onEntering: onStart,
        onExiting: onStart,
        onError,
        ...props
      }
    );
  }
  function generateMessage(rng, key2 = null) {
    return {
      key: key2,
      username: int(rng, 60, 128),
      rows: stream(
        rng,
        int(rng, 1, 4),
        () => stream(rng, int(rng, 3, 8), 30, 80)
      ),
      embed: rng() < 0.3 ? [int(rng, 140, 400), int(rng, 100, 240)] : null
    };
  }
  function generateMessageStream(rng, count) {
    return stream(rng, count, generateMessage);
  }
  function Message({ username = 40, rows = [], embed = null }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__message" }, /* @__PURE__ */ BdApi.React.createElement(Icon, { size: 40, radius: "50%" }), /* @__PURE__ */ BdApi.React.createElement(Flex, { flex: 1, column: true, align: "flex-start", gap: 6 }, /* @__PURE__ */ BdApi.React.createElement(Text, { length: username, color: "text-heading" }), rows.map((columns, i) => /* @__PURE__ */ BdApi.React.createElement(Flex, { key: i, gap: "6px 4px", wrap: true }, columns.map((length, i2) => /* @__PURE__ */ BdApi.React.createElement(Text, { key: i2, length })))), embed && /* @__PURE__ */ BdApi.React.createElement(Block, { w: embed[0], h: embed[1], maxWidth: "100%", radius: 8, bg: "text-primary" })));
  }
  function Chat({ messages, rng }) {
    const [module2, isActive] = useModule$1(ModuleKey.Messages);
    const [data2, setData] = require$$0$1.useState(messages);
    require$$0$1.useEffect(() => setData(messages), [messages]);
    const stage = useStages(Infinity, isActive);
    require$$0$1.useEffect(() => {
      if (stage === 0) return;
      setData((data22) => {
        if (rng() < 0.2) {
          const index2 = data22.length - int(rng, 1, 4);
          return data22.slice(0, index2).concat(data22.slice(index2 + 1));
        }
        return data22.slice(-10).concat(generateMessage(rng, messages.length + stage));
      });
    }, [stage]);
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { flex: 1, column: true, bg: "background-secondary" }, /* @__PURE__ */ BdApi.React.createElement(Block, { relative: true, flex: 1, overflow: "hidden" }, /* @__PURE__ */ BdApi.React.createElement(Flex, { className: "BAP__messages", flex: 1, column: true }, /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null }, data2.map(({ key: key2, ...props }, i) => /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        key: key2,
        container: { className: "BAP__messageContainer" },
        module: module2,
        enter: i > 1,
        exit: i > 1
      },
      /* @__PURE__ */ BdApi.React.createElement(Message, { ...props })
    ))))), /* @__PURE__ */ BdApi.React.createElement(Block, { px: 8, pb: 24, mt: -4, bg: "background-secondary" }, /* @__PURE__ */ BdApi.React.createElement(Block, { h: 50, bg: "background-primary", radius: 8, borderWidth: 1 })));
  }
  const Chat$1 = require$$0$1.memo(Chat);
  css`.BAP__messages {
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    padding-right: 16px;
    padding-bottom: 16px;
    box-sizing: border-box !important;
}
.BAP__messageContainer {
    margin-top: 16px;
}
.BAP__message {
    display: flex;
    gap: 16px;
    padding: 4px 0 2px 16px;
}``Preview: Chat`;
  const chat = {
    main: () => {
      const rng = sfc32(450181629, 238323892, 206681137, 215170589);
      return { rng, messages: generateMessageStream(rng, 8) };
    },
    alt: () => {
      const rng = sfc32(3849863118, 865888779, 2963917516, 814392167);
      return { rng, messages: generateMessageStream(rng, 5) };
    },
    tertiary: () => {
      const rng = sfc32(243164468, 1892646852, 3229717884, 3028721673);
      return { rng, messages: generateMessageStream(rng, 5) };
    }
  };
  const memberList = {
    main: () => ({
      sections: [
        {
          length: 55,
          items: [
            { length: 150 },
            { length: 92 },
            { length: 122 }
          ]
        },
        {
          length: 130,
          items: [
            { length: 102 },
            { length: 92 },
            { length: 122 },
            { length: 58 },
            { length: 138 }
          ]
        },
        {
          length: 96,
          items: [
            { length: 70 },
            { length: 135 },
            { length: 122 },
            { length: 144 },
            { length: 130 }
          ]
        }
      ]
    }),
    alt: () => ({
      sections: [
        {
          length: 115,
          items: [
            { length: 61 },
            { length: 91 },
            { length: 75 },
            { length: 137 },
            { length: 109 }
          ]
        },
        {
          length: 90,
          items: [
            { length: 98 },
            { length: 114 },
            { length: 86 },
            { length: 126 },
            { length: 133 },
            { length: 120 },
            { length: 54 },
            { length: 98 },
            { length: 126 }
          ]
        }
      ]
    })
  };
  const channel = {
    main: () => ({
      header: { name: 60, description: 282 },
      chat: chat.main(),
      memberList: memberList.main()
    }),
    alt: () => ({
      header: { name: 182, description: 176 },
      chat: chat.alt(),
      memberList: memberList.alt()
    })
  };
  const thread = {
    main: () => ({
      header: { name: 103 },
      chat: chat.alt()
    }),
    alt: () => ({
      header: { name: 143 },
      chat: chat.tertiary()
    })
  };
  const channelList = {
    main: () => ({
      name: 140,
      items: [
        { type: "channel", length: 126 },
        { type: "channel", length: 63 },
        { type: "section", length: 77 },
        { type: "channel", length: 37 },
        { type: "channel", length: 124 },
        { type: "channel", length: 83 },
        { type: "channel", length: 111 },
        { type: "section", length: 136 },
        { type: "channel", length: 143 },
        { type: "channel", length: 111 },
        { type: "channel", length: 123 },
        { type: "channel", length: 162 },
        { type: "channel", length: 83 },
        { type: "channel", length: 103 },
        { type: "section", length: 83 },
        { type: "channel", length: 124 },
        { type: "channel", length: 80 }
      ],
      active: 4
    }),
    alt: () => ({
      name: 67,
      items: [
        { type: "channel", length: 37 },
        { type: "channel", length: 111 },
        { type: "channel", length: 63 },
        { type: "section", length: 54 },
        { type: "channel", length: 58 },
        { type: "channel", length: 159 },
        { type: "channel", length: 87 },
        { type: "channel", length: 72 },
        { type: "channel", length: 125 },
        { type: "section", length: 127 },
        { type: "channel", length: 82 },
        { type: "channel", length: 154 },
        { type: "channel", length: 100 },
        { type: "section", length: 77 },
        { type: "channel", length: 125 },
        { type: "channel", length: 72 }
      ],
      active: 7
    })
  };
  const server = {
    main: () => ({
      channelList: channelList.main(),
      channel: channel.main()
    }),
    alt: () => ({
      channelList: channelList.alt(),
      channel: channel.alt()
    })
  };
  function ServerList({ active = -1, hover = -1, iconRefs = require$$0$1.use(PreviewContext).serverListIconRefs }) {
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { w: 72, column: true, align: "center", gap: 8, mb: 64, bg: "background-tertiary", overflow: "hidden" }, /* @__PURE__ */ BdApi.React.createElement(Icon, { size: 40, radius: 12 }), /* @__PURE__ */ BdApi.React.createElement(Divider$1, { length: 32 }), Array(13).fill(null).map((_, i) => /* @__PURE__ */ BdApi.React.createElement(Flex, { key: i, center: true, w: "100%", relative: true }, /* @__PURE__ */ BdApi.React.createElement("div", { className: classNames({
      "BAP__serverPill": true,
      "BAP__serverPill--hover": i === hover,
      "BAP__serverPill--active": i === active
    }) }), /* @__PURE__ */ BdApi.React.createElement("div", { ref: (ref) => {
      iconRefs.current[i] = ref;
    } }, /* @__PURE__ */ BdApi.React.createElement(Icon, { size: 40, radius: 12 })))));
  }
  css`.BAP__serverPill {
    position: absolute;
    top: 50%;
    left: 0;
    transform: translateY(-50%);
    width: 4px;
    height: 20px;
    border-radius: 0 5px 5px 0;
    background-color: var(--bap-white);
    transform-origin: 0 0;
    opacity: 0;
    scale: .5;
    transition: opacity .2s, scale .2s, height .2s;
}
.BAP__serverPill--hover, .BAP__serverPill--active {
    opacity: 1;
    scale: 1;
}
.BAP__serverPill--active {
    height: 40px;
}``Preview: ServerList`;
  function ChevronIcon({ size = 20, color = "var(--bap-text-heading)" }) {
    return /* @__PURE__ */ BdApi.React.createElement("svg", { width: size, height: size, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ BdApi.React.createElement(
      "path",
      {
        d: "M4.41691 7.74999C4.57268 7.5973 4.78211 7.51177 5.00024 7.51177C5.21837 7.51177 5.4278 7.5973 5.58358 7.74999L10.0002 12.1583L14.4169 7.74165C14.4922 7.65499 14.5847 7.58484 14.6884 7.53559C14.7921 7.48634 14.9049 7.45906 15.0197 7.45546C15.1345 7.45186 15.2488 7.47202 15.3554 7.51467C15.462 7.55732 15.5586 7.62155 15.6392 7.70332C15.7199 7.78509 15.7827 7.88264 15.8238 7.98985C15.865 8.09705 15.8835 8.2116 15.8783 8.32631C15.8731 8.44102 15.8442 8.55342 15.7935 8.65644C15.7428 8.75946 15.6713 8.85089 15.5836 8.92499L10.5836 13.925C10.4278 14.0777 10.2184 14.1632 10.0002 14.1632C9.78211 14.1632 9.57268 14.0777 9.41691 13.925L4.41691 8.92499C4.3388 8.84752 4.27681 8.75535 4.2345 8.6538C4.19219 8.55225 4.17041 8.44333 4.17041 8.33332C4.17041 8.22331 4.19219 8.11439 4.2345 8.01284C4.27681 7.91129 4.3388 7.81912 4.41691 7.74165V7.74999Z",
        fill: color
      }
    ));
  }
  function ChannelHeader({ name: name2, description, items: items2 = [0, 0, 0, 1], itemRefs = require$$0$1.useRef([]), search = true }) {
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { h: 48, pl: 21, pr: 8, justify: "space-between", borderBottomWidth: 1, bg: "background-secondary" }, /* @__PURE__ */ BdApi.React.createElement(Flex, { relative: true, align: "center", gap: 8, flex: 1, overflow: "hidden" }, /* @__PURE__ */ BdApi.React.createElement(Icon, { color: "text-heading" }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: name2, color: "text-heading" }), description && /* @__PURE__ */ BdApi.React.createElement(Text, { length: description }), /* @__PURE__ */ BdApi.React.createElement(
      Block,
      {
        absolute: true,
        top: 0,
        right: 0,
        bottom: 0,
        w: 8,
        background: "linear-gradient(to right, transparent, var(--bap-background-secondary))"
      }
    )), /* @__PURE__ */ BdApi.React.createElement(Flex, { pl: 8, align: "center", gap: 18 }, items2.map((active, i) => /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        key: i,
        ref: (ref) => {
          itemRefs.current[i] = ref;
        },
        className: classNames({
          "BAP__channelHeaderItem": true,
          "BAP__channelHeaderItem--active": active
        })
      }
    )), search && /* @__PURE__ */ BdApi.React.createElement(Block, { w: 244, h: 32, radius: 8, bg: "background-secondary-alt", borderWidth: 1 })));
  }
  function MemberListItem({ ref, active = false, length }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        ref,
        className: classNames({
          "BAP__memberListItem": true,
          "BAP__memberListItem--active": active
        })
      },
      /* @__PURE__ */ BdApi.React.createElement(Icon, { size: 32, radius: "50%", color: active && "text-heading" }),
      /* @__PURE__ */ BdApi.React.createElement(Text, { length, color: active && "text-heading" })
    );
  }
  function MemberList({ sections = [], itemRefs = require$$0$1.useRef([]), active = -1 }) {
    const { memberListShown, setMemberListShown } = require$$0$1.use(PreviewContext);
    const [module2, isActive] = useModule$1(ModuleKey.MembersSidebar);
    const stage = useStages(2, isActive);
    const mouse = useMouse({ x: 997, y: 57 });
    require$$0$1.useEffect(() => {
      if (isActive) setMemberListShown(!stage, true);
    }, [stage]);
    return /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        in: memberListShown,
        container: { className: "BAP__sidebar" },
        module: module2,
        mouse
      },
      /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__memberList" }, sections.map(({ length, items: items2 = [] }, i) => /* @__PURE__ */ BdApi.React.createElement(Flex, { key: i, column: true, gap: 2 }, /* @__PURE__ */ BdApi.React.createElement(Flex, { px: 8, pb: 4 }, /* @__PURE__ */ BdApi.React.createElement(Text, { length, height: 12 })), items2.map((props, j) => {
        const index2 = sections.slice(0, i).reduce((n, s) => n + s.items.length, 0) + j;
        return /* @__PURE__ */ BdApi.React.createElement(
          MemberListItem,
          {
            key: j,
            ref: (ref) => {
              itemRefs.current[index2] = ref;
            },
            active: index2 === active,
            ...props
          }
        );
      }))))
    );
  }
  function ThreadSidebar() {
    const { setMemberListShown } = require$$0$1.use(PreviewContext);
    const data2 = require$$0$1.useMemo(() => [thread.main(), thread.alt()], []);
    const [module2, isActive] = useModule$1(ModuleKey.ThreadSidebar);
    const [switchModule, isSwitchActive] = useModule$1(ModuleKey.ThreadSidebarSwitch);
    const stage = useStages(2, isActive || isSwitchActive);
    const key2 = isSwitchActive ? stage : 0;
    require$$0$1.useEffect(() => {
      if (isActive) setMemberListShown(!stage, !!stage);
    }, [stage]);
    if (!isActive && !isSwitchActive) return null;
    return /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        in: !!stage || isSwitchActive,
        container: { className: "BAP__sidebar" },
        module: module2
      },
      /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null }, /* @__PURE__ */ BdApi.React.createElement(
        PreviewTransition,
        {
          key: key2,
          container: { className: "BAP__sidebar" },
          module: switchModule
        },
        /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__threadSidebar" }, /* @__PURE__ */ BdApi.React.createElement(Block, { w: 8 }), /* @__PURE__ */ BdApi.React.createElement(Flex, { className: "BAP__threadSidebarContents" }, /* @__PURE__ */ BdApi.React.createElement(ChannelHeader, { ...data2[key2].header, items: [0, 0, 0], search: false }), /* @__PURE__ */ BdApi.React.createElement(Chat$1, { ...data2[key2].chat })))
      ))
    );
  }
  function Channel({ header, chat: chat2, memberList: memberList2 }) {
    const {
      channelHeaderItemRefs,
      memberListItemRefs,
      memberListShown,
      memberList: memberListOverrides,
      threadPopoutShown
    } = require$$0$1.use(PreviewContext);
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__channel" }, /* @__PURE__ */ BdApi.React.createElement(Flex, { className: "BAP__channelContents" }, /* @__PURE__ */ BdApi.React.createElement(
      ChannelHeader,
      {
        ...header,
        items: [threadPopoutShown, 0, 0, memberListShown],
        itemRefs: channelHeaderItemRefs
      }
    ), /* @__PURE__ */ BdApi.React.createElement(Flex, { align: "stretch", flex: 1 }, /* @__PURE__ */ BdApi.React.createElement(Chat$1, { ...chat2 }), /* @__PURE__ */ BdApi.React.createElement(
      MemberList,
      {
        ...memberList2,
        ...memberListOverrides,
        itemRefs: memberListItemRefs
      }
    ))), /* @__PURE__ */ BdApi.React.createElement(ThreadSidebar, null));
  }
  css`.BAP__channel {
    display: flex;
    align-items: stretch;
    flex: 1;
    min-width: 0;
}
.BAP__channelContents {
    flex: 1;
    display: flex;
    flex-direction: column;
    background-color: var(--bap-background-tertiary);
    border-top-width: 1px !important;
    overflow: clip;
}
.BAP__sidebar {
    position: relative;
    isolation: isolate;
    display: flex;
    flex-direction: column;
    height: 100%;
}
.BAP__memberList {
    width: 247px;
    padding: 20px 8px;
    background-color: var(--bap-background-secondary);
    display: flex;
    flex-direction: column;
    gap: 20px;
    border-left-width: 1px !important;
    overflow: hidden;
}
.BAP__memberListItem {
    display: flex;
    align-items: center;
    padding: 4px 16px;
    gap: 12px;
    border-radius: 8px;
}
.BAP__memberListItem--active {
    background-color: var(--bap-background-primary);
}
.BAP__threadSidebar {
    width: 458px;
    display: flex;
    align-items: stretch;
    height: 100%;
}
.BAP__threadSidebarContents {
    flex: 1;
    display: flex;
    flex-direction: column;
    border-top-width: 1px !important;
    border-left-width: 1px !important;
    border-radius: 8px 0 0 8px;
    overflow: clip;
}
.BAP__channel:has(.BAP__threadSidebar) .BAP__channelContents {
    border-right-width: 1px !important;
    border-radius: 0 8px 8px 0;
}
.BAP__channelHeaderItem {
    width: 22px;
    height: 22px;
    border-radius: 8px;
    background-color: var(--bap-text-primary);
}
.BAP__channelHeaderItem--active {
    background-color: var(--bap-text-heading);
}``Preview: Channel`;
  function ChannelListItem({ active = false, length }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__channelListItem" }, /* @__PURE__ */ BdApi.React.createElement(Flex, { px: 8, align: "center", gap: 8, radius: 4, flex: 1, bg: active && "background-primary" }, /* @__PURE__ */ BdApi.React.createElement(Icon, { size: 19, color: active && "text-heading" }), /* @__PURE__ */ BdApi.React.createElement(Text, { length, color: active && "text-heading" })));
  }
  function ChannelListSection({ active, length }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      Flex,
      {
        className: classNames({
          "BAP__channelListSection": true,
          "BAP__channelListSection--active": active
        })
      },
      /* @__PURE__ */ BdApi.React.createElement(Flex, { h: 24, px: 16, align: "center", gap: 4, flex: 1 }, /* @__PURE__ */ BdApi.React.createElement(Text, { length, height: 12 }), active != null && /* @__PURE__ */ BdApi.React.createElement(ChevronIcon, null))
    );
  }
  function ChannelList({ name: name2, items: items2 = [], active = -1 }) {
    const [module2, isActive] = useModule$1(ModuleKey.ChannelList);
    const stage = useStages(4, isActive);
    const sectionIndexes = require$$0$1.useMemo(
      () => items2.map(({ type }, i) => type === "section" ? i : -1).filter((i) => i !== -1).concat(items2.length),
      [items2]
    );
    const hiddenSections = require$$0$1.useMemo(
      () => [0, 1].slice(Math.max(0, stage - 2), stage),
      [stage]
    );
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { className: "BAP__channelList" }, /* @__PURE__ */ BdApi.React.createElement(Flex, { h: 48, align: "center", px: 14, borderBottomWidth: 1 }, /* @__PURE__ */ BdApi.React.createElement(Text, { length: name2, color: "text-heading" })), /* @__PURE__ */ BdApi.React.createElement(Flex, { column: true, py: 12, pr: 8, flex: 1 }, /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null }, items2.map(({ type, ...props }, i) => {
      if (type === "section") return /* @__PURE__ */ BdApi.React.createElement(
        ChannelListSection,
        {
          key: i,
          active: isActive ? !hiddenSections.some((s) => i === sectionIndexes[s]) : null,
          ...props
        }
      );
      if (hiddenSections.some((j) => i >= sectionIndexes[j] && i < sectionIndexes[j + 1]) && i !== active) return null;
      return /* @__PURE__ */ BdApi.React.createElement(
        PreviewTransition,
        {
          key: i,
          container: { className: "BAP__channelListItemContainer" },
          module: module2
        },
        /* @__PURE__ */ BdApi.React.createElement(
          ChannelListItem,
          {
            active: i === active,
            ...props
          }
        )
      );
    }))));
  }
  function Server({ channelList: channelList2, channel: channel$1 }) {
    const [module2, isActive] = useModule$1(ModuleKey.Channels);
    const data2 = require$$0$1.useMemo(
      () => !isActive ? [channel$1, channel$1] : [channel.main(), channel.alt()],
      [channel$1]
    );
    const stage = useStages(2, isActive);
    const auto2 = { direction: stage };
    const mouse = useMouse({
      x: 207,
      y: stage ? 463 : 253
    });
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__server" }, /* @__PURE__ */ BdApi.React.createElement(
      ChannelList,
      {
        ...channelList2,
        active: isActive ? stage ? 10 : 4 : channelList2.active
      }
    ), /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { className: "BAP__page", childFactory: passAuto(auto2) }, /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        key: stage,
        container: { className: "BAP__page" },
        module: module2,
        auto: auto2,
        mouse
      },
      /* @__PURE__ */ BdApi.React.createElement(Channel, { ...data2[stage] })
    )));
  }
  css`.BAP__server {
    display: flex;
    align-items: stretch;
    flex: 1;
    min-width: 0;
}
.BAP__channelList {
    display: flex;
    flex-direction: column;
    width: 268px;
    padding-bottom: 64px;
    border-top-width: 1px !important;
    border-left-width: 1px !important;
    border-top-left-radius: 12px;
    background-color: var(--bap-background-tertiary);
    overflow: hidden;
}
.BAP__channelListSection {
    height: 40px;
    display: flex;
    align-items: flex-end;
}
.BAP__channelListSection svg {
    transition: .2s transform;
    transform: rotate(-90deg);
}
.BAP__channelListSection--active svg {
    transform: rotate(0);
}
.BAP__channelListItem {
    display: flex;
    align-items: stretch;
    height: 32px;
    margin-left: 8px;
    padding: 1px 0;
}
.BAP__page {
    position: relative;
    isolation: isolate;
    display: flex;
    align-items: stretch;
    flex: 1;
    min-width: 0;
}``Preview: Server`;
  function UserPanel({ active = -1, actionRefs = require$$0$1.use(PreviewContext).userPanelActionRefs }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__userPanelContainer" }, /* @__PURE__ */ BdApi.React.createElement(Flex, { className: "BAP__userPanel", justify: "space-between", align: "center" }, /* @__PURE__ */ BdApi.React.createElement(Flex, { align: "center", gap: 10 }, /* @__PURE__ */ BdApi.React.createElement(Icon, { size: 40, radius: "50%" }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 100 })), /* @__PURE__ */ BdApi.React.createElement(Flex, null, Array(3).fill(null).map((_, i) => /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        ref: (ref) => {
          actionRefs.current[i] = ref;
        },
        key: i,
        className: classNames(
          "BAP__userPanelAction",
          { "BAP__userPanelAction--active": i === active }
        )
      },
      /* @__PURE__ */ BdApi.React.createElement(Icon, { size: 19, color: "current" })
    )))));
  }
  css`.BAP__userPanelContainer {
    position: absolute;
    z-index: 100;
    left: 0;
    bottom: 0;
    width: 341px;
    padding: 0 8px 8px;
    box-sizing: border-box !important;
}
.BAP__userPanel {
    height: 54px;
    border-width: 1px !important;
    border-radius: 8px;
    padding: 0 8px;
    background: var(--bap-background-primary);
}
.BAP__userPanelAction {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 32px;
    height: 32px;
    border-radius: 8px;
    background-color: transparent;
    color: var(--bap-text-primary);
    transition: background-color .2s, color .2s;
}
.BAP__userPanelAction--active {
    background-color: var(--bap-border-subtle);
    color: var(--bap-text-heading);
}``Preview: UserPanel`;
  function Content() {
    const { serverList, userPanel } = require$$0$1.use(PreviewContext);
    const [module2, isActive] = useModule$1(ModuleKey.Servers);
    const enhanceLayout = module2.settings.enhanceLayout ?? true;
    const data2 = require$$0$1.useMemo(() => [server.main(), server.alt()], []);
    const stage = useStages(2, isActive);
    const auto2 = { direction: stage };
    const mouse = useMouse({
      x: 36,
      y: stage ? 445 : 205
    });
    const wrap2 = (children2, enabled = false) => enabled ? /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { className: "BAP__content", childFactory: passAuto(auto2) }, /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        key: stage,
        container: { className: "BAP__content" },
        module: module2,
        auto: auto2,
        mouse
      },
      children2
    )) : children2;
    return wrap2(
      /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__content" }, /* @__PURE__ */ BdApi.React.createElement(ServerList, { active: stage ? 7 : 2, ...serverList }), wrap2(
        /* @__PURE__ */ BdApi.React.createElement(Server, { ...data2[stage] }),
        enhanceLayout
      ), /* @__PURE__ */ BdApi.React.createElement(UserPanel, { ...userPanel })),
      !enhanceLayout
    );
  }
  css`.BAP__content {
    position: relative;
    isolation: isolate;
    display: flex;
    flex: 1;
    min-height: 0;
    min-width: 0;
}``Preview: Content`;
  function Main() {
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { column: true }, /* @__PURE__ */ BdApi.React.createElement(SystemBar, null), /* @__PURE__ */ BdApi.React.createElement(Content, null));
  }
  const items$1 = [
    { type: "title", length: 96 },
    { type: "section", length: 85 },
    { type: "section", length: 56 },
    { type: "section", length: 119 },
    { type: "section", length: 105 },
    { type: "section", length: 98 },
    { type: "section", length: 118 },
    { type: "section", length: 56 },
    { type: "section", length: 90 },
    { type: "section", length: 38 },
    { type: "divider" },
    { type: "title", length: 121 },
    { type: "section", length: 38 },
    { type: "section", length: 92 },
    { type: "section", length: 97 },
    { type: "section", length: 98 },
    { type: "section", length: 46 },
    { type: "divider" },
    { type: "title", length: 90 }
  ];
  function Title({ length }) {
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { h: 24, px: 8, align: "center" }, /* @__PURE__ */ BdApi.React.createElement(Text, { length, height: 12, color: "background-primary" }));
  }
  function Section$1({ length, active = false }) {
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { h: 32, radius: 4, px: 8, align: "center", bg: active && "background-primary" }, /* @__PURE__ */ BdApi.React.createElement(Text, { length, color: active && "text-heading" }));
  }
  function Divider() {
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { h: 17, px: 10, align: "center" }, /* @__PURE__ */ BdApi.React.createElement(Block, { h: 1, flex: 1, bg: "border-subtle" }));
  }
  function NavSidebar({ active = -1 }) {
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { w: 238, pt: 60, pl: 120, pr: 14, column: true, gap: 22 }, /* @__PURE__ */ BdApi.React.createElement(Block, { h: 36, radius: 8, borderWidth: 1 }), /* @__PURE__ */ BdApi.React.createElement(Flex, { column: true, gap: 2 }, items$1.map(({ type, ...props }, i) => {
      switch (type) {
        case "title":
          return /* @__PURE__ */ BdApi.React.createElement(Title, { key: i, ...props });
        case "divider":
          return /* @__PURE__ */ BdApi.React.createElement(Divider, { key: i, ...props });
        case "section":
          return /* @__PURE__ */ BdApi.React.createElement(Section$1, { key: i, active: i === active, ...props });
      }
    })));
  }
  function XIcon$1({ size = 24, color = "var(--bap-text-heading)" }) {
    return /* @__PURE__ */ BdApi.React.createElement("svg", { width: size, height: size, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" }, /* @__PURE__ */ BdApi.React.createElement(
      "path",
      {
        d: "M17.3 18.7a1 1 0 0 0 1.4-1.4L13.42 12l5.3-5.3a1 1 0 0 0-1.42-1.4L12 10.58l-5.3-5.3a1 1 0 0 0-1.4 1.42L10.58 12l-5.3 5.3a1 1 0 1 0 1.42 1.4L12 13.42l5.3 5.3Z",
        fill: color
      }
    ));
  }
  function CloseButton(props) {
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { column: true, align: "center", gap: 9, ...props }, /* @__PURE__ */ BdApi.React.createElement(Flex, { w: 36, h: 36, center: true, radius: "50%", border: "2px solid var(--bap-text-heading)" }, /* @__PURE__ */ BdApi.React.createElement(XIcon$1, { size: 18 })), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 26, height: 12, color: "text-heading" }));
  }
  function Section({ children: children2 }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__section" }, /* @__PURE__ */ BdApi.React.createElement(CloseButton, { absolute: true, top: 92, right: 132 }), children2);
  }
  css`.BAP__section {
    position: relative;
    flex: 1;
    padding: 96px 208px 0 40px;
    overflow: hidden;
    background-color: var(--bap-background-primary);
}``Preview: Section`;
  function Tab({ length, active = false, activeColor = "text-heading" }) {
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { mb: -1, column: true, justify: "space-between" }, /* @__PURE__ */ BdApi.React.createElement(Text, { length, color: active && activeColor, height: 12 }), active && /* @__PURE__ */ BdApi.React.createElement(Block, { h: 2, bg: activeColor }));
  }
  function Tabs({ tabs = [], active = -1, activeColor, gap = 55, h = 24, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { gap, h: h - 1, align: "stretch", borderBottomWidth: 1, ...props }, tabs.map((length, i) => /* @__PURE__ */ BdApi.React.createElement(
      Tab,
      {
        key: i,
        length,
        active: i === active,
        activeColor
      }
    )));
  }
  function UserProfileSection() {
    return /* @__PURE__ */ BdApi.React.createElement(Section, null, /* @__PURE__ */ BdApi.React.createElement(Text, { length: 127, height: 24, color: "text-heading" }), /* @__PURE__ */ BdApi.React.createElement(Tabs, { mt: 36, tabs: [52, 56], active: 0, activeColor: "brand-primary" }), /* @__PURE__ */ BdApi.React.createElement(Block, { mt: 32, relative: true, radius: 8, bg: "background-tertiary", overflow: "hidden" }, /* @__PURE__ */ BdApi.React.createElement(Block, { h: 100, bg: "brand-primary", mb: 87 }), /* @__PURE__ */ BdApi.React.createElement(
      Block,
      {
        absolute: true,
        top: 76,
        left: 16,
        w: 82,
        h: 82,
        radius: "50%",
        bg: "brand-primary",
        border: "5px solid var(--bap-background-tertiary)"
      }
    ), /* @__PURE__ */ BdApi.React.createElement(Text, { absolute: true, top: 119, left: 117, length: 88, height: 24, color: "text-heading" }), /* @__PURE__ */ BdApi.React.createElement(Button, { absolute: true, top: 119, right: 16, width: 133 }), /* @__PURE__ */ BdApi.React.createElement(Flex, { m: 16, py: 18, pl: 14, pr: 16, column: true, gap: 28, radius: 8, bg: "background-secondary" }, [
      [101, 67],
      [76, 101],
      [55, 155],
      [110, 133]
    ].map((items2, i) => /* @__PURE__ */ BdApi.React.createElement(Flex, { key: i, justify: "space-between", align: "center" }, /* @__PURE__ */ BdApi.React.createElement(Flex, { column: true, align: "flex-start", gap: 8 }, items2.map((length, i2) => /* @__PURE__ */ BdApi.React.createElement(Text, { key: i2, length, color: "text-heading" }))), /* @__PURE__ */ BdApi.React.createElement(Button, { width: 60, color: "text-primary" }))))));
  }
  function Switch({ title = 90, note = [276], active = false }) {
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { relative: true, mt: 20, pt: 6, pb: 22, borderBottomWidth: 1, column: true, gap: 16 }, /* @__PURE__ */ BdApi.React.createElement(Text, { length: title, color: "text-heading" }), /* @__PURE__ */ BdApi.React.createElement(Flex, { column: true, gap: 4 }, note.map((length, i) => /* @__PURE__ */ BdApi.React.createElement(Text, { key: i, length }))), /* @__PURE__ */ BdApi.React.createElement(
      Block,
      {
        absolute: true,
        top: 0,
        right: 0,
        w: 42,
        h: 26,
        radius: 24,
        borderWidth: 1,
        bg: active ? "brand-primary" : "text-primary"
      },
      /* @__PURE__ */ BdApi.React.createElement(Block, { absolute: true, top: 3, left: active ? 19 : 3, w: 20, h: 20, radius: "50%", bg: "white" })
    ));
  }
  const switches = [
    { title: 201, note: [385, 128], active: true },
    { title: 90, note: [406], active: true },
    { title: 238, note: [276], active: true },
    { title: 150, note: [339, 314], active: false },
    { title: 227, note: [171], active: true },
    { title: 212, note: [329], active: false }
  ];
  function SwitchesSection() {
    return /* @__PURE__ */ BdApi.React.createElement(Section, null, /* @__PURE__ */ BdApi.React.createElement(Text, { length: 114, color: "text-heading" }), switches.map((props, i) => /* @__PURE__ */ BdApi.React.createElement(Switch, { key: i, ...props })));
  }
  function Settings$1() {
    const [module2, isActive] = useModule$1(ModuleKey.Settings);
    const stage = useStages(2, isActive);
    const auto2 = { direction: stage };
    const mouse = useMouse({
      x: 239,
      y: stage ? 400 : 162
    });
    return /* @__PURE__ */ BdApi.React.createElement(Flex, { bg: "background-tertiary" }, /* @__PURE__ */ BdApi.React.createElement(NavSidebar, { active: stage ? 8 : 1 }), /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { className: "BAP__contentRegion", childFactory: passAuto(auto2) }, /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        key: stage,
        container: { className: "BAP__contentRegion" },
        module: module2,
        auto: auto2,
        mouse
      },
      stage ? /* @__PURE__ */ BdApi.React.createElement(SwitchesSection, null) : /* @__PURE__ */ BdApi.React.createElement(UserProfileSection, null)
    )));
  }
  css`.BAP__contentRegion {
    position: relative;
    isolation: isolate;
    display: flex;
    flex: 1;
    background: var(--bap-background-primary);
}
.BAP__contentRegion > .BAP__contentRegion {
    background: none;
}``Preview: Settings`;
  function Layer$1({ baseLayer = false, hidden = false, children: children2 }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: classNames(
      "BAP__layer",
      {
        "BAP__baseLayer": baseLayer,
        "BAP__layer--hidden": hidden
      }
    ) }, children2);
  }
  function LayerTransition$1({ baseLayer, shown, children: children2, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        ...props,
        in: shown && props.in,
        container: { className: "BAP__layerContainer" },
        defaultLayoutStyles: false,
        mountOnEnter: false,
        unmountOnExit: false
      },
      (state) => /* @__PURE__ */ BdApi.React.createElement(Layer$1, { baseLayer, hidden: state === Transition.EXITED }, children2)
    );
  }
  function Layers({ layer }) {
    const [module2, isActive] = useModule$1(ModuleKey.Layers);
    const stage = useStages(2, isActive);
    const mainMouse = useMouse({ x: 308, y: 684 });
    const settingsMouse = useMouse({ x: 1128, y: 112 });
    if (!isActive) return /* @__PURE__ */ BdApi.React.createElement(Layer$1, { baseLayer: true }, layer);
    const auto2 = { direction: stage, preservedMouse: mainMouse };
    const mouse = stage ? mainMouse : settingsMouse;
    const props = { module: module2, mouse, auto: auto2 };
    return /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null, childFactory: passAuto(auto2) }, /* @__PURE__ */ BdApi.React.createElement(LayerTransition$1, { ...props, key: "main", baseLayer: true, shown: stage === 0 }, /* @__PURE__ */ BdApi.React.createElement(Main, null)), /* @__PURE__ */ BdApi.React.createElement(LayerTransition$1, { ...props, key: "settings", shown: stage === 1 }, /* @__PURE__ */ BdApi.React.createElement(Settings$1, null)));
  }
  css`.BAP__layerContainer, .BAP__layer, .BAP__layer > * {
    position: absolute;
    inset: 0;
}
.BAP__layer {
    background-color: var(--bap-background-primary);
    overflow: hidden;
    contain: strict;
}
.BAP__layer--hidden {
    visibility: hidden;
    pointer-events: none;
}
.BAP__baseLayer {
    background-color: transparent;
}``Preview: Layers`;
  function FloatingLayerContainer({ className, children: children2, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        className: classNames("BAP__floatingLayerContainer", className),
        ...props
      },
      children2
    );
  }
  function FloatingLayer({ className, children: children2, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        className: classNames("BAP__floatingLayer", className),
        ...props
      },
      children2
    );
  }
  function Floating({ ref, className, top, left, right, bottom, layer, children: children2 }) {
    return /* @__PURE__ */ BdApi.React.createElement(FloatingLayer, { ...layer }, /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        ref,
        className: classNames("BAP__floating", className),
        style: {
          position: "absolute",
          top,
          left,
          right,
          bottom
        }
      },
      children2
    ));
  }
  css`.BAP__floatingLayerContainer,
.BAP__floatingLayer {
    position: absolute;
    inset: 0;
    z-index: 1000;
    pointer-events: none;
    isolation: isolate;
}
.BAP__floating {
    position: absolute;
    pointer-events: all;
}``Preview: Floating`;
  function Tooltip({ children: children2, position: position2 = Position.Top, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(Floating, { ...props }, /* @__PURE__ */ BdApi.React.createElement("div", { className: classNames(
      "BAP__tooltip",
      `BAP__tooltip--${position2}`
    ) }, children2, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__tooltipArrow" })));
  }
  css`.BAP__tooltip {
    position: relative;
    padding: 8px;
    border-radius: 5px;
    background-color: var(--bap-background-surface-overlay);
    border-width: 1px !important;
    box-shadow: 0 12px 24px 0 rgba(0, 0, 0, .24);
}
.BAP__tooltipArrow {
    position: absolute;
    top: var(--arrow-top);
    left: var(--arrow-left);
    bottom: var(--arrow-bottom);
    right: var(--arrow-right);
    translate: var(--arrow-translate);
    width: 20px;
    height: 20px;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none;
}
.BAP__tooltipArrow::before {
    content: '';
    position: absolute;
    width: 6px;
    height: 6px;
    background-color: var(--bap-background-surface-overlay);
    border: 1px solid var(--bap-border-subtle);
    rotate: 45deg;
    translate: var(--arrow-translate-inner);
}
.BAP__tooltip--top {
    --arrow-top: 100%;
    --arrow-left: 50%;
    --arrow-translate: -50% 0;
    --arrow-translate-inner: 0 -10px;
    transform-origin: 50% 100%;
}
.BAP__tooltip--bottom {
    --arrow-bottom: 100%;
    --arrow-left: 50%;
    --arrow-translate: -50% 0;
    --arrow-translate-inner: 0 10px;
    transform-origin: 50% 0;
}
.BAP__tooltip--left {
    --arrow-left: 100%;
    --arrow-top: 50%;
    --arrow-translate: 0 -50%;
    --arrow-translate-inner: -10px 0;
    transform-origin: 100% 50%;
}
.BAP__tooltip--right {
    --arrow-right: 100%;
    --arrow-top: 50%;
    --arrow-translate: 0 -50%;
    --arrow-translate-inner: 10px 0;
    transform-origin: 0 50%;
}``Preview: Tooltip`;
  function AnimatedTooltip({ position: position2, align = Position.Center, top, left, children: children2, ...props }) {
    const containerRef = require$$0$1.useRef();
    const [module2] = useModule$1(ModuleKey.Tooltips);
    return /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        containerRef,
        module: module2,
        auto: { position: position2, align },
        ...props
      },
      /* @__PURE__ */ BdApi.React.createElement(
        Tooltip,
        {
          ref: containerRef,
          position: position2,
          top,
          left
        },
        children2
      )
    );
  }
  function Tooltips() {
    const {
      userPanelActionRefs,
      serverListIconRefs,
      setUserPanel,
      setServerList
    } = require$$0$1.use(PreviewContext);
    const [, isActive] = useModule$1(ModuleKey.Tooltips);
    const stage = useStages(4, isActive);
    const userPanelActionIndex = 0;
    require$$0$1.useEffect(() => {
      if (isActive) setUserPanel(stage === 1 ? { active: userPanelActionIndex } : {});
    }, [stage]);
    const serverListIconIndex = 9;
    require$$0$1.useEffect(() => {
      if (isActive) setServerList(stage === 3 ? { hover: serverListIconIndex } : {});
    }, [stage]);
    if (!isActive) return null;
    return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(
      AnimatedTooltip,
      {
        in: stage === 1,
        top: 625,
        left: 190,
        position: Position.Top,
        anchor: () => userPanelActionRefs.current[userPanelActionIndex]
      },
      /* @__PURE__ */ BdApi.React.createElement(Text, { length: 90 })
    ), /* @__PURE__ */ BdApi.React.createElement(
      AnimatedTooltip,
      {
        in: stage === 3,
        top: 497,
        left: 68,
        position: Position.Right,
        anchor: () => serverListIconRefs.current[serverListIconIndex]
      },
      /* @__PURE__ */ BdApi.React.createElement(Flex, { column: true, gap: 8 }, /* @__PURE__ */ BdApi.React.createElement(Text, { length: 140, color: "text-heading" }), /* @__PURE__ */ BdApi.React.createElement(Flex, { gap: 8, align: "center" }, /* @__PURE__ */ BdApi.React.createElement(Icon, { size: 19 }), /* @__PURE__ */ BdApi.React.createElement(Flex, null, Array(4).fill(null).map((_, i) => /* @__PURE__ */ BdApi.React.createElement(
        Icon,
        {
          key: i,
          size: 24,
          radius: "50%",
          mr: -5,
          boxShadow: "0 0 0 2px var(--bap-background-surface-overlay)"
        }
      )))), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 37 }))
    ));
  }
  function UserPopout(props) {
    return /* @__PURE__ */ BdApi.React.createElement(Floating, { ...props }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__userPopout" }, /* @__PURE__ */ BdApi.React.createElement(Block, { h: 105, bg: "brand-primary" }), /* @__PURE__ */ BdApi.React.createElement(
      Icon,
      {
        absolute: true,
        size: 82,
        top: 60,
        left: 15,
        radius: "50%",
        color: "brand-primary",
        boxShadow: "0 0 0 5px var(--bap-background-surface-overlay)"
      }
    ), /* @__PURE__ */ BdApi.React.createElement(Flex, { column: true, pt: 54, px: 16, pb: 16, flex: 1 }, /* @__PURE__ */ BdApi.React.createElement(Text, { length: 225, height: 24, color: "text-heading" }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 169, mt: 12 }), /* @__PURE__ */ BdApi.React.createElement(Flex, { gap: 4, mt: 16 }, /* @__PURE__ */ BdApi.React.createElement(Text, { length: 34, color: "text-heading" }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 106 })), /* @__PURE__ */ BdApi.React.createElement(Block, { mt: "auto", h: 44, radius: 3, bg: "background-primary", borderWidth: 1 }))));
  }
  function ThreadsPopout(props) {
    return /* @__PURE__ */ BdApi.React.createElement(Floating, { ...props }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__threadsPopout" }, /* @__PURE__ */ BdApi.React.createElement(Flex, { h: 48, px: 16, justify: "space-between", align: "center", borderBottomWidth: 1 }, /* @__PURE__ */ BdApi.React.createElement(Flex, { gap: 10, center: true }, /* @__PURE__ */ BdApi.React.createElement(Icon, { color: "text-heading" }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 167, color: "text-heading" })), /* @__PURE__ */ BdApi.React.createElement(Icon, { size: 26 })), /* @__PURE__ */ BdApi.React.createElement(Flex, { column: true, center: true, flex: 1 }, /* @__PURE__ */ BdApi.React.createElement(Icon, { size: 84, radius: "50%", color: "background-primary" }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 225, height: 24, color: "text-heading", mt: 20 }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 299, mt: 14 }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 265, mt: 6 }), /* @__PURE__ */ BdApi.React.createElement(Button, { width: 118, height: 36, mt: 24 }))));
  }
  function Popouts() {
    const {
      channelHeaderItemRefs,
      memberListItemRefs,
      setMemberList,
      setThreadPopoutShown
    } = require$$0$1.use(PreviewContext);
    const userPopoutRef = require$$0$1.useRef();
    const threadPopoutRef = require$$0$1.useRef();
    const [module2, isActive] = useModule$1(ModuleKey.Popouts);
    const stage = useStages(4, isActive);
    const memberListItemIndex = 0;
    require$$0$1.useEffect(() => {
      if (isActive) setMemberList(stage === 1 ? { active: memberListItemIndex } : {});
    }, [stage]);
    const channelHeaderItemIndex = 0;
    require$$0$1.useEffect(() => {
      if (isActive) setThreadPopoutShown(stage === 3);
    }, [stage]);
    if (!isActive) return null;
    return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        in: stage === 1,
        module: module2,
        containerRef: userPopoutRef,
        anchor: () => memberListItemRefs.current[memberListItemIndex],
        auto: {
          position: Position.Left,
          align: Position.Top
        }
      },
      /* @__PURE__ */ BdApi.React.createElement(
        UserPopout,
        {
          ref: userPopoutRef,
          top: 120,
          right: 272
        }
      )
    ), /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        in: stage === 3,
        module: module2,
        containerRef: threadPopoutRef,
        anchor: () => channelHeaderItemRefs.current[channelHeaderItemIndex],
        auto: {
          position: Position.Bottom,
          align: Position.Right
        }
      },
      /* @__PURE__ */ BdApi.React.createElement(
        ThreadsPopout,
        {
          ref: threadPopoutRef,
          top: 81,
          right: 392
        }
      )
    ));
  }
  css`.BAP__userPopout {
    width: 300px;
    height: 380px;
    display: flex;
    flex-direction: column;
    border-radius: 8px;
    box-shadow: 0 8px 16px 0 rgba(0, 0, 0, .24);
    background-color: var(--bap-background-surface-overlay);
    overflow: clip;
}

.BAP__threadsPopout {
    width: 534px;
    height: 448px;
    display: flex;
    flex-direction: column;
    border-radius: 8px;
    box-shadow: 0 0 0 1px var(--bap-border-subtle),
        0 12px 24px 0 rgba(0, 0, 0, .24);
    background-color: var(--bap-background-surface-overlay);
    overflow: clip;
}``Preview: Popouts`;
  const coords = { x: 36, y: 157 };
  const auto = {
    position: Position.Right,
    align: Position.Top
  };
  const items = [
    { type: "action", length: 79 },
    { type: "submenu", length: 82 },
    { type: "action", length: 35 },
    { type: "action", length: 52 },
    { type: "action", length: 87 },
    { type: "divider" },
    { type: "action", length: 60 },
    { type: "action", length: 75 },
    { type: "action", length: 32 },
    { type: "action", length: 81 },
    { type: "action", length: 116 },
    { type: "divider" },
    { type: "action", length: 97 }
  ];
  const submenuIndex = items.findIndex((item) => item.type === "submenu");
  const submenuItems = [
    { type: "action", length: 48 },
    { type: "action", length: 88 },
    { type: "action", length: 62 },
    { type: "action", length: 54 },
    { type: "action", length: 99 },
    { type: "action", length: 66 },
    { type: "action", length: 82 },
    { type: "action", length: 41 },
    { type: "divider" },
    { type: "action", length: 97 }
  ];
  function ContextMenuItem({ type, length, active = false, ...props }) {
    if (type === "divider") return /* @__PURE__ */ BdApi.React.createElement(Divider$1, { length: "100%", my: 8 });
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        className: classNames({
          "BAP__contextMenuItem": true,
          "BAP__contextMenuItem--active": active
        }),
        ...props
      },
      /* @__PURE__ */ BdApi.React.createElement(Text, { length, color: "text-heading" }),
      type === "submenu" ? /* @__PURE__ */ BdApi.React.createElement(ChevronIcon, { size: 20 }) : /* @__PURE__ */ BdApi.React.createElement(Icon, { size: 20 })
    );
  }
  function ContextMenu({ items: items2, itemRefs = require$$0$1.useRef([]), active = -1, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(Floating, { ...props }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__contextMenu" }, items2.map((props2, i) => /* @__PURE__ */ BdApi.React.createElement(
      ContextMenuItem,
      {
        key: i,
        ref: (ref) => {
          itemRefs.current[i] = ref;
        },
        active: i === active,
        ...props2
      }
    ))));
  }
  function ContextMenus() {
    const menuRef = require$$0$1.useRef();
    const submenuRef = require$$0$1.useRef();
    const itemRefs = require$$0$1.useRef([]);
    const [module2, isActive] = useModule$1(ModuleKey.ContextMenu);
    const stage = useStages(4, isActive);
    const mouse = useMouse(coords);
    if (!isActive) return null;
    return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        in: stage > 0,
        module: module2,
        containerRef: menuRef,
        auto,
        mouse
      },
      /* @__PURE__ */ BdApi.React.createElement(
        ContextMenu,
        {
          ref: menuRef,
          top: coords.y,
          left: coords.x,
          items,
          itemRefs,
          active: stage === 2 ? submenuIndex : -1
        }
      )
    ), /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        in: stage === 2,
        module: module2,
        containerRef: submenuRef,
        auto,
        anchor: () => itemRefs.current[submenuIndex]
      },
      /* @__PURE__ */ BdApi.React.createElement(
        ContextMenu,
        {
          ref: submenuRef,
          top: 202,
          left: 261,
          items: submenuItems
        }
      )
    ));
  }
  css`.BAP__contextMenu {
    width: 204px;
    border-width: 1px !important;
    box-shadow: 0 12px 24px 0 rgba(0, 0, 0, .24);
    background-color: var(--bap-background-surface-overlay);
    border-radius: 8px;
    padding: 8px;
}
.BAP__contextMenuItem {
    height: 36px;
    border-radius: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 8px;
}
.BAP__contextMenuItem svg {
    rotate: -90deg;
}
.BAP__contextMenuItem--active {
    background-color: var(--bap-border-subtle);
}``Preview: ContextMenus`;
  function Modal$1({ children: children2, ...props }) {
    const containerRef = require$$0$1.useRef();
    const [module2] = useModule$1(ModuleKey.Modals);
    return /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        module: module2,
        containerRef,
        ...props
      },
      /* @__PURE__ */ BdApi.React.createElement(FloatingLayer, { className: "BAP__modalLayer" }, /* @__PURE__ */ BdApi.React.createElement(
        AnimeContainer,
        {
          ref: containerRef,
          id: ModuleKey.Modals,
          container: { className: "BAP__modalContainer" }
        },
        /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__modal" }, children2)
      ))
    );
  }
  function UserModal(props) {
    return /* @__PURE__ */ BdApi.React.createElement(Modal$1, { ...props }, /* @__PURE__ */ BdApi.React.createElement(Block, { h: 780, relative: true }, /* @__PURE__ */ BdApi.React.createElement(Block, { h: 210, bg: "brand-primary" }), /* @__PURE__ */ BdApi.React.createElement(
      Icon,
      {
        absolute: true,
        size: 120,
        top: 145,
        left: 24,
        radius: "50%",
        color: "brand-primary",
        boxShadow: "0 0 0 8px var(--bap-background-primary)"
      }
    ), /* @__PURE__ */ BdApi.React.createElement(Block, { px: 16, py: 22 }, /* @__PURE__ */ BdApi.React.createElement(Flex, { justify: "flex-end", gap: 8, mb: 22 }, /* @__PURE__ */ BdApi.React.createElement(Button, { width: 32, color: "text-primary" }), /* @__PURE__ */ BdApi.React.createElement(Button, { width: 120 })), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 124, height: 24, color: "text-heading" }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 166, mt: 8 }), /* @__PURE__ */ BdApi.React.createElement(Tabs, { tabs: [59, 112, 95], active: 0, mt: 34, mb: 18 }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 162 }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 76, height: 12, color: "text-heading", mt: 22, mb: 8 }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 334 }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 216, mt: 4 }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 128, height: 12, color: "text-heading", mt: 22, mb: 8 }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 171 }), /* @__PURE__ */ BdApi.React.createElement(Text, { length: 92, mt: 4 }))));
  }
  function Backdrop(props) {
    const layerRef = require$$0$1.useRef();
    const [module2] = useModule$1(ModuleKey.ModalsBackdrop);
    return /* @__PURE__ */ BdApi.React.createElement(
      PreviewTransition,
      {
        module: module2,
        containerRef: layerRef,
        defaultLayoutStyles: false,
        ...props
      },
      /* @__PURE__ */ BdApi.React.createElement(FloatingLayer, { ref: layerRef, className: "BAP__backdropLayer" }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BAP__backdrop" }))
    );
  }
  function Modals() {
    const [, isActive] = useModule$1(ModuleKey.Modals);
    const [, isBackdropActive] = useModule$1(ModuleKey.ModalsBackdrop);
    const stage = useStages(2, isActive || isBackdropActive);
    if (!isActive && !isBackdropActive) return null;
    return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(Backdrop, { in: !!stage }), /* @__PURE__ */ BdApi.React.createElement(UserModal, { in: !!stage }));
  }
  css`.BAP__modalLayer {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 24px 0;
}
.BAP__modalContainer {
    min-height: 0;
}
.BAP__modal {
    background-color: var(--bap-background-primary);
    border-radius: 8px;
    overflow: clip;
    width: 600px;
    min-height: 220px;
    pointer-events: all;
    max-height: 100%;
    display: flex;
    flex-direction: column;
}
.BAP__backdropLayer {
    pointer-events: all;
}
.BAP__backdrop {
    position: absolute;
    inset: 0;
    pointer-events: none;
    background-color: rgba(0, 0, 0, 0.7);
}``Preview: Modals`;
  const mainPlaceholder = "data:image/png;base64,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";
  const settingsPlaceholder = "data:image/png;base64,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";
  const threadSidebarSwitchPlaceholder = "data:image/png;base64,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";
  const PREVIEW_WIDTH = 1280;
  const PREVIEW_HEIGHT = 720;
  function Preview({
    id = null,
    modules: modules2 = [],
    active = true,
    placeholder = false,
    pack = null,
    animation = null,
    dataKey = 0,
    className,
    style: style2,
    ref,
    viewportRef = require$$0$1.useRef(),
    preferences = {
      memberListShown: true
    },
    onError = ErrorManager.registerAnimationError
  }) {
    const store = require$$0$1.useMemo(() => new AnimationStore(), []);
    require$$0$1.useEffect(() => {
      store.initialize();
      return () => store.shutdown();
    }, [store]);
    const module2 = require$$0$1.useMemo(() => modules2.find((m) => m.id === id), [id, modules2]);
    const [data2, setData] = require$$0$1.useState(null);
    require$$0$1.useEffect(() => {
      if (placeholder || !module2 || !pack || !animation) {
        setData(null);
        return;
      }
      const data22 = module2.initializeAnimations(pack, animation);
      const error2 = data22.enter.error || data22.exit.error;
      if (error2) onError(error2);
      setData(data22);
    }, [placeholder, module2, pack, animation, dataKey]);
    const placeholderRef = require$$0$1.useRef();
    const placeholderSrc = require$$0$1.useMemo(() => {
      if (typeof placeholder === "string") return placeholder;
      switch (module2?.id) {
        case ModuleKey.Settings:
          return settingsPlaceholder;
        case ModuleKey.ThreadSidebarSwitch:
          return threadSidebarSwitchPlaceholder;
        default:
          return mainPlaceholder;
      }
    }, [placeholder, module2]);
    const layer = require$$0$1.useMemo(() => {
      switch (module2.id) {
        case ModuleKey.Settings:
          return /* @__PURE__ */ BdApi.React.createElement(Settings$1, null);
        default:
          return /* @__PURE__ */ BdApi.React.createElement(Main, null);
      }
    }, [module2]);
    const serverListIconRefs = require$$0$1.useRef([]);
    const userPanelActionRefs = require$$0$1.useRef([]);
    const channelHeaderItemRefs = require$$0$1.useRef([]);
    const memberListItemRefs = require$$0$1.useRef([]);
    const [serverList, setServerList] = require$$0$1.useState({});
    const [userPanel, setUserPanel] = require$$0$1.useState({});
    const [memberList2, setMemberList] = require$$0$1.useState({});
    const [threadPopoutShown, setThreadPopoutShown] = require$$0$1.useState(false);
    const [memberListShown, _setMemberListShown] = require$$0$1.useState(
      id === ModuleKey.ThreadSidebar ? preferences.memberListShown : id !== ModuleKey.ThreadSidebarSwitch
    );
    const setMemberListShown = (value, force = false) => {
      if (value === preferences.memberListShown || force) _setMemberListShown(value);
    };
    const context = {
      store,
      id,
      modules: modules2,
      active,
      pack,
      animation,
      data: data2,
      viewportRef,
      onError,
      serverListIconRefs,
      userPanelActionRefs,
      channelHeaderItemRefs,
      memberListItemRefs,
      serverList,
      setServerList,
      userPanel,
      setUserPanel,
      memberListShown,
      setMemberListShown,
      memberList: memberList2,
      setMemberList,
      threadPopoutShown,
      setThreadPopoutShown
    };
    return /* @__PURE__ */ BdApi.React.createElement(PreviewContext, { value: context }, /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        ref,
        className: classNames(
          "BAP__container",
          `BAP--${id}`,
          className
        ),
        style: style2
      },
      /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null }, /* @__PURE__ */ BdApi.React.createElement(
        CSSTransition,
        {
          key: placeholder ? "placeholder" : "viewport",
          nodeRef: placeholder ? placeholderRef : viewportRef,
          classNames: placeholder ? "BAP__fade" : void 0,
          timeout: 400
        },
        placeholder ? /* @__PURE__ */ BdApi.React.createElement(
          "img",
          {
            ref: placeholderRef,
            src: placeholderSrc,
            className: "BAP__viewport"
          }
        ) : /* @__PURE__ */ BdApi.React.createElement(
          "div",
          {
            ref: viewportRef,
            className: "BAP__viewport"
          },
          /* @__PURE__ */ BdApi.React.createElement(Layers, { layer }),
          /* @__PURE__ */ BdApi.React.createElement(FloatingLayerContainer, null, /* @__PURE__ */ BdApi.React.createElement(Modals, null), /* @__PURE__ */ BdApi.React.createElement(Tooltips, null), /* @__PURE__ */ BdApi.React.createElement(Popouts, null), /* @__PURE__ */ BdApi.React.createElement(ContextMenus, null))
        )
      ))
    ));
  }
  const Preview$1 = require$$0$1.memo(Preview);
  css`.BAP__container {
    position: relative;
    overflow: clip;
    width: ${PREVIEW_WIDTH}px;
    height: ${PREVIEW_HEIGHT}px;
    contain: strict;
}
.BAP__viewport {
    --bap-background-primary: #202024;
    --bap-background-secondary: #1A1A1E;
    --bap-background-secondary-alt: #18181C;
    --bap-background-tertiary: #121214;
    --bap-background-surface-overlay: #242429;
    --bap-border-subtle: rgba(151, 151, 159, .12);
    --bap-text-primary: #3B3D42;
    --bap-text-heading: #505357;
    --bap-brand-primary: #5865F2;
    --bap-white: #FBFBFB;
    --bap-current: currentColor;

    position: absolute;
    inset: 0;
    isolation: isolate;
    font-size: 16px;
    color: var(--bap-text-primary);
    background-color: var(--bap-background-tertiary);
    overflow: clip;
    object-fit: cover;
}
img.BAP__viewport {
    z-index: 2;
}
.BAP__viewport > * {
    position: absolute;
    inset: 0;
}
.BAP__viewport * {
    border-color: var(--bap-border-subtle);
    border-style: solid;
    border-width: 0;
    box-sizing: content-box;
}

.BAP--messages .BAP__viewport {
    transform-origin: 63% bottom;
    scale: 1.35;
}
.BAP--membersSidebar .BAP__viewport {
    transform-origin: bottom right;
    scale: 1.05;
}
.BAP--tooltips .BAP__viewport {
    transform-origin: bottom left;
    scale: 2.8;
}
.BAP--channelList .BAP__viewport {
    transform-origin: left 66%;
    scale: 1.5;
}
.BAP--popouts .BAP__viewport {
    transform-origin: top right;
    scale: 1.3;
}
.BAP--contextMenu .BAP__viewport {
    transform-origin: 0 58%;
    scale: 1.45;
}

.BAP__fade-enter-active, .BAP__fade-exit-active {
    transition: opacity .4s;
}
.BAP__fade-enter, .BAP__fade-exit-active {
    opacity: 0;
}
.BAP__fade-enter-active {
    opacity: 1;
}``Preview`;
  function ButtonGroupItem({ children: children2, tooltip, selected, disabled, className, onClick }) {
    const button = (props) => /* @__PURE__ */ BdApi.React.createElement(
      Clickable,
      {
        ...props,
        tag: "button",
        className: classNames({
          "BA__buttonGroupItem": true,
          "BA__buttonGroupItem--selected": selected,
          "BA__buttonGroupItem--disabled": disabled
        }, className),
        onClick
      },
      children2
    );
    if (!tooltip) return button({});
    return /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { ...typeof tooltip === "string" ? { text: tooltip } : tooltip }, button);
  }
  function ButtonGroup({ options, multiple = false, selected, onChange, className, itemClassName, size = "sm" }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        className: classNames(
          "BA__buttonGroup",
          `BA__buttonGroup--${size}`,
          {
            "BA__buttonGroup--single": !multiple
          },
          className
        )
      },
      options.map((option) => /* @__PURE__ */ BdApi.React.createElement(
        ButtonGroupItem,
        {
          ...option,
          key: option.value,
          className: classNames(itemClassName, option.className),
          selected: multiple ? option.selected : selected === option.value,
          onClick: multiple ? option.onClick : () => selected !== option.value && onChange(option.value),
          children: option.children ?? option.label
        }
      ))
    );
  }
  css`.BA__buttonGroup {
    --ba--button-group-border-radius: 4px;
    
    display: flex;
    border-radius: var(--ba--button-group-border-radius);
    height: 28px;
    box-sizing: border-box;
}

.BA__buttonGroupItem {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
    background-color: var(--input-background);
    border-style: solid;
    border-color: var(--input-border);
    border-top-width: 1px;
    border-bottom-width: 1px;
    color: var(--interactive-normal);
    flex: 1;
}
.BA__buttonGroupItem:hover {
    background-color: var(--background-modifier-hover);
}
.BA__buttonGroupItem.BA__buttonGroupItem--disabled {
    color: var(--interactive-muted);
    cursor: not-allowed;
}    

.BA__buttonGroup > .BA__buttonGroupItem {
    padding: 0 8px;
}
.BA__buttonGroup > .BA__buttonGroupItem:first-of-type {
    border-top-left-radius: var(--ba--button-group-border-radius);
    border-bottom-left-radius: var(--ba--button-group-border-radius);
    border-left-width: 1px;
}
.BA__buttonGroup > .BA__buttonGroupItem:last-of-type {
    border-top-right-radius: var(--ba--button-group-border-radius);
    border-bottom-right-radius: var(--ba--button-group-border-radius);
    border-right-width: 1px;
}

.BA__buttonGroup--md {
    --ba--button-group-border-radius: 8px;
    height: 36px;
}
.BA__buttonGroup--md > .BA__buttonGroupItem {
    padding: 0 12px;
}

.BA__buttonGroup--lg {
    --ba--button-group-border-radius: 8px;
    height: 42px;
}
.BA__buttonGroup--lg > .BA__buttonGroupItem {
    padding: 0 12px;
}

.BA__buttonGroupItem.BA__buttonGroupItem--selected {
    background-color: var(--brand-500);
    border-color: var(--brand-500);
    color: var(--white-500);
}
.BA__buttonGroup.BA__buttonGroup--single .BA__buttonGroupItem.BA__buttonGroupItem--selected {
    cursor: default;
}``ButtonGroup`;
  function DoorEnterIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M9 12a1 1 0 0 1 1 1v2a1 1 0 1 1-2 0v-2a1 1 0 0 1 1-1Z"
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M2.75 3.02A3 3 0 0 1 5 2h10a3 3 0 0 1 3 3v7.5a.5.5 0 0 1-.5.5H16a3 3 0 0 0-3 3v3.5a2.5 2.5 0 0 1-3.68 2.2l-5.8-3.09A3 3 0 0 1 2 16V5a3 3 0 0 1 .76-1.98Zm1.3 1.95A.04.04 0 0 0 4 5v11c0 .36.2.68.49.86l5.77 3.08a.5.5 0 0 0 .74-.44V8.02a.5.5 0 0 0-.32-.46l-6.63-2.6Z",
          clipRule: "evenodd"
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M15 18.5V22a1 1 0 1 0 2 0v-3.59l4.3 4.3a1 1 0 0 0 1.4-1.42L18.42 17H22a1 1 0 1 0 0-2h-6a1 1 0 0 0-1 1v2.5Z"
        }
      )
    );
  }
  function DoorExitIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M9 12a1 1 0 0 1 1 1v2a1 1 0 1 1-2 0v-2a1 1 0 0 1 1-1Z"
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M2.75 3.02A3 3 0 0 1 5 2h10a3 3 0 0 1 3 3v7.64c0 .44-.55.7-.95.55a3 3 0 0 0-3.17 4.93l.02.03a.5.5 0 0 1-.35.85h-.05a.5.5 0 0 0-.5.5 2.5 2.5 0 0 1-3.68 2.2l-5.8-3.09A3 3 0 0 1 2 16V5a3 3 0 0 1 .76-1.98Zm1.3 1.95A.04.04 0 0 0 4 5v11c0 .36.2.68.49.86l5.77 3.08a.5.5 0 0 0 .74-.44V8.02a.5.5 0 0 0-.32-.46l-6.63-2.6Z",
          clipRule: "evenodd"
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M15.3 16.7a1 1 0 0 1 1.4-1.4l4.3 4.29V16a1 1 0 1 1 2 0v6a1 1 0 0 1-1 1h-6a1 1 0 1 1 0-2h3.59l-4.3-4.3Z"
        }
      )
    );
  }
  function useToggleHint() {
    const [hintShown, setHintShown] = require$$0$1.useState(false);
    const showHint = require$$0$1.useCallback(() => setHintShown(true), [setHintShown]);
    const hideHint = require$$0$1.useCallback(() => setHintShown(false), [setHintShown]);
    const hintProps = require$$0$1.useCallback((optionDisabled, text2 = Messages.SELECT_ANIMATION_TO_ENABLE) => {
      if (!optionDisabled) return {};
      return Object.assign(
        { onClick: stop(showHint) },
        hintShown ? {
          tooltip: { text: text2, onTooltipHide: hideHint }
        } : {}
      );
    }, [hintShown, showHint, hideHint]);
    return {
      hintShown,
      setHintShown,
      showHint,
      hideHint,
      hintProps
    };
  }
  function AnimationToggleControl({ enter, exit, setEnter, setExit }) {
    const module2 = require$$0$1.use(ModuleContext);
    const isAdvanced = useAdvancedMode(enter !== exit);
    const { hintProps } = useToggleHint();
    const options = require$$0$1.useMemo(() => {
      if (module2.meta?.type === ModuleType.Switch && !isAdvanced) return [
        {
          value: "enabled",
          selected: enter && exit,
          disabled: !setEnter || !setExit,
          onClick: stop(() => {
            const value = !(enter && exit);
            setEnter(value);
            setExit(value);
          }),
          children: /* @__PURE__ */ BdApi.React.createElement(
            CheckIcon,
            {
              size: "sm",
              color: "currentColor"
            }
          ),
          ...hintProps(!setEnter || !setExit)
        }
      ];
      return [
        {
          value: "enter",
          tooltip: "Enter",
          selected: enter,
          disabled: !setEnter,
          onClick: stop(() => setEnter(!enter)),
          children: /* @__PURE__ */ BdApi.React.createElement(
            DoorEnterIcon,
            {
              size: "custom",
              width: 18,
              height: 18,
              color: "currentColor"
            }
          ),
          ...hintProps(!setEnter)
        },
        {
          value: "exit",
          tooltip: "Exit",
          selected: exit,
          disabled: !setExit,
          onClick: stop(() => setExit(!exit)),
          children: /* @__PURE__ */ BdApi.React.createElement(
            DoorExitIcon,
            {
              size: "custom",
              width: 18,
              height: 18,
              color: "currentColor"
            }
          ),
          ...hintProps(!setExit)
        }
      ];
    }, [enter, exit, setEnter, setExit, hintProps, module2.meta?.type, isAdvanced]);
    return /* @__PURE__ */ BdApi.React.createElement(
      ButtonGroup,
      {
        size: "md",
        itemClassName: "BA__animationToggleGroupItem",
        options,
        multiple: true
      }
    );
  }
  css`.BA__animationToggleGroupItem {
    border: none;
    background-color: transparent;
    border-radius: 0 !important;
}
.BA__animationToggleGroupItem:last-of-type {
    border-bottom-right-radius: 8px !important;
}``AnimationToggleControl`;
  function SettingsIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M10.56 1.1c-.46.05-.7.53-.64.98.18 1.16-.19 2.2-.98 2.53-.8.33-1.79-.15-2.49-1.1-.27-.36-.78-.52-1.14-.24-.77.59-1.45 1.27-2.04 2.04-.28.36-.12.87.24 1.14.96.7 1.43 1.7 1.1 2.49-.33.8-1.37 1.16-2.53.98-.45-.07-.93.18-.99.64a11.1 11.1 0 0 0 0 2.88c.06.46.54.7.99.64 1.16-.18 2.2.19 2.53.98.33.8-.14 1.79-1.1 2.49-.36.27-.52.78-.24 1.14.59.77 1.27 1.45 2.04 2.04.36.28.87.12 1.14-.24.7-.95 1.7-1.43 2.49-1.1.8.33 1.16 1.37.98 2.53-.07.45.18.93.64.99a11.1 11.1 0 0 0 2.88 0c.46-.06.7-.54.64-.99-.18-1.16.19-2.2.98-2.53.8-.33 1.79.14 2.49 1.1.27.36.78.52 1.14.24.77-.59 1.45-1.27 2.04-2.04.28-.36.12-.87-.24-1.14-.96-.7-1.43-1.7-1.1-2.49.33-.8 1.37-1.16 2.53-.98.45.07.93-.18.99-.64a11.1 11.1 0 0 0 0-2.88c-.06-.46-.54-.7-.99-.64-1.16.18-2.2-.19-2.53-.98-.33-.8.14-1.79 1.1-2.49.36-.27.52-.78.24-1.14a11.07 11.07 0 0 0-2.04-2.04c-.36-.28-.87-.12-1.14.24-.7.96-1.7 1.43-2.49 1.1-.8-.33-1.16-1.37-.98-2.53.07-.45-.18-.93-.64-.99a11.1 11.1 0 0 0-2.88 0ZM16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z",
          clipRule: "evenodd"
        }
      )
    );
  }
  function CollapseListIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M7.3 2.3a1 1 0 0 1 1.4 0L12 5.58l3.3-3.3a1 1 0 1 1 1.4 1.42l-4 4a1 1 0 0 1-1.4 0l-4-4a1 1 0 0 1 0-1.42ZM2 12a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1ZM8.7 21.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L12 18.42l-3.3 3.3Z",
          clipRule: "evenodd"
        }
      )
    );
  }
  function AnimationCardControls({
    hasSettings,
    hasAccordions,
    expanded,
    setExpanded,
    enter,
    exit,
    setEnter,
    setExit,
    errors = [],
    forceOpenSettingsTooltip = false
  }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationCardControls" }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationCardControlsGroup", ...useMovable("controls") }, /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        tooltip: {
          text: hasSettings ? "Settings" : "No settings available",
          forceOpen: forceOpenSettingsTooltip
        },
        disabled: !hasSettings,
        active: expanded === "settings",
        onClick: stop(() => setExpanded("settings"))
      },
      /* @__PURE__ */ BdApi.React.createElement(SettingsIcon, { size: "xs", color: "currentColor" })
    ), hasAccordions && /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        tooltip: "Smooth Expand/Collapse",
        active: expanded === "accordions",
        onClick: stop(() => setExpanded("accordions"))
      },
      /* @__PURE__ */ BdApi.React.createElement(CollapseListIcon, { size: "xs", color: "currentColor" })
    ), !!errors.length && /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        tooltip: "An error occurred",
        onClick: stop(() => ErrorManager.showModal(errors))
      },
      /* @__PURE__ */ BdApi.React.createElement(CircleWarningIcon, { size: "xs", color: colors.STATUS_DANGER })
    )), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationCardControlsToggle", ...useMovable("toggle") }, /* @__PURE__ */ BdApi.React.createElement(
      AnimationToggleControl,
      {
        enter,
        exit,
        setEnter,
        setExit
      }
    )));
  }
  css`.BA__animationCardControls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    min-height: 36px;
}

.BA__animationCardControlsGroup {
    display: flex;
    gap: 8px;
    padding-left: 10px;
}``AnimationCardControls`;
  function useLatest(value) {
    const ref = require$$0$1.useRef(value);
    require$$0$1.useEffect(() => {
      ref.current = value;
    }, [value]);
    return ref;
  }
  function useCustomCompareEffect(effect, deps, depsEqual) {
    const ref = require$$0$1.useRef(void 0);
    const forceUpdate = useUpdate();
    if (!ref.current) {
      ref.current = deps;
    }
    require$$0$1.useLayoutEffect(() => {
      if (!depsEqual(deps, ref.current)) {
        ref.current = deps;
        forceUpdate();
      }
    });
    require$$0$1.useEffect(effect, ref.current);
  }
  function useDeepCompareEffect(effect, deps) {
    useCustomCompareEffect(effect, deps, isEqual);
  }
  function getTargetElement(target, defaultElement = void 0) {
    if (!target) return defaultElement;
    if (typeof target === "function") return target();
    if ("current" in target) return target.current;
    return target;
  }
  function on(obj, ...args) {
    if (obj && obj.addEventListener) obj.addEventListener(...args);
  }
  function off(obj, ...args) {
    if (obj && obj.removeEventListener) obj.removeEventListener(...args);
  }
  function useEventListener(eventName, handler2, element2, options) {
    const savedHandler = useLatest(handler2);
    useDeepCompareEffect(() => {
      const targetElement = getTargetElement(element2, window);
      if (!(targetElement && targetElement.addEventListener)) {
        return;
      }
      const eventListener = (event) => savedHandler.current(event);
      on(targetElement, eventName, eventListener, options);
      return () => {
        if (!(targetElement && targetElement.removeEventListener)) {
          return;
        }
        off(targetElement, eventName, eventListener);
      };
    }, [eventName, element2, options]);
  }
  function useHover(target) {
    const [hovered, setHovered] = require$$0$1.useState(false);
    const onMouseEnter = require$$0$1.useCallback(() => setHovered(true), []);
    const onMouseLeave = require$$0$1.useCallback(() => setHovered(false), []);
    useEventListener("mouseenter", onMouseEnter, target);
    useEventListener("mouseleave", onMouseLeave, target);
    return hovered;
  }
  var shim = { exports: {} };
  var useSyncExternalStoreShim_production = {};
  /**
   * @license React
   * use-sync-external-store-shim.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredUseSyncExternalStoreShim_production;
  function requireUseSyncExternalStoreShim_production() {
    if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
    hasRequiredUseSyncExternalStoreShim_production = 1;
    var React = require$$0$1;
    function is(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue;
    function useSyncExternalStore$2(subscribe2, getSnapshot) {
      var value = getSnapshot(), _useState = useState({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
      useLayoutEffect(
        function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        },
        [subscribe2, value, getSnapshot]
      );
      useEffect(
        function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          return subscribe2(function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          });
        },
        [subscribe2]
      );
      useDebugValue(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error2) {
        return true;
      }
    }
    function useSyncExternalStore$1(subscribe2, getSnapshot) {
      return getSnapshot();
    }
    var shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
    useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim2;
    return useSyncExternalStoreShim_production;
  }
  var useSyncExternalStoreShim_development = {};
  /**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredUseSyncExternalStoreShim_development;
  function requireUseSyncExternalStoreShim_development() {
    if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
    hasRequiredUseSyncExternalStoreShim_development = 1;
    "production" !== process.env.NODE_ENV && function() {
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      function useSyncExternalStore$2(subscribe2, getSnapshot) {
        didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe2, value, getSnapshot]
        );
        useEffect(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe2(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe2]
        );
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe2, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React = require$$0$1, objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      useSyncExternalStoreShim_development.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim2;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
    return useSyncExternalStoreShim_development;
  }
  var hasRequiredShim;
  function requireShim() {
    if (hasRequiredShim) return shim.exports;
    hasRequiredShim = 1;
    if (process.env.NODE_ENV === "production") {
      shim.exports = requireUseSyncExternalStoreShim_production();
    } else {
      shim.exports = requireUseSyncExternalStoreShim_development();
    }
    return shim.exports;
  }
  var shimExports = requireShim();
  function subscribe(callback) {
    window.addEventListener("resize", callback);
    return () => {
      window.removeEventListener("resize", callback);
    };
  }
  function useWindowSize() {
    const stateDependencies = require$$0$1.useRef({}).current;
    const previous = require$$0$1.useRef({
      width: 0,
      height: 0
    });
    const isEqual2 = (prev, current) => {
      for (const t in stateDependencies) {
        if (current[t] !== prev[t]) {
          return false;
        }
      }
      return true;
    };
    const cached = shimExports.useSyncExternalStore(
      subscribe,
      () => {
        const data2 = {
          width: window.innerWidth,
          height: window.innerHeight
        };
        if (!isEqual2(previous.current, data2)) {
          previous.current = data2;
          return data2;
        }
        return previous.current;
      },
      () => {
        return previous.current;
      }
    );
    return {
      get width() {
        stateDependencies.width = true;
        return cached.width;
      },
      get height() {
        stateDependencies.height = true;
        return cached.height;
      }
    };
  }
  function useConfig() {
    useEmitterEffect(Events.SettingsChanged);
    const config2 = Config.current;
    const onChange = require$$0$1.useCallback(() => Emitter.emit(Events.SettingsChanged), []);
    return {
      config: config2,
      onChange,
      save: () => Config.save(),
      load: () => Config.load()
    };
  }
  function Hint({ href, onClick, ...props }) {
    const { config: config2 } = useConfig();
    if (config2.general.disableHints) return null;
    return /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        onClick: href ? () => handleClick({ href }) : () => {
        },
        ...props
      },
      /* @__PURE__ */ BdApi.React.createElement(CircleQuestionIcon, { size: "xs", color: "currentColor" })
    );
  }
  function SettingControl({ label, doc: doc2, onReset, children: children2 }) {
    return /* @__PURE__ */ BdApi.React.createElement(FormItem, { className: "BA__settingControl" }, /* @__PURE__ */ BdApi.React.createElement(FormTitle, { tag: "h5", className: "BA__settingControlHeader" }, /* @__PURE__ */ BdApi.React.createElement("span", null, label), doc2 && /* @__PURE__ */ BdApi.React.createElement(Hint, { href: Documentation.getSettingUrl(doc2) }), onReset && /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        className: "BA__settingControlReset",
        tooltip: "Reset",
        onClick: onReset
      },
      /* @__PURE__ */ BdApi.React.createElement(RedoIcon, { size: "xs", color: "currentColor" })
    )), children2);
  }
  css`.BA__settingControlHeader {
    display: flex;
    align-items: center;
    gap: 4px;
}
.BA__settingControlReset {
    margin-left: auto;
}``SettingControl`;
  const range = (start, stop2, step) => Array.from({ length: (stop2 - start) / step + 1 }, (_, i) => start + i * step);
  function findInReactTree(tree, searchFilter) {
    return Utils.findInTree(tree, searchFilter, { walkable: ["props", "children"] });
  }
  const byClassName = (className) => (m) => m?.props?.className?.includes(className);
  class Slider extends Slider$1 {
    static getDerivedStateFromProps(props, state) {
      const original = super.getDerivedStateFromProps(props, state);
      const derived = "value" in props && props.value !== state.valueProp ? {
        value: props.value,
        valueProp: props.value
      } : null;
      if (!original && !derived) return null;
      return Object.assign({}, original, derived);
    }
    render() {
      const { forceShowBubble = false, onValueRender } = this.props;
      const value = super.render();
      if (forceShowBubble) {
        TinyPatcher.after(value.props, "children", (self2, args, value2) => {
          const tooltip = findInReactTree(value2, (m) => m?.type === Tooltip$1);
          if (!tooltip) return;
          tooltip.props.text = onValueRender(this.state.value);
        });
      }
      return value;
    }
    componentDidUpdate(...args) {
      super.componentDidUpdate?.(...args);
      if (this.props.stickToMarkers) {
        const value = this.unscaleValue(
          this.state.markerPositions[this.state.newClosestIndex ?? this.state.closestMarkerIndex]
        );
        if (Math.abs(this.state.value - value) > 1e-6) this.setState({ value });
      }
    }
  }
  function DurationSlider({
    from,
    to,
    dense = to - from <= 2e3,
    step = dense ? 50 : 100,
    ...props
  }) {
    const markers = range(from - from % step, to, step);
    const onMarkerRender = (v) => v % 500 === 0 || [from, to].includes(v) ? (v / 1e3).toFixed(1) + "s" : to - from <= 3e3 && v % 100 === 0 ? "" : null;
    const onValueRender = (value) => (value / 1e3).toFixed(dense ? 2 : 1) + "s";
    return /* @__PURE__ */ BdApi.React.createElement(
      Slider,
      {
        minValue: from,
        maxValue: to,
        markers,
        onMarkerRender,
        stickToMarkers: true,
        forceShowBubble: true,
        onValueRender,
        ...props
      }
    );
  }
  function DurationControl({ animation, value, onChange, label = "Duration", onReset, ...props }) {
    const { to, from } = animation.settings[AnimationSetting.Duration];
    return /* @__PURE__ */ BdApi.React.createElement(SettingControl, { label, doc: Documentation.Setting.Duration, onReset }, /* @__PURE__ */ BdApi.React.createElement(
      DurationSlider,
      {
        ...props,
        from,
        to,
        initialValue: value,
        onValueChange: onChange
      }
    ));
  }
  function EasingField({ label, children: children2 }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__easingField" }, /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__easingFieldLabel",
        variant: "text-xs/medium",
        color: "text-muted"
      },
      label
    ), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__easingFieldControl" }, children2));
  }
  function EasingValueSlider({ options, value, onChange, ...props }) {
    const {
      min,
      max: max2,
      default: defaultValue,
      fractionDigits = 0
    } = options;
    const [draftValue, setDraftValue] = require$$0$1.useState(value.toFixed(fractionDigits));
    require$$0$1.useEffect(() => setDraftValue(value.toFixed(fractionDigits)), [value]);
    function onSubmit() {
      let value2 = Number(parseFloat(draftValue).toFixed(fractionDigits));
      value2 = Math.max(min, Math.min(max2, !isNaN(value2) ? value2 : defaultValue));
      onChange(value2);
      setDraftValue(value2.toFixed(fractionDigits));
    }
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__easingValueSliderWrapper" }, /* @__PURE__ */ BdApi.React.createElement(
      Slider,
      {
        className: "BA__easingValueSlider",
        minValue: min,
        maxValue: max2,
        onValueRender: (value2) => value2.toFixed(fractionDigits),
        value,
        initialValue: value,
        onValueChange: (value2) => onChange(Number(value2.toFixed(fractionDigits))),
        ...props
      }
    ), /* @__PURE__ */ BdApi.React.createElement(
      "form",
      {
        className: "BA__easingValueSliderInput",
        onSubmit: prevent(onSubmit)
      },
      /* @__PURE__ */ BdApi.React.createElement(
        TextInput,
        {
          value: draftValue,
          onChange: setDraftValue,
          onBlur: onSubmit
        }
      )
    ));
  }
  function buildEasingValueSliders(type, items2, { easing }) {
    return items2.map(([key2, label]) => /* @__PURE__ */ BdApi.React.createElement(EasingField, { label }, /* @__PURE__ */ BdApi.React.createElement(
      EasingValueSlider,
      {
        options: easingValues[type][key2],
        value: easing[key2],
        onChange: (value) => easing[key2] = value
      }
    )));
  }
  function EasingBezierSelect({ value, onChange }) {
    return /* @__PURE__ */ BdApi.React.createElement(EasingField, { label: "Bezier" }, /* @__PURE__ */ BdApi.React.createElement(
      SingleSelect,
      {
        options: easingBeziers,
        value,
        onChange
      }
    ));
  }
  function EasingEaseControl({ easing }) {
    return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(
      EasingBezierSelect,
      {
        value: easing.bezier,
        onChange: (bezier) => easing.bezier = bezier
      }
    ), /* @__PURE__ */ BdApi.React.createElement(EasingField, { label: "Style" }, /* @__PURE__ */ BdApi.React.createElement(
      SingleSelect,
      {
        options: easingStyles,
        value: easing.style,
        onChange: (style2) => easing.style = style2
      }
    )));
  }
  function EasingBackControl({ easing }) {
    return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(
      EasingBezierSelect,
      {
        value: easing.bezier,
        onChange: (bezier) => easing.bezier = bezier
      }
    ), buildEasingValueSliders(EasingType.Back, [
      ["overshoot", "Overshoot"]
    ], { easing }));
  }
  function EasingElasticControl({ easing }) {
    return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(
      EasingBezierSelect,
      {
        value: easing.bezier,
        onChange: (bezier) => easing.bezier = bezier
      }
    ), buildEasingValueSliders(EasingType.Elastic, [
      ["amplitude", "Amplitude"],
      ["period", "Period"]
    ], { easing }));
  }
  function EasingStepsControl({ easing }) {
    return /* @__PURE__ */ BdApi.React.createElement(EasingField, { label: "Amount" }, /* @__PURE__ */ BdApi.React.createElement(
      EasingValueSlider,
      {
        options: easingValues[EasingType.Steps]["amount"],
        value: easing.amount,
        onChange: (amount) => easing.amount = Math.round(amount)
      }
    ));
  }
  function EasingControl({ value, onChange, onReset }) {
    const easing = require$$0$1.useMemo(() => new Proxy(value, {
      set(obj, key2, value2) {
        onChange({ ...obj, [key2]: value2 });
        return true;
      }
    }), [value, onChange]);
    const AdditionalControl = require$$0$1.useMemo(
      () => ({
        [EasingType.Ease]: EasingEaseControl,
        [EasingType.Back]: EasingBackControl,
        [EasingType.Elastic]: EasingElasticControl,
        [EasingType.Steps]: EasingStepsControl
      })[easing.type] ?? null,
      [easing.type]
    );
    return /* @__PURE__ */ BdApi.React.createElement(SettingControl, { label: "Easing", doc: Documentation.Setting.Easing, onReset }, /* @__PURE__ */ BdApi.React.createElement(
      SingleSelect,
      {
        options: easingTypes,
        value: easing.type,
        onChange: (type) => onChange({ type })
      }
    ), AdditionalControl && /* @__PURE__ */ BdApi.React.createElement(AdditionalControl, { easing }));
  }
  css`.BA__easingField {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-top: 8px;
}
.BA__easingFieldLabel {
    text-transform: uppercase;
    flex-shrink: 0;
    width: 70px;
}
.BA__easingFieldControl {
    flex-grow: 1;
}

.BA__easingValueSliderWrapper {
    display: flex;
    align-items: center;
    gap: 8px;
}
.BA__easingValueSlider {
    flex-grow: 1;
}
.BA__easingValueSliderInput {
    width: 60px;
    flex-shrink: 0;
}``EasingControl`;
  function VariantControl({ animation, value, onChange, defaultValue, onReset }) {
    const options = animation.settings[AnimationSetting.Variant].map((o) => ({ label: o.name, value: o.key }));
    return /* @__PURE__ */ BdApi.React.createElement(SettingControl, { label: "Variant", doc: Documentation.Setting.Variant, onReset }, /* @__PURE__ */ BdApi.React.createElement(
      SingleSelect,
      {
        placeholder: defaultValue,
        options,
        value,
        onChange
      }
    ));
  }
  const positions = [
    { value: Auto(Position).Auto, label: "Auto" },
    { value: Position.TopLeft, label: "Top Left" },
    { value: Position.Top, label: "Top" },
    { value: Position.TopRight, label: "Top Right" },
    { value: Position.Left, label: "Left" },
    { value: Position.Center, label: "Center" },
    { value: Position.Right, label: "Right" },
    { value: Position.BottomLeft, label: "Bottom Left" },
    { value: Position.Bottom, label: "Bottom" },
    { value: Position.BottomRight, label: "Bottom Right" }
  ];
  function PositionPreserveControl({ value, onChange, label = "Preserve" }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      Checkbox,
      {
        className: DiscordClasses.Margins.marginTop8,
        value,
        onChange: (_, value2) => onChange(value2),
        type: CheckboxTypes.INVERTED
      },
      /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-sm/normal" }, label)
    );
  }
  function PositionControl({ module: module2, animation, value, onChange, defaultValue, preserve, onPreserveChange, onReset }) {
    const options = positions.filter(
      (p) => p.value === Auto() ? module2?.supportsAuto(animation, AnimationSetting.Position) : animation.settings[AnimationSetting.Position] === true || animation.settings[AnimationSetting.Position].includes(p.value)
    );
    const auto2 = module2?.getSupportsAuto(AnimationSetting.Position);
    const additionalControl = value === Auto(Position).Auto ? {
      [PositionAutoType.Precise]: auto2?.options.preservable && /* @__PURE__ */ BdApi.React.createElement(
        PositionPreserveControl,
        {
          value: preserve,
          onChange: onPreserveChange,
          label: auto2?.options.preserveLabel
        }
      )
    }[auto2?.type] : null;
    return /* @__PURE__ */ BdApi.React.createElement(SettingControl, { label: "Position", doc: Documentation.Setting.Position, onReset }, /* @__PURE__ */ BdApi.React.createElement(
      SingleSelect,
      {
        placeholder: defaultValue,
        options,
        value,
        onChange
      }
    ), additionalControl);
  }
  const directions = [
    { value: Auto(Direction).Auto, label: "Auto" },
    { value: Direction.Upwards, label: "Upwards" },
    { value: Direction.Downwards, label: "Downwards" },
    { value: Direction.Leftwards, label: "Leftwards" },
    { value: Direction.Rightwards, label: "Rightwards" },
    { value: Direction.Forwards, label: "Forwards" },
    { value: Direction.Backwards, label: "Backwards" }
  ];
  const directionAxes = [
    { value: Axis.Y, name: "Vertical", desc: "Automatically choose between Upwards and Downwards" },
    { value: Axis.X, name: "Horizontal", desc: "Automatically choose between Leftwards and Rightwards" },
    { value: Axis.Z, name: "Depth", desc: "Automatically choose between Forwards and Backwards" }
  ];
  const directionAnchorOptions = [
    { value: false, name: "Away", desc: "Move away from the anchor" },
    { value: true, name: "Towards", desc: "Move towards the anchor" }
  ];
  function HorizontalIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: "none",
          stroke: typeof color === "string" ? color : color.css,
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "2",
          d: "M3 12h18M3 12l3 3m-3-3l3-3m15 3l-3-3m3 3l-3 3"
        }
      )
    );
  }
  function VerticalIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: "none",
          stroke: typeof color === "string" ? color : color.css,
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "2",
          d: "M12 21V3m0 18l3-3m-3 3l-3-3m3-15L9 6m3-3l3 3"
        }
      )
    );
  }
  function DepthIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          strokeWidth: "2",
          d: "M12,22C12,22,12,22,12,22L12,22c-0.5,0-0.9-0.1-1.2-0.2c-0.4-0.2-0.7-0.4-1-0.7l-6.6-6.9c-0.6-0.7-0.2-1.6,0.9-2.2\r\n	c1-0.5,2.4-0.5,3,0l2.5,2l1.2-10.7L9.3,3.7C8.7,3.9,8,3.9,7.6,3.7C7.2,3.5,7.3,3.3,7.8,3.1l3.5-1c0.1,0,0.2-0.1,0.3-0.1\r\n	c0.1,0,0.2,0,0.4,0l0,0c0,0,0,0,0,0l0,0c0.1,0,0.3,0,0.4,0c0.1,0,0.2,0,0.3,0.1l3.5,1c0.5,0.2,0.6,0.4,0.2,0.6\r\n	c-0.4,0.2-1.2,0.2-1.7,0l-1.6-0.5l1.2,10.7l2.5-2c0.7-0.5,2-0.5,3,0c1.1,0.6,1.6,1.5,0.9,2.2l-6.6,6.9c-0.3,0.3-0.6,0.5-1,0.7\r\n	C12.9,21.9,12.5,22,12,22L12,22C12,22,12,22,12,22z"
        }
      )
    );
  }
  function RepeatIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "g",
        {
          fill: "none",
          stroke: typeof color === "string" ? color : color.css,
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "2"
        },
        /* @__PURE__ */ BdApi.React.createElement("path", { d: "m17 2l4 4l-4 4" }),
        /* @__PURE__ */ BdApi.React.createElement("path", { d: "M3 11v-1a4 4 0 0 1 4-4h14M7 22l-4-4l4-4" }),
        /* @__PURE__ */ BdApi.React.createElement("path", { d: "M21 13v1a4 4 0 0 1-4 4H3" })
      )
    );
  }
  function ArrowLeftToLineIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: "none",
          stroke: typeof color === "string" ? color : color.css,
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "2",
          d: "M3 19V5m10 1l-6 6l6 6m-6-6h14"
        }
      )
    );
  }
  function ArrowRightFromLineIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: "none",
          stroke: typeof color === "string" ? color : color.css,
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "2",
          d: "M3 5v14m18-7H7m8 6l6-6l-6-6"
        }
      )
    );
  }
  function getAxisIcon(axis) {
    switch (axis) {
      case Axis.Y:
        return /* @__PURE__ */ BdApi.React.createElement(VerticalIcon, { color: "currentColor" });
      case Axis.X:
        return /* @__PURE__ */ BdApi.React.createElement(HorizontalIcon, { color: "currentColor" });
      case Axis.Z:
        return /* @__PURE__ */ BdApi.React.createElement(DepthIcon, { color: "currentColor" });
    }
  }
  function getAnchorIcon(isTowards) {
    return isTowards ? /* @__PURE__ */ BdApi.React.createElement(ArrowLeftToLineIcon, { color: "currentColor" }) : /* @__PURE__ */ BdApi.React.createElement(ArrowRightFromLineIcon, { color: "currentColor" });
  }
  function DirectionAxisControl({ animation, value, onChange, reverse, onReverseChange }) {
    const axisOptions = directionAxes.filter(
      (a) => animation.settings.direction === true || getDirectionsByAxis(a.value).every((d) => animation.settings.direction.includes(d))
    );
    const options = axisOptions.map((option) => ({
      value: option.value,
      children: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, getAxisIcon(option.value), /* @__PURE__ */ BdApi.React.createElement("span", null, option.name))
    }));
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__directionAxisControl" }, /* @__PURE__ */ BdApi.React.createElement(
      ButtonGroup,
      {
        className: "BA__directionAxisControlSelect",
        size: "lg",
        options,
        selected: value,
        onChange
      }
    ), /* @__PURE__ */ BdApi.React.createElement(
      ButtonGroup,
      {
        className: "BA__directionAxisControlReverse",
        size: "lg",
        multiple: true,
        options: [{
          children: /* @__PURE__ */ BdApi.React.createElement(RepeatIcon, { color: "currentColor" }),
          tooltip: "Reverse",
          selected: reverse,
          onClick: () => onReverseChange(!reverse)
        }]
      }
    ));
  }
  function DirectionAnchorControl({ value, onChange }) {
    const options = directionAnchorOptions.map((option) => ({
      value: option.value,
      children: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, getAnchorIcon(option.value), /* @__PURE__ */ BdApi.React.createElement("span", null, option.name))
    }));
    return /* @__PURE__ */ BdApi.React.createElement(
      ButtonGroup,
      {
        className: DiscordClasses.Margins.marginTop8,
        size: "lg",
        options,
        selected: value,
        onChange
      }
    );
  }
  function DirectionControl({ module: module2, animation, value, onChange, defaultValue, axis, onAxisChange, reverse, onReverseChange, towards, onTowardsChange, onReset }) {
    const options = directions.filter(
      (d) => d.value === Auto() ? module2?.supportsAuto(animation, AnimationSetting.Direction) : animation.settings[AnimationSetting.Direction] === true || animation.settings[AnimationSetting.Direction].includes(d.value)
    );
    const additionalControl = value === Auto(Direction).Auto ? {
      [DirectionAutoType.Alternate]: /* @__PURE__ */ BdApi.React.createElement(
        DirectionAxisControl,
        {
          animation,
          value: axis,
          onChange: onAxisChange,
          reverse,
          onReverseChange
        }
      ),
      [DirectionAutoType.Anchor]: /* @__PURE__ */ BdApi.React.createElement(
        DirectionAnchorControl,
        {
          value: towards,
          onChange: onTowardsChange
        }
      )
    }[module2?.getSupportsAuto(AnimationSetting.Direction).type] : null;
    return /* @__PURE__ */ BdApi.React.createElement(SettingControl, { label: "Direction", doc: Documentation.Setting.Direction, onReset }, /* @__PURE__ */ BdApi.React.createElement(
      SingleSelect,
      {
        placeholder: defaultValue,
        options,
        value,
        onChange
      }
    ), additionalControl);
  }
  css`.BA__directionAxisControl {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
}
.BA__directionAxisControlSelect {
    flex-grow: 1;
}
.BA__directionAxisControlReverse {
    flex-shrink: 0;
}``DirectionControl`;
  function OverflowControl({ value, onChange, forced = false, onReset }) {
    const control = (props) => /* @__PURE__ */ BdApi.React.createElement("div", { ...props }, /* @__PURE__ */ BdApi.React.createElement(
      Checkbox,
      {
        value,
        onChange: (_, value2) => onChange(value2),
        type: CheckboxTypes.INVERTED,
        disabled: forced
      },
      /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-sm/normal" }, "Enable overflow")
    ));
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__overflowControl" }, forced ? /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: "Forced by the animation", hideOnClick: false }, control) : control(), /* @__PURE__ */ BdApi.React.createElement(Hint, { href: Documentation.getSettingUrl(Documentation.Setting.Overflow) }), !forced && onReset && /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        className: "BA__overflowControlReset",
        tooltip: "Reset",
        onClick: onReset
      },
      /* @__PURE__ */ BdApi.React.createElement(RedoIcon, { size: "xs", color: "currentColor" })
    ));
  }
  css`.BA__overflowControl {
    display: flex;
    align-items: center;
    gap: 4px;
}
.BA__overflowControlReset {
    margin-left: auto;
}``OverflowControl`;
  function SettingList({ children: children2, className = "BA__animationSettingsList" }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className }, typeof children2 === "function" ? children2() : children2.map((item) => {
      if (!item) return /* @__PURE__ */ BdApi.React.createElement("div", null);
      return /* @__PURE__ */ BdApi.React.createElement(Setting, { ...item });
    }));
  }
  function SettingGroup({ children: children2, className }) {
    return /* @__PURE__ */ BdApi.React.createElement(SettingList, { className: classNames("BA__animationSettingsGroup", className) }, children2);
  }
  function Setting({ type, ...props }) {
    if (type === AnimationSettingContainer.List) return /* @__PURE__ */ BdApi.React.createElement(SettingList, { ...props });
    if (type === AnimationSettingContainer.Group) return /* @__PURE__ */ BdApi.React.createElement(SettingGroup, { ...props });
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationSettingsItem" }, require$$0$1.createElement(
      {
        [AnimationSetting.Duration]: DurationControl,
        [AnimationSetting.Easing]: EasingControl,
        [AnimationSetting.Variant]: VariantControl,
        [AnimationSetting.Position]: PositionControl,
        [AnimationSetting.Direction]: DirectionControl,
        [AnimationSetting.Overflow]: OverflowControl
      }[type],
      props
    ));
  }
  function AnimationSettingsHeader({ headers }) {
    return /* @__PURE__ */ BdApi.React.createElement(SettingGroup, { className: "BA__animationSettingsHeaderGroup" }, () => headers.map(({ key: key2, title, subtitle, headerAfter, enabled, setEnabled, onReset, switchTooltip }) => /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationSettingsItem BA__animationSettingsHeader", key: key2 }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationSettingsHeading" }, /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "heading-lg/semibold", lineClamp: 1 }, title), subtitle && /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        tag: "span",
        variant: "heading-md/normal",
        color: "header-muted"
      },
      subtitle
    ), headerAfter), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationSettingsHeaderControls" }, onReset && /* @__PURE__ */ BdApi.React.createElement(IconButton, { tooltip: "Reset all", onClick: onReset }, /* @__PURE__ */ BdApi.React.createElement(RedoIcon, { size: "sm", color: "currentColor" })), typeof enabled === "boolean" && /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: switchTooltip, hideOnClick: false }, (props) => /* @__PURE__ */ BdApi.React.createElement("div", { ...props }, /* @__PURE__ */ BdApi.React.createElement(Switch$1, { checked: enabled, disabled: !setEnabled, onChange: setEnabled })))))));
  }
  function AnimationSettings({ headers, settings }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationSettings" }, /* @__PURE__ */ BdApi.React.createElement(AnimationSettingsHeader, { headers }), settings.map(Setting));
  }
  css`.BA__animationSettings {
    position: relative;
    isolation: isolate;
}
.BA__animationSettings::before,
.BA__animationSettingsHeaderGroup::before {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 50%;
    border-right: 1px solid var(--border-subtle);
    z-index: -1;
}
.BA__animationSettings, .BA__animationSettingsList {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.BA__animationSettingsGroup {
    display: flex;
    gap: 40px;
}
.BA__animationSettingsGroup > * {
    flex: 1;
}

.BA__animationSettingsItem {
    background-color: var(--background-base-lowest);
    box-shadow: 0 -16px 0 var(--background-base-lowest),
                0 16px 0 var(--background-base-lowest);
}

.BA__animationSettingsHeaderGroup {
    position: sticky;
    top: 0;
    z-index: 100;
    isolation: isolate;
}
.BA__animationSettingsHeaderGroup::before {
    top: -20px;
    bottom: -16px;
}
.BA__animationSettingsHeaderGroup::after {
    content: '';
    position: absolute;
    top: -20px;
    left: -20px;
    right: -20px;
    bottom: -16px;
    background-color: var(--background-base-lowest);
    z-index: -2;
}
.BA__animationSettingsHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 16px;
    padding-bottom: 4px;
    box-shadow: 0 -20px 0 var(--background-base-lowest),
                0 16px 0 var(--background-base-lowest);
    min-width: 0;
}
.BA__animationSettingsHeading {
    display: flex;
    gap: 8px;
    min-width: 0;
    align-items: flex-end;
}
.BA__animationSettingsHeaderControls {
    display: flex;
    gap: 10px;
    align-items: center;
}``AnimationSettings`;
  function useResizeObserver(target, callback, options = {}) {
    const savedCallback = useLatest(callback);
    const observerRef = require$$0$1.useRef();
    const stop2 = require$$0$1.useCallback(() => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    }, []);
    useDeepCompareEffect(() => {
      const element2 = getTargetElement(target);
      if (!element2) {
        return;
      }
      observerRef.current = new ResizeObserver(savedCallback.current);
      observerRef.current.observe(element2, options);
      return stop2;
    }, [savedCallback, stop2, target, options]);
    return stop2;
  }
  function useElementBounding(target, options = {}) {
    const {
      windowResize = true,
      windowScroll = true,
      immediate = true
    } = options;
    const update = useUpdate();
    useResizeObserver(target, update);
    require$$0$1.useLayoutEffect(() => {
      if (immediate) update();
    }, [immediate, update]);
    require$$0$1.useEffect(() => {
      if (windowScroll) window.addEventListener("scroll", update, { passive: true });
      if (windowResize) window.addEventListener("resize", update, { passive: true });
      return () => {
        if (windowScroll) window.removeEventListener("scroll", update);
        if (windowResize) window.removeEventListener("resize", update);
      };
    }, [update, windowResize, windowScroll]);
    const bounding = getTargetElement(target)?.getBoundingClientRect();
    const boundingCached = require$$0$1.useRef();
    if (bounding) boundingCached.current = bounding;
    return {
      top: bounding?.top ?? boundingCached.current?.top ?? 0,
      left: bounding?.left ?? boundingCached.current?.left ?? 0,
      width: bounding?.width ?? boundingCached.current?.width ?? 0,
      height: bounding?.height ?? boundingCached.current?.height ?? 0,
      update
    };
  }
  function CircleInfoIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL, secondaryColor = "transparent" }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "circle",
        {
          cx: "12",
          cy: "12",
          r: "10",
          fill: typeof secondaryColor === "string" ? secondaryColor : secondaryColor.css
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M23 12a11 11 0 1 1-22 0 11 11 0 0 1 22 0Zm-9.5-4.75a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0Zm-.77 3.96a1 1 0 1 0-1.96-.42l-1.04 4.86a2.77 2.77 0 0 0 4.31 2.83l.24-.17a1 1 0 1 0-1.16-1.62l-.24.17a.77.77 0 0 1-1.2-.79l1.05-4.86Z",
          clipRule: "evenodd"
        }
      )
    );
  }
  function HintTooltip({ text: _text, color = Tooltip$1.Colors.BRAND, children: children2, ...props }) {
    const text2 = require$$0$1.useCallback(() => /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__hintTooltip" }, /* @__PURE__ */ BdApi.React.createElement(CircleInfoIcon, { size: "xs", color: "currentColor" }), /* @__PURE__ */ BdApi.React.createElement("span", null, _text)), [_text]);
    return /* @__PURE__ */ BdApi.React.createElement(
      Tooltip$1,
      {
        text: text2,
        color,
        ...props
      },
      children2
    );
  }
  css`.BA__hintTooltip {
    display: flex;
    gap: 4px;
}
.BA__hintTooltip > svg {
    flex-shrink: 0;
}``HintTooltip`;
  const DispatcherEvents = Enum({
    SET_SETTINGS_SECTION: "BA__SET_SETTINGS_SECTION",
    SET_ANIMATION_EXPANDED: "BA__SET_ANIMATION_EXPANDED"
  });
  const SettingsSection = Enum({
    Home: "home",
    Catalog: "catalog",
    Library: "library",
    General: "general"
  });
  let section = SettingsSection.Home;
  let animationExpanded = false;
  function handleSetSection({ section: _section }) {
    section = _section;
  }
  function handleSetAnimationExpanded({ value }) {
    animationExpanded = value;
  }
  const SettingsStore = new class SettingsStore extends Flux.Store {
    initialize() {
      [
        Events.ModuleToggled,
        Events.ModuleSettingsChanged,
        Events.SettingsChanged,
        Events.SettingsSaved,
        Events.MigratorUpdated
      ].forEach((event) => Emitter.on(event, this.emitChange.bind(this)));
    }
    getSection() {
      return section;
    }
    _getAnimationExpanded() {
      return animationExpanded;
    }
    isAnimationExpanded() {
      return animationExpanded !== false;
    }
    // Used by StandardSidebarView
    showNotice() {
      return !Config.migrator.isActive && Config.hasUnsavedChanges();
    }
  }(Dispatcher, {
    [DispatcherEvents.SET_SETTINGS_SECTION]: handleSetSection,
    [DispatcherEvents.SET_ANIMATION_EXPANDED]: handleSetAnimationExpanded
  });
  function setSection(section2) {
    Dispatcher.dispatch({
      type: DispatcherEvents.SET_SETTINGS_SECTION,
      section: section2
    });
  }
  function setAnimationExpanded(value) {
    Dispatcher.dispatch({
      type: DispatcherEvents.SET_ANIMATION_EXPANDED,
      value
    });
  }
  function useSection() {
    return [
      useStateFromStores([SettingsStore], () => SettingsStore.getSection()),
      setSection
    ];
  }
  function useIsAnimationExpanded(useValue = null) {
    const id = require$$0$1.useId();
    const clearIfNeeded = () => {
      if (SettingsStore._getAnimationExpanded() === id) setAnimationExpanded(false);
    };
    require$$0$1.useEffect(() => {
      if (useValue == null) return;
      if (useValue) setAnimationExpanded(id);
      else clearIfNeeded();
    }, [useValue]);
    require$$0$1.useEffect(() => clearIfNeeded, [id]);
    return useStateFromStores([SettingsStore], () => SettingsStore.isAnimationExpanded());
  }
  function getCardHeight(width) {
    return getPreviewHeight(width) + 36;
  }
  const CARD_WIDE_WIDTH = 320;
  const CARD_EXPANDED_WIDTH = 460;
  const CARD_EXPANDED_HEIGHT = getCardHeight(CARD_EXPANDED_WIDTH);
  const TOP_BAR_HEIGHT = 0;
  const TOP_OFFSET = TOP_BAR_HEIGHT + 40;
  const BOTTOM_OFFSET = 72 + 20;
  const POPOUT_GAP = 20;
  const MovableContext = require$$0$1.createContext({ styles: {} });
  const MOVABLE_ATTRIBUTE = "data-expand-movable";
  function useMovable(key2) {
    return {
      [MOVABLE_ATTRIBUTE]: key2,
      style: require$$0$1.use(MovableContext).styles[key2] ?? {}
    };
  }
  function useAnimationCardExpand({ expanded, positionerRef, cardRef, popoutRef, refToScroller }) {
    const window2 = useWindowSize();
    const positioner = {
      ...useElementBounding(positionerRef),
      width: positionerRef.current?.clientWidth ?? 0,
      height: positionerRef.current?.clientHeight ?? 0
    };
    const getScrollerNode = require$$0$1.useCallback(() => refToScroller.current?.getScrollerNode(), [refToScroller]);
    useEventListener("scroll", () => expanded && positioner.update(), getScrollerNode);
    const popout = useElementBounding(popoutRef);
    const update = require$$0$1.useCallback(() => {
      positioner.update();
      popout.update();
    }, [positioner.update, popout.update]);
    const popoutMaxHeight = window2.height - (TOP_OFFSET + CARD_EXPANDED_HEIGHT + POPOUT_GAP + BOTTOM_OFFSET);
    const totalHeight = CARD_EXPANDED_HEIGHT + POPOUT_GAP + popout.height;
    const top = Math.max(TOP_OFFSET, Math.min(window2.height - (BOTTOM_OFFSET + totalHeight), positioner.top));
    require$$0$1.useLayoutEffect(update, [expanded, top]);
    const [movableStyles, setMovableStyles] = require$$0$1.useState({});
    require$$0$1.useLayoutEffect(() => {
      if (!expanded || !cardRef.current) {
        setMovableStyles({});
        return;
      }
      const movables = Array.from(cardRef.current.querySelectorAll(`[${MOVABLE_ATTRIBUTE}]`));
      const store = (fn) => Object.fromEntries(
        movables.map((movable) => {
          const key2 = movable.getAttribute(MOVABLE_ATTRIBUTE);
          return [key2, fn(movable, key2)];
        })
      );
      const original = store((movable) => getRect(movable, positionerRef.current));
      cardRef.current.style.width = CARD_EXPANDED_WIDTH + "px";
      setMovableStyles(store((movable, key2) => {
        const rect = getRect(movable, positionerRef.current);
        return {
          transform: [
            `translate(${rect.x - original[key2].x}px, ${rect.y - original[key2].y}px)`,
            `scale(${rect.width / original[key2].width}, ${rect.height / original[key2].height})`
          ].join(" ")
        };
      }));
      cardRef.current.style.removeProperty("width");
    }, [expanded]);
    return {
      update,
      positionerStyle: {
        height: getCardHeight(positioner.width) + "px"
      },
      cardStyle: {
        transform: expanded ? `translateY(${top - positioner.top}px)` : "translateY(0)"
      },
      popoutWrapperStyle: {
        maxHeight: popoutMaxHeight + "px",
        transform: `translateY(${top + CARD_EXPANDED_HEIGHT + POPOUT_GAP - TOP_BAR_HEIGHT}px)`
      },
      popoutStyle: {
        transformOrigin: `${positioner.left + positioner.width / 2 - popout.left}px ${positioner.top + positioner.height / 2 - popout.top}px`
      },
      wrap: (children2) => /* @__PURE__ */ BdApi.React.createElement(MovableContext, { value: { styles: movableStyles } }, children2)
    };
  }
  function useQuickPreview(cardRef) {
    const { config: config2 } = useConfig();
    const hovered = useHover(cardRef);
    const [isActive, setIsActive] = require$$0$1.useState(hovered);
    const timeout = require$$0$1.useMemo(() => new Timeout(), []);
    require$$0$1.useEffect(() => {
      if (hovered) timeout.start(500, () => setIsActive(true));
      else {
        timeout.stop();
        setIsActive(false);
      }
    }, [hovered]);
    return config2.general.quickPreview && isActive;
  }
  function AnimationCard({
    pack,
    animation,
    name: name2 = animation?.name,
    enter,
    exit,
    setEnter,
    setExit,
    onClick,
    refToScroller,
    animationSettings,
    accordionsSettings,
    active = enter || exit,
    header = false,
    wide = header,
    errors
  }) {
    const positionerRef = require$$0$1.useRef();
    const settingsPopoutRef = require$$0$1.useRef();
    const accordionsPopoutRef = require$$0$1.useRef();
    const popoutRefs = require$$0$1.useMemo(() => ({
      settings: settingsPopoutRef,
      accordions: accordionsPopoutRef
    }), [settingsPopoutRef, accordionsPopoutRef]);
    const [expanded, setExpanded] = require$$0$1.useState(null);
    const close = require$$0$1.useCallback(() => setExpanded(null), [setExpanded]);
    const [isHeaderVisible, setIsHeaderVisible] = require$$0$1.useState(false);
    const cardRef = useIsVisible((isVisible) => header && setIsHeaderVisible(isVisible), 0.5);
    const isAnimationExpanded = useIsAnimationExpanded(header ? null : !!expanded);
    const {
      update,
      positionerStyle,
      cardStyle,
      popoutWrapperStyle,
      popoutStyle,
      wrap: wrap2
    } = useAnimationCardExpand({
      expanded,
      positionerRef,
      cardRef,
      popoutRef: popoutRefs[expanded],
      refToScroller
    });
    require$$0$1.useLayoutEffect(update, [animationSettings, accordionsSettings]);
    const isQuickPreview = useQuickPreview(cardRef);
    const [rightClickHint, setRightClickHint] = useDismissible("rightClickAnimationCard");
    require$$0$1.useEffect(() => {
      const onKeyDown = (e) => {
        if (e.key !== "Escape" || !expanded) return;
        close();
        e.preventDefault();
        e.stopPropagation();
      };
      document.addEventListener("keydown", onKeyDown);
      return () => {
        document.removeEventListener("keydown", onKeyDown);
      };
    }, [expanded, close]);
    useEventListener("wheel", (e) => {
      if (!expanded) return;
      e.stopPropagation();
      e.preventDefault();
    }, cardRef);
    const hasSettings = !!animationSettings.settings.length;
    const hasAccordions = !!accordionsSettings?.settings?.length;
    const [forceOpenSettingsTooltip, setForceOpenSettingsTooltip] = require$$0$1.useState(false);
    const expandSettings = (rightClick = false) => {
      if (expanded) return;
      if (!hasSettings && !hasAccordions) return setForceOpenSettingsTooltip(true);
      setExpanded(hasSettings ? "settings" : "accordions");
      if (rightClick === true && !rightClickHint && !header) setRightClickHint(true);
    };
    return wrap2(
      /* @__PURE__ */ BdApi.React.createElement(
        "div",
        {
          className: classNames(
            "BA__animationCardWrapper",
            {
              "BA__animationCard--expanded": expanded,
              "BA__animationCard--wide": wide,
              "BA__animationCard--active": active
            }
          )
        },
        /* @__PURE__ */ BdApi.React.createElement(
          HintTooltip,
          {
            text: "Right-click the card to open the settings",
            shouldShow: !rightClickHint && !!expandSettings && !expanded && hasSettings && !header
          },
          (props) => /* @__PURE__ */ BdApi.React.createElement(
            "div",
            {
              ref: positionerRef,
              className: "BA__animationCardPositioner",
              style: positionerStyle,
              ...props
            },
            /* @__PURE__ */ BdApi.React.createElement(
              Clickable,
              {
                innerRef: cardRef,
                tag: "div",
                className: "BA__animationCard",
                style: cardStyle,
                onClick: onClick ?? expandSettings,
                onContextMenu: () => expandSettings?.(true),
                onMouseLeave: () => setForceOpenSettingsTooltip(false)
              },
              /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationCardBg", ...useMovable("bg") }),
              /* @__PURE__ */ BdApi.React.createElement(
                AnimationPreview,
                {
                  className: "BA__animationCardPreview",
                  pack,
                  animation,
                  title: name2,
                  active: header && isHeaderVisible && !isAnimationExpanded || isQuickPreview || !!expanded
                }
              ),
              /* @__PURE__ */ BdApi.React.createElement(
                AnimationCardControls,
                {
                  enter,
                  exit,
                  setEnter,
                  setExit,
                  hasSettings,
                  hasAccordions,
                  expanded,
                  setExpanded,
                  errors,
                  forceOpenSettingsTooltip
                }
              )
            )
          )
        ),
        /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationCardBackdrop", onClick: close }),
        /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null }, expanded && /* @__PURE__ */ BdApi.React.createElement(
          CSSTransition,
          {
            key: expanded,
            nodeRef: popoutRefs[expanded],
            timeout: 400,
            classNames: "BA__fade",
            mountOnEnter: true,
            unmountOnExit: true
          },
          /* @__PURE__ */ BdApi.React.createElement("div", { ref: popoutRefs[expanded], className: "BA__animationCardPopoutWrapper", style: popoutWrapperStyle }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationCardPopout", style: popoutStyle }, /* @__PURE__ */ BdApi.React.createElement("div", { className: `BA__animationCardPopoutScroller ${DiscordClasses.Scroller.thin}` }, /* @__PURE__ */ BdApi.React.createElement(AnimationSettings, { ...{
            settings: animationSettings,
            accordions: accordionsSettings
          }[expanded] }))))
        ))
      )
    );
  }
  css`.BA__animationCardWrapper {
    min-width: 0;
}

[${MOVABLE_ATTRIBUTE}] {
    transform-origin: top left;
    transition: transform .4s;
}

.BA__animationCardBackdrop {
    position: absolute;
    inset: 0;
    z-index: 99;
    background-color: rgba(0, 0, 0, .8);
    opacity: 0;
    pointer-events: none;
    transition: opacity .4s;
}

.BA__animationCardPositioner {
    position: relative;
    display: flex;
}
.BA__animationCardWrapper:nth-child(3n - 1) .BA__animationCardPositioner {
    justify-content: center;
}
.BA__animationCardWrapper:nth-child(3n) .BA__animationCardPositioner {
    justify-content: flex-end;
}

.BA__animationCard {
    position: absolute;
    width: 100%;
    cursor: pointer;
    z-index: 10;
    transition: transform .4s, z-index .4s step-end;
    isolation: isolate;
}
.BA__animationCardBg {
    position: absolute;
    inset: 0;
    z-index: -1;
    background-color: var(--background-base-lowest);
    border-radius: 8px;
    box-shadow: 0 0 0 1px var(--border-subtle);
    transition: background-color .2s, box-shadow .2s, border-radius .4s, transform .4s;
}
.BA__animationCard:hover .BA__animationCardBg {
    background-color: var(--background-base-lower);
}
.BA__animationPreviewContainer.BA__animationCardPreview {
    border-radius: 8px 8px 0 0;
    box-shadow: none;
    background: var(--background-base-lowest);
}

.BA__animationCard--wide .BA__animationCardPositioner,
.BA__animationCard--wide .BA__animationCard {
    width: ${CARD_WIDE_WIDTH}px;
}

.BA__animationCard--expanded .BA__animationCardBackdrop {
    opacity: 1;
    pointer-events: all;
}
.BA__animationCard--expanded .BA__animationCard {
    z-index: 105;
    transition: transform .4s, z-index .4s step-start;
}
.BA__animationCard--expanded .BA__animationCardBg {
    border-radius: 4px;
    box-shadow: 0 0 0 .5px var(--border-subtle);
}
.BA__animationCard--expanded .BA__animationPreviewContainer {
    border-radius: 4px 4px 0 0;
}

.BA__animationCard--active .BA__animationCardBg {
    box-shadow: 0 0 0 2.5px var(--brand-500);
}
.BA__animationCard--active.BA__animationCard--expanded .BA__animationCardBg {
    box-shadow: 0 0 0 1.5px var(--brand-500);
}

.BA__animationCardPopoutWrapper {
    position: absolute;
    top: 0;
    left: 40px;
    right: 40px;
    z-index: 100;
    display: flex;
    transition: transform .4s, translate .4s;
}
.BA__animationCardPopout {
    background-color: var(--background-base-lowest);
    box-shadow: 0 0 0 1px var(--border-subtle);
    border-radius: 8px;
    overflow: hidden;
    flex: 1;
    display: flex;
}
.BA__animationCardPopoutScroller {
    position: relative;
    overflow: hidden scroll;
    padding: 20px;
    padding-right: 12px;
}
.BA__animationCardPopoutScroller::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 20px;
    background-color: var(--background-base-lowest);
    z-index: 110;
}

.BA__fade-enter, .BA__fade-exit-active {
    opacity: 0;
}
:is(.BA__fade-enter, .BA__fade-exit-active) > * {
    scale: .5;
}
.BA__fade-enter-active {
    opacity: 1;
}
.BA__fade-enter-active > * {
    scale: 1;
}
.BA__fade-enter-active, .BA__fade-exit-active {
    transition: opacity .4s;
}
.BA__fade-exit-active {
    pointer-events: none;
}
:is(.BA__fade-enter-active, .BA__fade-exit-active) > * {
    transition: scale .4s;
}``AnimationCard`;
  function EyeIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M15.56 11.77c.2-.1.44.02.44.23a4 4 0 1 1-4-4c.21 0 .33.25.23.44a2.5 2.5 0 0 0 3.32 3.32Z"
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M22.89 11.7c.07.2.07.4 0 .6C22.27 13.9 19.1 21 12 21c-7.11 0-10.27-7.11-10.89-8.7a.83.83 0 0 1 0-.6C1.73 10.1 4.9 3 12 3c7.11 0 10.27 7.11 10.89 8.7Zm-4.5-3.62A15.11 15.11 0 0 1 20.85 12c-.38.88-1.18 2.47-2.46 3.92C16.87 17.62 14.8 19 12 19c-2.8 0-4.87-1.38-6.39-3.08A15.11 15.11 0 0 1 3.15 12c.38-.88 1.18-2.47 2.46-3.92C7.13 6.38 9.2 5 12 5c2.8 0 4.87 1.38 6.39 3.08Z",
          clipRule: "evenodd"
        }
      )
    );
  }
  function RefreshIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          fillRule: "evenodd",
          d: "M21 2a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1h-6a1 1 0 1 1 0-2h3.93A8 8 0 0 0 6.97 5.78a1 1 0 0 1-1.26-1.56A9.98 9.98 0 0 1 20 6V3a1 1 0 0 1 1-1ZM3 22a1 1 0 0 1-1-1v-6a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H5.07a8 8 0 0 0 11.96 2.22 1 1 0 1 1 1.26 1.56A9.99 9.99 0 0 1 4 18v3a1 1 0 0 1-1 1Z",
          clipRule: "evenodd"
        }
      )
    );
  }
  function getPreviewHeight(width) {
    return width * 9 / 16;
  }
  function AnimationPreview({
    module: module2 = require$$0$1.use(ModuleContext),
    pack,
    animation,
    title = animation?.name,
    active = false,
    className
  }) {
    const { isActive: hasActiveAnimation } = require$$0$1.use(AnimeTransitionContext);
    const isActive = active && !hasActiveAnimation;
    const [dataKey, setDataKey] = require$$0$1.useState(0);
    require$$0$1.useEffect(() => moduleEffect(
      module2.id,
      () => setDataKey((key2) => key2 + 1),
      true
    ), [module2]);
    const containerRef = require$$0$1.useRef();
    const [scale, setScale] = require$$0$1.useState(1);
    const onUpdate = require$$0$1.useCallback(() => {
      setScale(containerRef.current.offsetWidth / PREVIEW_WIDTH);
    }, [setScale]);
    useResizeObserver(containerRef, onUpdate);
    require$$0$1.useLayoutEffect(onUpdate, []);
    const [error2, setError] = require$$0$1.useState(null);
    require$$0$1.useEffect(() => {
      if (!isActive) setError(null);
    }, [isActive]);
    const onError = require$$0$1.useCallback((error22) => {
      setError(error22);
      Logger.error("AnimationPreview", error22);
    }, [setError]);
    const { isMembersOpen: memberListShown = true } = useStateFromStores([ChannelSectionStore], () => ChannelSectionStore.getState());
    const modules2 = require$$0$1.useMemo(() => Core.getAllModules(true), []);
    const style2 = require$$0$1.useMemo(() => ({ scale }), [scale]);
    const preferences = require$$0$1.useMemo(() => ({ memberListShown }), [memberListShown]);
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        ref: containerRef,
        className: classNames("BA__animationPreviewContainer", className),
        ...useMovable("preview")
      },
      /* @__PURE__ */ BdApi.React.createElement(
        Preview$1,
        {
          className: classNames(
            getThemeClass("darker"),
            "BA__animationPreview"
          ),
          style: style2,
          key: module2.id,
          id: module2.id,
          modules: modules2,
          placeholder: !isActive || error2 != null,
          pack,
          animation,
          dataKey,
          preferences,
          onError
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement("div", { className: classNames(
        "BA__animationPreviewOverlay",
        { "BA__animationPreviewOverlay--hidden": (isActive || !title) && !error2 }
      ) }, error2 ? /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationPreviewError" }, /* @__PURE__ */ BdApi.React.createElement(CircleWarningIcon, { size: "lg", color: colors.STATUS_DANGER }), /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-sm/bold" }, "An error occurred."), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationPreviewErrorActions" }, /* @__PURE__ */ BdApi.React.createElement(
        IconButton,
        {
          tooltip: "View",
          onClick: stop(() => ErrorManager.showModal([error2]))
        },
        /* @__PURE__ */ BdApi.React.createElement(EyeIcon, { size: "sm", color: "currentColor" })
      ), /* @__PURE__ */ BdApi.React.createElement(
        IconButton,
        {
          tooltip: "Try again",
          onClick: stop(() => setError(null))
        },
        /* @__PURE__ */ BdApi.React.createElement(RefreshIcon, { size: "xs", color: "currentColor" })
      ))) : title ? /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "heading-sm/semibold", lineClamp: 2, color: "always-white" }, title) : null)
    );
  }
  css`.BA__animationPreviewContainer {
    position: relative;
    overflow: hidden;
    isolation: isolate;
    aspect-ratio: 16 / 9;
    border-radius: 4px;
    background: var(--background-base-low);
    display: flex;
    align-items: center;
    box-shadow: 0 0 0 1px var(--border-faint);
    transition: border-radius .4s, box-shadow .4s, transform .4s;
}
.BA__animationPreview {
    position: absolute;
    top: 50%;
    left: 50%;
    translate: -50% -50%;
}
.BA__animationPreview::after {
    content: '';
    position: absolute;
    inset: 0;
    box-shadow: inset 0 0 80px 0 rgba(0,0,0,.5);
    z-index: 10;
}
.BA__animationPreviewOverlay {
    position: absolute;
    inset: 0;
    padding: 12px;
    background: rgba(0, 0, 0, .1);
    backdrop-filter: blur(15px);
    transition: .4s;
    display: flex;
    flex-direction: column;
}
.BA__animationPreviewOverlay--hidden {
    opacity: 0;
    backdrop-filter: blur(0);
}
.BA__animationPreviewError {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 4px;
    text-align: center;
}
.BA__animationPreviewErrorActions {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 4px;
}``AnimationPreview`;
  function XIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M17.3 18.7a1 1 0 0 0 1.4-1.4L13.42 12l5.3-5.3a1 1 0 0 0-1.42-1.4L12 10.58l-5.3-5.3a1 1 0 0 0-1.4 1.42L10.58 12l-5.3 5.3a1 1 0 1 0 1.42 1.4L12 13.42l5.3 5.3Z"
        }
      )
    );
  }
  function ChevronSmallLeftIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M14.7 5.3a1 1 0 0 1 0 1.4L9.42 12l5.3 5.3a1 1 0 0 1-1.42 1.4l-6-6a1 1 0 0 1 0-1.4l6-6a1 1 0 0 1 1.42 0Z"
        }
      )
    );
  }
  function ChevronSmallRightIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M9.3 5.3a1 1 0 0 0 0 1.4l5.29 5.3-5.3 5.3a1 1 0 1 0 1.42 1.4l6-6a1 1 0 0 0 0-1.4l-6-6a1 1 0 0 0-1.42 0Z"
        }
      )
    );
  }
  function ErrorCard({ text: text2, actions, className, iconType = IconBrandTypes.ERROR, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { ...props, className: classNames("BA__errorCard", className) }, /* @__PURE__ */ BdApi.React.createElement(
      IconBrand,
      {
        type: iconType,
        size: "xl"
      }
    ), /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-md/bold" }, text2), actions && /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__errorCardActions" }, actions));
  }
  css`.BA__errorCard {
    padding: 16px;
    background-color: #e7828430;
    border: 1px solid #e78284;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 12px;
    text-align: center;
    min-width: 170px;
}
.BA__errorCard a:hover {
    text-decoration: underline;
}
.BA__errorCardActions {
    display: flex;
    align-items: center;
    gap: 8px;
}``ErrorCard`;
  function ModuleLabel({ module: module2 }) {
    const parent = Core.getParentModule(module2);
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__moduleLabel" }, parent && /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, parent.name, /* @__PURE__ */ BdApi.React.createElement(
      ChevronSmallRightIcon,
      {
        size: "xs",
        color: "currentColor"
      }
    )), module2.name);
  }
  function PackPreview({ pack, module: module2 }) {
    const animations2 = pack.animations.filter((a) => module2?.isSupportedBy(a));
    const [index2, setIndex] = require$$0$1.useState(0);
    const step = (step2) => setIndex((index22) => (animations2.length + index22 + step2) % animations2.length);
    useEventListener("keydown", (e) => {
      if (e.repeat) return;
      switch (e.code) {
        case "ArrowLeft":
          return step(-1);
        case "ArrowRight":
          return step(1);
      }
    });
    const animation = animations2[index2];
    require$$0$1.useEffect(() => {
      if (index2 >= animations2.length) setIndex(0);
    });
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packPreview" }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packPreviewContent" }, /* @__PURE__ */ BdApi.React.createElement(
      AnimationPreview,
      {
        key: animation?.key,
        className: "BA__packPreviewAnimation",
        module: module2,
        pack,
        animation,
        title: null,
        active: animation != null
      }
    )), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packPreviewFooter" }, animations2.length > 1 && /* @__PURE__ */ BdApi.React.createElement(
      Button$1,
      {
        variant: "icon-only",
        icon: ChevronSmallLeftIcon,
        onClick: () => step(-1)
      }
    ), animation && /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__packPreviewTitle",
        variant: "heading-lg/semibold",
        lineClamp: 1
      },
      animation.name
    ), animations2.length > 1 && /* @__PURE__ */ BdApi.React.createElement(
      Button$1,
      {
        variant: "icon-only",
        icon: ChevronSmallRightIcon,
        onClick: () => step(1)
      }
    )));
  }
  function usePack({ filename, location, onClose }) {
    const registry = usePackRegistry();
    const cachedPack = require$$0$1.useRef();
    const storedPack = location === PackContentLocation.CATALOG ? registry.getPack(filename) : PackManager.getPackByFile(filename, true);
    require$$0$1.useEffect(() => {
      if (!storedPack) onClose();
      else cachedPack.current = storedPack;
    }, [!storedPack]);
    return storedPack ?? cachedPack.current;
  }
  function useLoadedPack(pack, isRemote) {
    const registry = usePackRegistry();
    const remoteData = registry.storage.use(isRemote ? pack?.filename : null);
    return isRemote ? remoteData : { pack, loading: false, error: null };
  }
  function PackMeta({ pack }) {
    const meta2 = [];
    if (pack.createdAt) meta2.push(
      /* @__PURE__ */ BdApi.React.createElement(
        Timestamp,
        {
          timestamp: pack.createdAt,
          timestampFormat: "[Published] L"
        }
      )
    );
    if (pack.updatedAt) meta2.push(
      /* @__PURE__ */ BdApi.React.createElement(
        Timestamp,
        {
          timestamp: pack.updatedAt,
          timestampFormat: "[Updated] L"
        }
      )
    );
    const size = pack.size ?? pack.installed?.size;
    if (size) meta2.push(
      humanize.filesize(size)
    );
    if (pack.installed) {
      const modules2 = Core.getModulesUsingPack(pack.installed);
      meta2.push(
        /* @__PURE__ */ BdApi.React.createElement(
          Tooltip$1,
          {
            text: modules2.map((m) => m.name).join(", "),
            shouldShow: modules2.length > 0
          },
          (props) => /* @__PURE__ */ BdApi.React.createElement("span", { ...props }, modules2.length > 0 ? `Used in ${modules2.length} ${modules2.length > 1 ? "modules" : "module"}` : "Not used in any modules")
        )
      );
    }
    return /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__packModalMeta",
        variant: "text-sm/medium",
        color: "text-muted"
      },
      meta2.map((item, index2) => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, item, index2 < meta2.length - 1 && " • "))
    );
  }
  function PackModal({ filename, location = PackContentLocation.CATALOG, onClose, ...props }) {
    useEmitterEffect(Events.PluginDisabled, onClose);
    const registry = usePackRegistry();
    const pack = usePack({ filename, location, onClose });
    const { pack: loadedPack, loading, error: error2 } = useLoadedPack(pack, location === PackContentLocation.CATALOG);
    const modules2 = Core.getAllModules(true).filter((module22) => !loadedPack || loadedPack.partial || loadedPack.animations?.some((a) => module22.isSupportedBy(a)));
    const [moduleId, setModuleId] = require$$0$1.useState(data.preferences.module ?? modules2[0]?.id);
    const moduleIndex = modules2.findIndex((m) => m.id === moduleId);
    const module2 = modules2[moduleIndex];
    const selectModule = require$$0$1.useCallback((moduleId2) => {
      setModuleId(moduleId2);
      data.preferences.module = moduleId2;
    }, [setModuleId]);
    const step = (step2) => {
      const module22 = modules2.at((moduleIndex + step2) % modules2.length);
      if (module22) selectModule(module22.id);
    };
    const options = modules2.map((module22) => ({ module: module22, value: module22.id, label: module22.name }));
    require$$0$1.useEffect(() => {
      if (!modules2.some((m) => m.id === moduleId)) setModuleId(modules2[0]?.id);
    });
    useEventListener("keydown", (e) => {
      if (e.repeat) return;
      switch (e.code) {
        case "ArrowUp":
          return step(-1);
        case "ArrowDown":
          return step(1);
      }
    });
    const errorCard = (() => {
      if (pack?.partial) return { text: "Pack did not load properly. Preview is unavailable." };
      if (error2 || !loadedPack) return { text: "Failed to load the preview." };
      if (!registry.verifier.check(pack)) return { iconType: IconBrandTypes.WARNING, text: "Preview is not available for unverified packs." };
      if (!modules2.length) return { iconType: IconBrandTypes.WARNING, text: "This pack does not support any animation modules." };
      if (!module2) return { iconType: IconBrandTypes.WARNING, text: "Module not found." };
      return null;
    })();
    return /* @__PURE__ */ BdApi.React.createElement(
      ModalRoot,
      {
        ...props,
        className: "BA__packModal",
        size: ModalSize.DYNAMIC,
        onClose
      },
      /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, null, pack && /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packModalSidebar" }, /* @__PURE__ */ BdApi.React.createElement(
        PackContent,
        {
          className: "BA__packModalContent",
          pack,
          location,
          size: "md"
        }
      )), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packModalPreview" }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packModalPreviewHeader" }, /* @__PURE__ */ BdApi.React.createElement(
        SingleSelect,
        {
          className: "BA__packModalPreviewSelect",
          options,
          value: moduleId,
          onChange: selectModule,
          isDisabled: loading || errorCard,
          renderOptionLabel: ({ module: module22 }) => /* @__PURE__ */ BdApi.React.createElement(ModuleLabel, { module: module22 }),
          renderOptionValue: ([option]) => option && /* @__PURE__ */ BdApi.React.createElement(ModuleLabel, { module: option.module })
        }
      ), /* @__PURE__ */ BdApi.React.createElement(
        Button$1,
        {
          variant: "icon-only",
          icon: XIcon,
          onClick: onClose
        }
      )), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packModalPreviewContent" }, loading ? /* @__PURE__ */ BdApi.React.createElement(Spinner, { className: "BA__packModalPreviewSpinner" }) : errorCard ? /* @__PURE__ */ BdApi.React.createElement(
        ErrorCard,
        {
          className: "BA__packModalPreviewError",
          ...errorCard
        }
      ) : /* @__PURE__ */ BdApi.React.createElement(
        PackPreview,
        {
          key: moduleId,
          module: module2,
          pack: loadedPack
        }
      )), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packModalPreviewFooter" }, /* @__PURE__ */ BdApi.React.createElement(PackMeta, { pack })))))
    );
  }
  css`.BA__packModal {
    display: flex;
    align-items: stretch;
    flex-direction: row;
    height: 600px;
    overflow: clip;
    max-width: 100%;
}
.BA__packModalSidebar {
    width: 350px;
    display: flex;
    flex-direction: column;
    background-color: var(--background-base-lowest);
}
.BA__packModalContent {
    flex: 1;
}

.BA__packModalPreview {
    width: 560px;
    flex-grow: 1;
    border-left: 1px solid var(--border-subtle);
    display: flex;
    flex-direction: column;
    padding: 16px;
}
.BA__packModalPreviewHeader {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    margin-bottom: 8px;
}
.BA__packModalPreviewSelect {
    min-width: 260px;
}
.BA__packModalPreviewContent {
    flex: 1;
}
.BA__packModalPreviewFooter {
    text-align: center;
}
.BA__packModalPreviewError,
.BA__packModalPreviewSpinner {
    aspect-ratio: 16 / 9;
}
.BA__packModalMeta > * {
    margin: 0 !important;
}

.BA__packPreviewContent {
    display: flex;
    align-items: center;
    gap: 8px;
}
.BA__packPreviewAnimation {
    flex: 1;
    border-radius: 8px;
    box-shadow: 0 0 0 1px var(--border-subtle);
}
.BA__packPreviewFooter {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
    text-align: center;
}
.BA__packPreviewTitle {
    flex: 1;
}

.BA__moduleLabel {
    display: flex;
    align-items: center;
    gap: 2px;
}``PackModal`;
  function getMainConfig(configs) {
    return configs.find((config2) => !config2.slug);
  }
  const slug = "olDays";
  const modules = [
    ["guild", "servers"],
    ["channel", "channels"],
    ["settings", "settings"],
    ["messages", "messages"],
    ["popouts", "popouts"],
    ["popouts", "tooltips"],
    ["popouts", "contextMenu"]
  ];
  const switchTypes = {
    slipUp: {
      key: "containerSlip",
      direction: "upwards"
    },
    slipDown: {
      key: "containerSlip",
      direction: "downwards"
    },
    slipLeft: {
      key: "containerSlip",
      direction: "leftwards"
    },
    slipRight: {
      key: "containerSlip",
      direction: "rightwards"
    },
    slideUp: {
      key: "containerSlide",
      direction: "upwards"
    },
    slideDown: {
      key: "containerSlide",
      direction: "downwards"
    },
    slideLeft: {
      key: "containerSlide",
      direction: "leftwards"
    },
    slideRight: {
      key: "containerSlide",
      direction: "rightwards"
    },
    flipForwards: {
      key: "containerFlip",
      direction: "forwards"
    },
    flipBackwards: {
      key: "containerFlip",
      direction: "backwards"
    },
    flipLeft: {
      key: "containerFlip",
      direction: "leftwards"
    },
    flipRight: {
      key: "containerFlip",
      direction: "rightwards"
    },
    scaleUp: {
      key: "containerScale",
      direction: "upwards"
    },
    scaleDown: {
      key: "containerScale",
      direction: "downwards"
    },
    scaleLeft: {
      key: "containerScale",
      direction: "leftwards"
    },
    scaleRight: {
      key: "containerScale",
      direction: "rightwards"
    },
    fade: {
      key: "containerFade"
    },
    scaleForwards: {
      key: "containerScale",
      direction: "forwards"
    },
    scaleBackwards: {
      key: "containerScale",
      direction: "backwards"
    },
    scaleChange: {
      key: "containerScaleChange"
    }
  };
  const revealTypes = {
    fade: {
      key: "revealFade"
    },
    slip: {
      key: "revealSlip",
      position: "auto"
    },
    slipScale: {
      key: "revealSlipScale",
      position: "auto"
    },
    flip: {
      key: "revealFlip",
      position: "auto"
    },
    scaleForwards: {
      key: "revealScale",
      position: "center",
      direction: "forwards"
    },
    scaleBackwards: {
      key: "revealScale",
      position: "center",
      direction: "backwards"
    },
    scaleForwardsSide: {
      key: "revealScale",
      position: "auto",
      direction: "forwards"
    },
    scaleBackwardsSide: {
      key: "revealScale",
      position: "auto",
      direction: "backwards"
    },
    rotateForwardsLeft: {
      key: "revealRotate",
      direction: "forwards",
      variant: "left"
    },
    rotateForwardsRight: {
      key: "revealRotate",
      direction: "forwards",
      variant: "right"
    },
    rotateBackwardsLeft: {
      key: "revealRotate",
      direction: "backwards",
      variant: "left"
    },
    rotateBackwardsRight: {
      key: "revealRotate",
      direction: "backwards",
      variant: "right"
    }
  };
  function parseEasing(easing) {
    switch (easing) {
      case "linear":
        return {
          type: "linear"
        };
      case "easeIn":
        return {
          type: "ease",
          bezier: "in",
          style: "sine"
        };
      case "easeOut":
        return {
          type: "ease",
          bezier: "out",
          style: "sine"
        };
      case "ease":
      case "easeInOut":
        return {
          type: "ease",
          bezier: "inOut",
          style: "sine"
        };
      default:
        const [, bezier, style2] = easing.match(/^ease(In|Out|InOut)(Sine|Quad|Cubic|Quart|Quint|Expo|Circ|Back)$/).map((i) => i.slice(0, 1).toLowerCase() + i.slice(1));
        switch (style2) {
          case "back":
            return {
              type: "back",
              bezier,
              overshoot: 2.7
            };
          default:
            return {
              type: "ease",
              bezier,
              style: style2
            };
        }
    }
  }
  function parsePosition(position2) {
    switch (position2) {
      case "bottom":
        return "top";
      case "top":
        return "bottom";
      case "right":
        return "left";
      case "left":
        return "right";
    }
  }
  function generateMutations(config2) {
    const data2 = structuredClone(configDefaults);
    const packData = structuredClone(packConfigDefaults);
    for (const [key2, moduleKey] of modules) {
      if (!config2[key2]) continue;
      const moduleData = data2.modules[moduleKey];
      const { enabled, type, duration, easing, position: position2 } = config2[key2];
      const { key: animationKey, ...settings } = ["messages", "popouts"].includes(key2) ? revealTypes[type] : switchTypes[type];
      moduleData.enabled = enabled;
      const pointer = {
        packSlug: slug,
        animationKey
      };
      moduleData.enter = pointer;
      moduleData.exit = pointer;
      settings.duration = duration;
      settings.easing = parseEasing(easing);
      if (position2) settings.position = parsePosition(position2);
      packData.entries.push({
        animation: animationKey,
        module: moduleKey,
        enter: settings,
        exit: settings
      });
    }
    return [
      {
        version: 2,
        data: data2
      },
      {
        slug,
        version: 2,
        data: packData
      }
    ];
  }
  function promptDownload() {
    return new Promise((resolve) => {
      const showPackModal = () => ModalActions.openModal((props) => /* @__PURE__ */ BdApi.React.createElement(
        PackModal,
        {
          ...props,
          filename: slug + PackManager.extension,
          location: PackContentLocation.CATALOG
        }
      ), { onCloseCallback: () => PackRegistry.storage.clear() });
      ModalActions.openModal((props) => /* @__PURE__ */ BdApi.React.createElement(
        Modal$2,
        {
          ...props,
          title: Messages.SETTINGS_MIGRATOR,
          confirmText: "Install",
          confirmButtonVariant: "primary",
          cancelText: "Cancel",
          onConfirm: () => resolve(true)
        },
        /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-md/normal" }, /* @__PURE__ */ BdApi.React.createElement("p", null, "Animations from V1 are considered legacy and no longer come preinstalled with BetterAnimations."), /* @__PURE__ */ BdApi.React.createElement("p", null, "In order to successfully migrate your settings from V1 to V2 pack ", /* @__PURE__ */ BdApi.React.createElement(TextButton, { text: "Ol' Days", onClick: showPackModal }), " will be installed. Proceed?"))
      ), { onCloseCallback: () => resolve(false) });
    });
  }
  async function downloadPack(signal) {
    if (PackManager.getPack(slug)) return true;
    if (!await promptDownload()) return false;
    const installed = await PackRegistry.install(slug + PackManager.extension, { signal });
    if (!installed) throw new Error(`Failed to install pack "${slug}"`);
    return true;
  }
  async function handler(configs, signal) {
    const config2 = getMainConfig(configs);
    if (!config2) return [];
    if (!await downloadPack(signal)) return false;
    return generateMutations(config2.data);
  }
  const migrations = {
    2: {
      handler,
      prompt: true
    }
  };
  function InlineList({
    items: items2,
    limit = 3,
    dividers = [", ", " and "],
    tag: Tag = require$$0$1.Fragment,
    itemTag: ItemTag = "b"
  }) {
    const nodes = items2.length <= limit ? items2 : items2.slice(0, limit - 1).concat(items2.length - limit + 1);
    if (!nodes.length) return null;
    return /* @__PURE__ */ BdApi.React.createElement(Tag, null, nodes.map((node, index2) => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, typeof node === "number" ? `${node} others` : /* @__PURE__ */ BdApi.React.createElement(ItemTag, null, node), [...dividers, ""][Math.max(0, index2 - nodes.length + dividers.length + 1)])));
  }
  class BaseConfig {
    get name() {
      return "BaseConfig";
    }
    constructor(data2, defaults2) {
      this.data = data2;
      this.defaults = defaults2;
      this.stored = {};
      this.current = {};
    }
    get configVersion() {
      const configVersion = this.data.configVersion;
      if (configVersion != null) return configVersion;
      if (this.data.settings != null) return 1;
      return CONFIG_VERSION;
    }
    get isOutdated() {
      return this.configVersion < CONFIG_VERSION;
    }
    read() {
      if (this.isOutdated) {
        Logger.warn(this.name, `Config version is outdated, falling back to defaults.`);
        this.stored = structuredClone(this.defaults);
        return;
      }
      this.stored = deepmerge(this.defaults, this.data.settings ?? {});
    }
    load() {
      this.current = structuredClone(this.stored);
    }
    save() {
      this.data.configVersion = CONFIG_VERSION;
      this.data.settings = this.current;
      this.stored = structuredClone(this.current);
    }
    hasUnsavedChanges() {
      return !isEqual(this.current, this.stored);
    }
    reset() {
      this.current = structuredClone(this.defaults);
      this.save();
    }
  }
  class PackConfig extends BaseConfig {
    get name() {
      return `PackConfig: ${this.slug}`;
    }
    constructor(slug2) {
      super(PackData$1.pack(slug2), packConfigDefaults);
      this.slug = slug2;
      this.read();
      this.load();
    }
    createAnimationConfigEntry(key2, moduleKey) {
      return {
        animation: key2,
        module: moduleKey
      };
    }
    getAnimationConfigEntry(key2, moduleKey, createIfMissing = false) {
      const entry = this.current.entries.find(({ animation, module: module2 }) => animation === key2 && module2 === moduleKey);
      if (entry || !createIfMissing) return entry;
      const newEntry = this.createAnimationConfigEntry(key2, moduleKey);
      this.current.entries.push(newEntry);
      return newEntry;
    }
    getAnimationConfig(key2, moduleKey, type) {
      return this.getAnimationConfigEntry(key2, moduleKey)?.[type] ?? {};
    }
    setAnimationConfig(key2, moduleKey, type, value) {
      this.getAnimationConfigEntry(key2, moduleKey, true)[type] = value;
      Emitter.emit(Events.ModuleSettingsChanged, moduleKey);
    }
  }
  const Config = new class Config extends BaseConfig {
    get name() {
      return "Config";
    }
    constructor() {
      super(data, configDefaults);
      this.migrator = new Migrator(this, migrations);
      this.packs = /* @__PURE__ */ new Map();
      this.onPackLoaded = (pack) => {
        if (pack.partial) return;
        const config2 = new PackConfig(pack.slug);
        this.packs.set(pack.slug, config2);
        this.migrator.validate([config2]);
      };
      this.onPackUnloaded = (pack) => this.packs.delete(pack.slug);
    }
    initialize() {
      super.read();
      super.load();
      internalPackSlugs.forEach((slug2) => this.packs.set(slug2, new PackConfig(slug2)));
      Emitter.on(Events.PackLoaded, this.onPackLoaded);
      Emitter.on(Events.PackUnloaded, this.onPackUnloaded);
      this.migrator.validate();
      Logger.info(this.name, "Initialized.");
    }
    load() {
      super.load();
      this.packs.forEach((pack) => pack.load());
      Emitter.emit(Events.SettingsLoaded);
      Emitter.emit(Events.SettingsChanged);
    }
    save() {
      super.save();
      this.packs.forEach((pack) => pack.save());
      Emitter.emit(Events.SettingsSaved);
    }
    hasUnsavedChanges() {
      return super.hasUnsavedChanges() || Array.from(this.packs.values()).some((pack) => pack.hasUnsavedChanges());
    }
    pack(slug2) {
      return this.packs.get(slug2) ?? new PackConfig(slug2);
    }
    getAll() {
      return [this, ...this.packs.values()];
    }
    buildMigrationPromptMessage(configs) {
      const { internals = [], packs = [] } = Object.groupBy(
        configs,
        (config2) => !config2.slug || internalPackSlugs.includes(config2.slug) ? "internals" : "packs"
      );
      const packNames = packs.map((pack) => PackManager.getPack(pack.slug, true)?.name ?? pack.slug);
      const parts = [];
      if (packNames.length) parts.push(
        /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, packNames.length > 1 ? "packs " : "pack ", /* @__PURE__ */ BdApi.React.createElement(
          InlineList,
          {
            items: packNames,
            limit: Infinity
          }
        ))
      );
      if (internals.length && parts.length) parts.unshift("the plugin");
      return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("p", null, "The version of your saved ", parts.length > 1 ? "configurations " : "configuration ", parts.length > 0 && /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "for ", /* @__PURE__ */ BdApi.React.createElement(
        InlineList,
        {
          items: parts,
          limit: Infinity,
          itemTag: require$$0$1.Fragment
        }
      )), parts.length > 1 ? " are " : " is ", "outdated and cannot be used with the current version of the plugin."), /* @__PURE__ */ BdApi.React.createElement("p", null, "Would you like to migrate your settings to the latest version?"));
    }
    applyMutations(mutations) {
      for (const mutation of mutations) {
        const config2 = mutation.slug ? this.pack(mutation.slug) : this;
        config2.current = mutation.data;
        config2.save();
      }
      Emitter.emit(Events.SettingsChanged);
    }
    shutdown() {
      this.migrator.abort();
      Emitter.off(Events.PackLoaded, this.onPackLoaded);
      Emitter.off(Events.PackUnloaded, this.onPackUnloaded);
      this.packs.clear();
      Logger.info(this.name, "Shutdown.");
    }
  }();
  const SectionContext = require$$0$1.createContext({ section: null, setSection: null });
  function DismissibleAlert({ children: children2, onDismiss, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(Alert, { ...props }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__dismissibleAlert" }, /* @__PURE__ */ BdApi.React.createElement("div", null, children2), /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        className: "BA__dismissibleAlertDismiss",
        onClick: onDismiss
      },
      /* @__PURE__ */ BdApi.React.createElement(XIcon, { size: "xs", color: "currentColor" })
    )));
  }
  css`.BA__dismissibleAlert {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 8px;
}
.BA__dismissibleAlertDismiss {
    flex-shrink: 0;
}``DismissibleAlert`;
  function ModuleSettingsHeader({ module: module2, enabled, setEnabled, selected, onSelect, ...props }) {
    const { setSection: setSection2 } = require$$0$1.use(SectionContext);
    const parentModules = require$$0$1.useMemo(() => Core.getParentModules(module2), [module2]);
    const childModules = require$$0$1.useMemo(() => Core.getChildModules(module2), [module2]);
    const breadcrumbs = parentModules.concat(module2).map((m) => ({
      id: m.id,
      label: m.name
    }));
    const toggleSwitch = /* @__PURE__ */ BdApi.React.createElement(Switch$1, { checked: enabled, onChange: setEnabled });
    const handleSetSettings = (pack, animation, type) => (value) => Config.pack(pack.slug).setAnimationConfig(animation.key, module2.id, type, value);
    const defaultSettings = (animation, type) => module2.buildDefaultSettings(animation, type);
    const handleResetSettings = (pack, animation, type) => {
      const setSettings = handleSetSettings(pack, animation, type);
      return () => setSettings(defaultSettings(animation, type));
    };
    const setEnterEnabled = selected.enter.animation ? (value) => !value && onSelect(AnimationType.Enter, null, null) : null;
    const setExitEnabled = selected.exit.animation ? (value) => !value && onSelect(AnimationType.Exit, null, null) : null;
    const animationSettings = useAnimationSettings(module2, [
      {
        animation: selected.enter.animation,
        type: AnimationType.Enter,
        title: selected.enter.animation?.name,
        subtitle: true,
        settings: selected.enter.animation && module2.getAnimationSettings(selected.enter.pack, selected.enter.animation, AnimationType.Enter),
        setSettings: selected.enter.animation && handleSetSettings(selected.enter.pack, selected.enter.animation, AnimationType.Enter),
        enabled: !!selected.enter.animation,
        setEnabled: setEnterEnabled,
        context: selected.enter.context,
        switchTooltip: !selected.enter.animation ? Messages.SELECT_ANIMATION_TO_ENABLE : null,
        defaults: () => defaultSettings(selected.enter.animation, AnimationType.Enter),
        onReset: selected.enter.animation && handleResetSettings(selected.enter.pack, selected.enter.animation, AnimationType.Enter)
      },
      {
        animation: selected.exit.animation,
        type: AnimationType.Exit,
        title: selected.exit.animation?.name,
        subtitle: true,
        settings: selected.exit.animation && module2.getAnimationSettings(selected.exit.pack, selected.exit.animation, AnimationType.Exit),
        setSettings: selected.exit.animation && handleSetSettings(selected.exit.pack, selected.exit.animation, AnimationType.Exit),
        enabled: !!selected.exit.animation,
        setEnabled: setExitEnabled,
        context: selected.exit.context,
        switchTooltip: !selected.exit.animation ? Messages.SELECT_ANIMATION_TO_ENABLE : null,
        defaults: () => defaultSettings(selected.exit.animation, AnimationType.Exit),
        onReset: selected.exit.animation && handleResetSettings(selected.exit.pack, selected.exit.animation, AnimationType.Exit)
      }
    ]);
    const accordionHint = /* @__PURE__ */ BdApi.React.createElement(
      Hint,
      {
        className: "BA__accordionHint",
        href: Documentation.accordionUrl
      }
    );
    const accordions = module2.getAccordions();
    const accordionsSettings = useAnimationSettings(module2, accordions ? [
      {
        animation: accordions.animation,
        type: AnimationType.Enter,
        title: "Smooth Expand",
        headerAfter: accordionHint,
        switchTooltip: accordions.enter.forceDisabled ? Messages.IMPLEMENTED_BY_ANIMATION(selected.enter.animation?.name) : null,
        ...accordions.enter
      },
      {
        animation: accordions.animation,
        type: AnimationType.Exit,
        title: "Smooth Collapse",
        headerAfter: accordionHint,
        switchTooltip: accordions.exit.forceDisabled ? Messages.IMPLEMENTED_BY_ANIMATION(selected.exit.animation?.name) : null,
        ...accordions.exit
      }
    ] : [], { hideOverflow: true });
    const errors = [
      selected.enter.error,
      selected.exit.error
    ].filter(Boolean);
    const [alertDismissed, setAlertDismissed] = useDismissible(`moduleAlert:${module2.id}`);
    return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, module2.alert && !alertDismissed && /* @__PURE__ */ BdApi.React.createElement(
      DismissibleAlert,
      {
        messageType: AlertTypes.WARNING,
        className: DiscordClasses.Margins.marginBottom8,
        onDismiss: () => setAlertDismissed(true)
      },
      module2.alert
    ), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__moduleSettingsHeader" }, /* @__PURE__ */ BdApi.React.createElement(
      AnimationCard,
      {
        ...props,
        enter: !!selected.enter.animation,
        exit: !!selected.exit.animation,
        setEnter: setEnterEnabled,
        setExit: setExitEnabled,
        animationSettings,
        accordionsSettings,
        active: false,
        header: true,
        errors
      }
    ), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__moduleSettingsHeading" }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__moduleSettingsTitle" }, /* @__PURE__ */ BdApi.React.createElement(
      Breadcrumbs,
      {
        breadcrumbs,
        activeId: module2.id,
        renderCustomBreadcrumb: ({ label }, active) => /* @__PURE__ */ BdApi.React.createElement(
          FormTitle,
          {
            tag: "h1",
            className: `BA__moduleSettingsBreadcrumb ${active ? "BA__moduleSettingsBreadcrumb--active" : ""}`
          },
          label
        ),
        onBreadcrumbClick: ({ id }) => setSection2(id)
      }
    ), /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: `${enabled ? "Disable" : "Enable"} ${module2.name} animations`, hideOnClick: false }, (props2) => /* @__PURE__ */ BdApi.React.createElement("div", { ...props2 }, toggleSwitch))), module2.description && /* @__PURE__ */ BdApi.React.createElement(FormText, { type: FormText.Types.DESCRIPTION, className: DiscordClasses.Margins.marginTop8 }, typeof module2.description === "function" ? module2.description(setSection2) : module2.description), module2.controls && /* @__PURE__ */ BdApi.React.createElement("div", { className: DiscordClasses.Margins.marginTop8 }, module2.controls({ module: module2 })), childModules.map((m) => /* @__PURE__ */ BdApi.React.createElement(Clickable, { tag: "div", onClick: () => setSection2(m.id) }, /* @__PURE__ */ BdApi.React.createElement(
      FormTitle,
      {
        key: m.id,
        tag: "label",
        className: "BA__moduleSettingsLink"
      },
      m.name,
      " animations",
      /* @__PURE__ */ BdApi.React.createElement(ArrowSmallRightIcon, { size: "xs" })
    ))))));
  }
  css`.BA__moduleSettingsHeader {
    margin-bottom: 32px;
    display: flex;
    gap: 20px;
}
    
.BA__moduleSettingsHeader .BA__animationCardWrapper {
    flex-shrink: 0;
}

.BA__moduleSettingsHeading {
    padding: 12px 0;
    flex-grow: 1;
}
    
.BA__moduleSettingsTitle {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.BA__moduleSettingsBreadcrumb {
    margin-bottom: 0;
    color: var(--header-muted);
}
.BA__moduleSettingsBreadcrumb:not(.BA__moduleSettingsBreadcrumb--active) {
    cursor: pointer;
}
.BA__moduleSettingsBreadcrumb:hover,
.BA__moduleSettingsBreadcrumb.BA__moduleSettingsBreadcrumb--active {
    color: var(--header-primary);
}

.BA__moduleSettingsLink {
    display: flex;
    align-items: center;
    gap: 2px;
    color: var(--header-secondary);
    margin-top: 16px;
    cursor: pointer;
}
.BA__moduleSettingsLink:hover {
    text-decoration: underline;
}
.BA__moduleSettingsLink svg {
    transition: transform .2s;
}
.BA__moduleSettingsLink:hover svg {
    transform: translateX(4px);
}

.BA__accordionHint {
    margin: auto 0;
}``ModuleSettingsHeader`;
  function AnimationItem({ module: module2, pack, animation, selected, onSelect, ...props }) {
    const packConfig = require$$0$1.useMemo(() => Config.pack(pack.slug), [pack]);
    const isActive = (type) => selected[type].packSlug === pack.slug && selected[type].animationKey === animation.key;
    const handleSelect = (type) => (value) => onSelect(type, value && animation && pack, value && animation);
    const handleSelectAll = () => {
      const value = !AnimationType.values().every((type) => isActive(type));
      AnimationType.values().forEach((type) => handleSelect(type)(value));
    };
    const handleSetSettings = (type) => (value) => packConfig.setAnimationConfig(animation.key, module2.id, type, value);
    const defaultSettings = (type) => module2.buildDefaultSettings(animation, type);
    const handleResetSettings = (type) => {
      const setSettings = handleSetSettings(type);
      return () => setSettings(defaultSettings(type));
    };
    const animationSettings = useAnimationSettings(
      module2,
      AnimationType.values().map((type) => ({
        animation,
        type,
        settings: module2.getAnimationSettings(pack, animation, type),
        setSettings: handleSetSettings(type),
        enabled: isActive(type),
        setEnabled: handleSelect(type),
        context: isActive(type) ? selected[type].context : null,
        defaults: () => defaultSettings(type),
        onReset: handleResetSettings(type)
      }))
    );
    const errors = AnimationType.values().map((type) => isActive(type) && selected[type].error).filter(Boolean);
    return /* @__PURE__ */ BdApi.React.createElement(
      AnimationCard,
      {
        ...props,
        key: animation.key,
        pack,
        animation,
        enter: isActive(AnimationType.Enter),
        exit: isActive(AnimationType.Exit),
        setEnter: handleSelect(AnimationType.Enter),
        setExit: handleSelect(AnimationType.Exit),
        onClick: handleSelectAll,
        animationSettings,
        errors
      }
    );
  }
  function AnimationList({ animations: animations2, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__animationList" }, animations2.map((animation) => /* @__PURE__ */ BdApi.React.createElement(
      AnimationItem,
      {
        key: animation.key,
        animation,
        ...props
      }
    )));
  }
  css`.BA__animationList {
    display: grid;
    gap: 8px;
    grid-template-columns: repeat(3, 1fr);
}``AnimationList`;
  function PackPicture(props) {
    return /* @__PURE__ */ BdApi.React.createElement("svg", { ...props, width: "160", height: "192", viewBox: "0 0 160 192", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ BdApi.React.createElement("g", { "clip-path": "url(#clip0_364_497)" }, /* @__PURE__ */ BdApi.React.createElement("path", { d: "M0.12699 43.8989C-0.863275 37.1255 4.04575 30.863 11.0915 29.911L113.152 16.1221C120.197 15.1702 126.712 19.8893 127.702 26.6627L147.873 164.635C148.863 171.409 143.954 177.671 136.908 178.623L39.1006 191.837C29.7063 193.107 21.0203 186.814 19.7001 177.784L0.12699 43.8989Z", fill: "url(#paint0_linear_364_497)" }), /* @__PURE__ */ BdApi.React.createElement("path", { d: "M10.1376 30.5728C9.06483 22.8787 14.3827 15.7647 22.0152 14.6834L124.678 0.138664C132.31 -0.942678 139.367 4.41806 140.44 12.1122L159.862 151.427C160.935 159.121 155.617 166.235 147.985 167.317L45.3224 181.861C37.6899 182.943 30.6329 177.582 29.5602 169.888L10.1376 30.5728Z", fill: "url(#paint1_linear_364_497)" }), /* @__PURE__ */ BdApi.React.createElement("path", { d: "M19.0979 33.7417C18.3346 28.2753 22.1183 23.221 27.5489 22.4527L121.946 9.09852C127.376 8.33025 132.397 12.1389 133.161 17.6054L151.402 148.258C152.165 153.725 148.382 158.779 142.951 159.547L48.5544 172.901C43.1238 173.67 38.1027 169.861 37.3394 164.395L19.0979 33.7417Z", fill: "white" }), /* @__PURE__ */ BdApi.React.createElement("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M91.6298 136.767C104.339 149.771 112.123 129.724 110.522 118.561C108.63 105.362 94.2015 99.8837 86.5377 100.972C74.237 102.719 63.9659 114.548 65.9411 128.458C68.1366 143.918 82.7808 150.575 93.3682 149.072C90.9234 149.067 82.6965 148.49 79.9777 130.116C78.1393 117.689 81.5632 112.133 88.286 113.408C88.4372 113.441 95.755 115.191 97.0231 124.121C98.2858 133.013 91.6298 136.767 91.6298 136.767Z", fill: "url(#paint2_linear_364_497)" }), /* @__PURE__ */ BdApi.React.createElement("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M88.2981 113.397C80.9178 111.971 73.1222 118.994 74.7716 130.609C77.4648 149.574 91.7633 149.3 93.4668 149.058C105.768 147.311 116.039 135.481 114.063 121.572C111.868 106.111 97.2237 99.4545 86.6364 100.958C89.5111 100.135 102.892 101.887 105.39 119.481C107.02 130.954 98.2947 138.565 91.6643 136.784C91.5131 136.751 84.1953 135.001 82.9272 126.071C81.6645 117.179 88.2981 113.397 88.2981 113.397Z", fill: "url(#paint3_linear_364_497)" }), /* @__PURE__ */ BdApi.React.createElement("path", { d: "M47.8507 42.0276C47.8349 41.9761 47.8165 41.9254 47.7955 41.8757C47.775 41.8263 47.752 41.778 47.7266 41.731C47.7016 41.6837 47.6741 41.6378 47.644 41.5935C47.6135 41.5495 47.5812 41.5068 47.5471 41.4665C47.5126 41.4252 47.4757 41.3858 47.4368 41.3487C47.399 41.312 47.3583 41.2768 47.3168 41.2438C47.2747 41.2126 47.231 41.1838 47.1858 41.1573C47.1407 41.129 47.0938 41.1021 47.0463 41.0783C46.9982 41.0547 46.9489 41.0336 46.8986 41.0152C46.5918 40.9079 46.262 40.8844 45.943 40.9471C45.4691 41.1322 45.0954 41.3724 44.8774 41.8574C44.8551 41.9067 44.8356 41.9571 44.819 42.0086C44.8031 42.0592 44.7885 42.1117 44.7771 42.1649C44.7655 42.2175 44.7565 42.2707 44.7504 42.3242C44.7443 42.3776 44.7413 42.4306 44.7396 42.4855C44.738 42.5404 44.7409 42.5904 44.7459 42.6475C44.7503 42.7011 44.7579 42.7544 44.7685 42.8072C44.7762 42.8608 44.7904 42.9092 44.8057 42.9648C44.8209 43.0204 44.8388 43.0652 44.8598 43.1169C44.9176 43.2604 44.9965 43.3944 45.094 43.5145C45.1259 43.5541 45.1607 43.5922 45.1964 43.6292C45.2322 43.6662 45.2707 43.7006 45.31 43.7329C45.3494 43.7662 45.3906 43.7971 45.4335 43.8257C45.4754 43.8544 45.5201 43.8806 45.5647 43.9058C45.6093 43.931 45.6564 43.9517 45.7045 43.9722C46.0531 44.1181 46.3754 44.1154 46.7427 44.0601C47.2113 43.8663 47.5776 43.6261 47.7889 43.1389C47.8103 43.0892 47.829 43.0385 47.8451 42.9869C47.8621 42.9358 47.8758 42.8837 47.886 42.8308C47.9183 42.6723 47.9271 42.51 47.9121 42.3489C47.9045 42.2954 47.8975 42.2459 47.8894 42.1892C47.8814 42.1326 47.8664 42.079 47.8507 42.0276Z", fill: "url(#paint4_linear_364_497)" }), /* @__PURE__ */ BdApi.React.createElement("path", { d: "M60.4791 52.2765C60.5 52.3274 60.5239 52.377 60.5507 52.425C60.576 52.4723 60.6039 52.5182 60.6343 52.5624C60.6638 52.6066 60.6958 52.649 60.7301 52.6896C60.7647 52.7305 60.8015 52.7694 60.8403 52.8064C60.8783 52.8435 60.9184 52.8785 60.9603 52.9112C61.0025 52.9445 61.0466 52.9754 61.0922 53.0039C61.1372 53.0322 61.184 53.0581 61.2315 53.0818C61.2792 53.1057 61.3281 53.1268 61.3782 53.1451C61.4281 53.164 61.4792 53.18 61.531 53.1927C61.8483 53.2683 62.1804 53.2539 62.4899 53.151C62.9429 52.929 63.2885 52.6466 63.4547 52.1521C63.4714 52.1012 63.4854 52.0493 63.4967 51.9969C63.5081 51.9438 63.5171 51.8889 63.5235 51.8376C63.5298 51.784 63.5334 51.7302 63.5342 51.6763C63.535 51.6226 63.5329 51.5714 63.5281 51.5153C63.5233 51.4592 63.5135 51.4123 63.5054 51.3556C63.4974 51.299 63.4826 51.2538 63.4674 51.1992C63.4523 51.1446 63.4343 51.0988 63.4133 51.0471C63.3936 50.9971 63.3709 50.9484 63.3452 50.9012C63.3207 50.8543 63.2932 50.8088 63.2637 50.7636C63.2341 50.7184 63.2019 50.6767 63.1678 50.6364C63.1337 50.596 63.0975 50.556 63.0596 50.5183C63.0217 50.4806 62.9831 50.4461 62.9394 50.4124C62.8985 50.3787 62.8555 50.3476 62.8106 50.3193C62.7663 50.2899 62.7204 50.2631 62.6731 50.239C62.6254 50.2142 62.5772 50.1927 62.527 50.1725C62.4776 50.153 62.4272 50.1363 62.3759 50.1225C62.0311 50.0254 61.7375 50.0671 61.3936 50.1402C60.942 50.3641 60.595 50.6436 60.429 51.1401C60.4127 51.1929 60.3983 51.2464 60.3857 51.3008C60.3742 51.3548 60.3654 51.4093 60.3595 51.4642C60.3529 51.5191 60.3495 51.5743 60.3494 51.6296C60.3489 51.6854 60.3513 51.7397 60.3562 51.7958C60.3608 51.8508 60.3686 51.9055 60.3794 51.9596C60.3872 52.0142 60.4042 52.0675 60.4202 52.1209C60.437 52.1738 60.4566 52.2257 60.4791 52.2765Z", fill: "url(#paint5_linear_364_497)" }), /* @__PURE__ */ BdApi.React.createElement("path", { d: "M58.6152 47.0068C58.6285 46.9597 58.6387 46.9131 58.6477 46.8656C58.6567 46.818 58.6614 46.7701 58.665 46.7212C58.6689 46.6732 58.6701 46.6249 58.6686 46.5767C58.6672 46.5284 58.6631 46.4802 58.6565 46.4323C58.6523 46.3843 58.6455 46.3365 58.6362 46.2891C58.6241 46.2415 58.6112 46.1949 58.5954 46.1499C58.5797 46.1042 58.5614 46.0594 58.5406 46.0158C58.5207 45.9718 58.4981 45.929 58.473 45.8877C58.374 45.7258 58.2418 45.5866 58.0851 45.4795C57.9284 45.3724 57.7507 45.2998 57.5639 45.2665C56.9696 45.1523 53.7461 45.6766 52.9821 45.8398C52.5752 46.0532 52.2879 46.3021 52.1465 46.7563C52.1318 46.8014 52.1205 46.8472 52.1103 46.8938C52.1001 46.9405 52.0933 46.9887 52.0884 47.0357C52.0835 47.0826 52.0808 47.1303 52.0804 47.1787C52.0799 47.2271 52.0823 47.274 52.087 47.3217C52.0917 47.3694 52.1003 47.4155 52.1071 47.4629C52.1161 47.5098 52.1276 47.5562 52.1416 47.602C52.1545 47.648 52.1704 47.6931 52.1891 47.7371C52.2069 47.7812 52.227 47.8243 52.2495 47.8662C52.333 48.0206 52.4466 48.1567 52.5837 48.2663C52.7208 48.3759 52.8785 48.4568 53.0475 48.5042C53.2375 48.5572 53.4351 48.5771 53.6318 48.5631C54.2106 48.5313 54.797 48.3975 55.3708 48.316C56.1712 48.2022 56.9789 48.1169 57.7717 47.9643C58.1838 47.7355 58.4792 47.477 58.6152 47.0068Z", fill: "url(#paint6_linear_364_497)" }), /* @__PURE__ */ BdApi.React.createElement("path", { d: "M104.452 55.4932C105.883 53.1573 106.79 49.8482 106.973 47.1232C107.196 43.8283 106.508 40.383 104.27 37.8487C102.357 35.6822 99.4849 34.4981 96.6252 34.3432C93.987 34.201 91.124 34.7918 88.4959 35.1579L58.7608 39.3191L53.0144 40.1357C52.1903 40.2528 51.3438 40.3237 50.5284 40.4805C50.2035 40.5312 49.8999 40.6739 49.6536 40.8918C49.5264 41.0127 49.4245 41.1578 49.3539 41.3185C49.2832 41.4792 49.2453 41.6523 49.2422 41.8278C49.2417 41.8762 49.2423 41.9245 49.2459 41.9723C49.2501 42.02 49.2568 42.0675 49.2661 42.1145C49.2744 42.1618 49.2853 42.2087 49.2987 42.2549C49.3114 42.3012 49.3266 42.3467 49.3443 42.3913C49.3808 42.4807 49.4254 42.5665 49.4775 42.6478C49.5041 42.6871 49.5317 42.7262 49.5623 42.7639C49.5929 42.8016 49.6252 42.837 49.6584 42.8711C49.8982 43.1132 50.2142 43.265 50.553 43.3011C51.1149 43.3358 53.1592 42.9517 53.8165 42.8583L65.9119 41.1396C66.4384 41.0648 66.9972 40.9296 67.5311 40.9442C67.9321 40.9555 68.2853 41.0745 68.5554 41.3851C68.8108 41.6772 68.9431 42.057 68.9246 42.4446C68.9072 42.676 68.8294 42.8989 68.6991 43.091C68.5687 43.2831 68.3902 43.4376 68.1815 43.5391C67.6328 43.8273 66.8942 43.8513 66.2851 43.9358L62.5608 44.4492C61.9427 44.5371 61.2569 44.5704 60.6629 44.7463C60.4156 44.814 60.1863 44.9356 59.9915 45.1023C59.8598 45.2137 59.7531 45.3517 59.6785 45.5072C59.6039 45.6627 59.563 45.8322 59.5585 46.0046C59.5489 46.3886 59.6756 46.8288 59.9573 47.0957C60.178 47.3167 60.4678 47.4554 60.7783 47.4887C61.4675 47.561 62.3016 47.3437 62.989 47.2408L67.594 46.5864C68.2811 46.4888 69.0334 46.302 69.7235 46.2922C70.1326 46.2866 70.5103 46.378 70.8075 46.6721C70.9503 46.809 71.0626 46.9743 71.1374 47.1575C71.2121 47.3406 71.2475 47.5374 71.2413 47.735C71.2365 47.9687 71.1708 48.197 71.0508 48.3975C70.9307 48.598 70.7603 48.7636 70.5566 48.8781C69.399 49.5334 65.8126 49.2201 64.9229 50.1253C64.7998 50.2588 64.7051 50.4159 64.6445 50.5871C64.584 50.7583 64.5587 50.94 64.5704 51.1213C64.5713 51.3152 64.6127 51.5069 64.6922 51.6839C64.7716 51.8609 64.8873 52.0192 65.0317 52.1487C65.3096 52.3878 65.6694 52.5096 66.0354 52.4885C66.6586 52.4735 67.3324 52.3189 67.9525 52.2308L89.9636 49.103C90.8104 48.9827 91.6754 48.8199 92.5301 48.7699C93.0358 48.8746 93.4749 49.0434 93.7811 49.4897C94.062 49.8985 94.096 50.3519 94.0766 50.8297C94.012 51.2682 93.8591 51.689 93.6272 52.0666C93.3952 52.4442 93.0891 52.7709 92.7272 53.0268C92.4863 53.2013 92.22 53.3377 91.9376 53.4311C91.1221 53.609 90.2717 53.6973 89.4414 53.8153C87.7653 54.0535 86.0811 54.2644 84.4099 54.5303C84.0268 58.1875 83.536 61.8411 83.1965 65.5016L88.2114 64.789C89.0449 64.6706 89.9378 64.468 90.7761 64.4582C91.2511 64.5389 91.6963 64.7205 91.9944 65.1175C92.3213 65.5545 92.3882 66.143 92.2967 66.6678C92.2122 67.0968 92.0433 67.5046 91.7997 67.8677C91.5561 68.2307 91.2427 68.5416 90.8777 68.7823C90.5982 68.9642 90.2879 69.0938 89.962 69.1646C89.4074 69.2928 88.8223 69.3392 88.2583 69.4162L85.6488 69.787C83.1548 70.1414 80.6574 70.5467 78.1573 70.8515C78.1439 70.3132 78.2548 69.7331 78.316 69.1947L78.6867 65.9312L79.8911 55.1766L66.03 57.1399C65.42 62.3513 64.9158 67.5896 64.269 72.8083C63.9473 76.2392 63.5118 79.6685 63.1293 83.0934L62.8127 85.9466C62.7831 86.2336 62.7083 86.5206 62.6908 86.8047C62.6761 86.9189 62.6926 87.035 62.7386 87.1406C62.8264 87.1711 62.922 87.1705 63.0095 87.1389C64.8136 86.9582 66.6278 86.6342 68.4234 86.379L86.4549 83.8167C89.2024 83.4263 91.9513 83.0683 94.6113 82.2468C97.119 81.47 99.5452 80.3202 101.512 78.5546C105.213 75.232 106.367 70.6266 106.612 65.8581C106.784 62.5029 106.357 58.8904 104.02 56.2998L104.016 56.2771C104.174 56.0193 104.316 55.7585 104.452 55.4932Z", fill: "url(#paint7_linear_364_497)" })), /* @__PURE__ */ BdApi.React.createElement("defs", null, /* @__PURE__ */ BdApi.React.createElement("linearGradient", { id: "paint0_linear_364_497", x1: "0.447603", y1: "16.413", x2: "148.448", y2: "191.541", gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ BdApi.React.createElement("stop", { "stop-color": "#508AB7" }), /* @__PURE__ */ BdApi.React.createElement("stop", { offset: "1", "stop-color": "#1F2569" })), /* @__PURE__ */ BdApi.React.createElement("linearGradient", { id: "paint1_linear_364_497", x1: "11.1858", y1: "19.1536", x2: "158.875", y2: "162.67", gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ BdApi.React.createElement("stop", { "stop-color": "#41D1FF" }), /* @__PURE__ */ BdApi.React.createElement("stop", { offset: "1", "stop-color": "#5865F2" })), /* @__PURE__ */ BdApi.React.createElement("linearGradient", { id: "paint2_linear_364_497", x1: "73.3725", y1: "107.902", x2: "107.5", y2: "144.392", gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ BdApi.React.createElement("stop", { "stop-color": "#5865F2" }), /* @__PURE__ */ BdApi.React.createElement("stop", { offset: "1", "stop-color": "#41D1FF" })), /* @__PURE__ */ BdApi.React.createElement("linearGradient", { id: "paint3_linear_364_497", x1: "109.369", y1: "139.553", x2: "70.6513", y2: "110.457", gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ BdApi.React.createElement("stop", { "stop-color": "#5865F2" }), /* @__PURE__ */ BdApi.React.createElement("stop", { offset: "1", "stop-color": "#41D1FF" })), /* @__PURE__ */ BdApi.React.createElement("linearGradient", { id: "paint4_linear_364_497", x1: "44.7007", y1: "44.5189", x2: "111.604", y2: "78.0676", gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ BdApi.React.createElement("stop", { "stop-color": "#41D1FF" }), /* @__PURE__ */ BdApi.React.createElement("stop", { offset: "1", "stop-color": "#5865F2" })), /* @__PURE__ */ BdApi.React.createElement("linearGradient", { id: "paint5_linear_364_497", x1: "44.7007", y1: "44.5189", x2: "111.604", y2: "78.0676", gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ BdApi.React.createElement("stop", { "stop-color": "#41D1FF" }), /* @__PURE__ */ BdApi.React.createElement("stop", { offset: "1", "stop-color": "#5865F2" })), /* @__PURE__ */ BdApi.React.createElement("linearGradient", { id: "paint6_linear_364_497", x1: "44.7007", y1: "44.5189", x2: "111.604", y2: "78.0676", gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ BdApi.React.createElement("stop", { "stop-color": "#41D1FF" }), /* @__PURE__ */ BdApi.React.createElement("stop", { offset: "1", "stop-color": "#5865F2" })), /* @__PURE__ */ BdApi.React.createElement("linearGradient", { id: "paint7_linear_364_497", x1: "44.7007", y1: "44.5189", x2: "111.604", y2: "78.0676", gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ BdApi.React.createElement("stop", { "stop-color": "#41D1FF" }), /* @__PURE__ */ BdApi.React.createElement("stop", { offset: "1", "stop-color": "#5865F2" })), /* @__PURE__ */ BdApi.React.createElement("clipPath", { id: "clip0_364_497" }, /* @__PURE__ */ BdApi.React.createElement("rect", { width: "160", height: "192", fill: "white" }))));
  }
  function ShopIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M2.63 4.19A3 3 0 0 1 5.53 2H7a1 1 0 0 1 1 1v3.98a3.07 3.07 0 0 1-.3 1.35A2.97 2.97 0 0 1 4.98 10c-2 0-3.44-1.9-2.9-3.83l.55-1.98ZM10 2a1 1 0 0 0-1 1v4a3 3 0 0 0 3 3 3 3 0 0 0 3-2.97V3a1 1 0 0 0-1-1h-4ZM17 2a1 1 0 0 0-1 1v3.98a3.65 3.65 0 0 0 0 .05A2.95 2.95 0 0 0 19.02 10c2 0 3.44-1.9 2.9-3.83l-.55-1.98A3 3 0 0 0 18.47 2H17Z"
        }
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M21 11.42V19a3 3 0 0 1-3 3h-2.75a.25.25 0 0 1-.25-.25V16a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2v5.75c0 .14-.11.25-.25.25H6a3 3 0 0 1-3-3v-7.58c0-.18.2-.3.37-.24a4.46 4.46 0 0 0 4.94-1.1c.1-.12.3-.12.4 0a4.49 4.49 0 0 0 6.58 0c.1-.12.3-.12.4 0a4.45 4.45 0 0 0 4.94 1.1c.17-.07.37.06.37.24Z"
        }
      )
    );
  }
  function LibraryIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M5.5 3A1.5 1.5 0 0 1 7 4.5v15A1.5 1.5 0 0 1 5.5 21h-2A1.5 1.5 0 0 1 2 19.5v-15A1.5 1.5 0 0 1 3.5 3zm6 0A1.5 1.5 0 0 1 13 4.5v15a1.5 1.5 0 0 1-1.5 1.5h-2A1.5 1.5 0 0 1 8 19.5v-15A1.5 1.5 0 0 1 9.5 3zm7.281 3.124l3.214 12.519a1.5 1.5 0 0 1-1.08 1.826l-1.876.48a1.5 1.5 0 0 1-1.826-1.08L13.999 7.354a1.5 1.5 0 0 1 1.08-1.826l1.876-.483a1.5 1.5 0 0 1 1.826 1.08"
        }
      )
    );
  }
  function NoPacksPlaceholder({
    title = "Install Animation Packs",
    description = /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Expand your animation library with collections of community-made animations"),
    actions = ["catalog", "library"]
  }) {
    const [section2, setSection2] = useSection();
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__noPacks" }, /* @__PURE__ */ BdApi.React.createElement(PackPicture, { className: "BA__noPacksPicture" }), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__noPacksContent" }, /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__noPacksTitle",
        variant: "heading-xl/bold"
      },
      title
    ), /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__noPacksDescription",
        variant: "text-md/normal"
      },
      description
    ), actions && /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__noPacksActions" }, actions.map((action) => {
      switch (action) {
        case "catalog":
          return /* @__PURE__ */ BdApi.React.createElement(
            Button$1,
            {
              icon: ShopIcon,
              text: "Catalog",
              onClick: () => setSection2(SettingsSection.Catalog)
            }
          );
        case "library":
          return /* @__PURE__ */ BdApi.React.createElement(
            Button$1,
            {
              variant: "secondary",
              icon: LibraryIcon,
              text: "Library",
              onClick: () => setSection2(SettingsSection.Library)
            }
          );
        default:
          return action;
      }
    }))));
  }
  css`.BA__noPacks {
    display: flex;
    align-items: center;
    gap: 24px;
    margin-top: 48px;
    justify-content: center;
}
.BA__noPacksContent {
    padding-bottom: 20px;
}
.BA__noPacksPicture {
    flex-shrink: 0;
}
.BA__noPacksDescription {
    margin-top: 8px;
    max-width: 360px;
}
.BA__noPacksActions {
    margin-top: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
}``NoPacksPlaceholder`;
  function usePagination(allItems, pageSize, dependencies = []) {
    const [page, setPage] = require$$0$1.useState(1);
    const offset = (page - 1) * pageSize;
    const items2 = allItems.slice(offset, offset + pageSize);
    require$$0$1.useEffect(
      () => setPage(1),
      dependencies
    );
    require$$0$1.useEffect(() => {
      if (items2.length === 0 && page > 1) setPage(1);
    }, [items2.length, page]);
    return {
      page,
      setPage,
      offset,
      items: items2
    };
  }
  function ChevronSmallDownIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M5.3 9.3a1 1 0 0 1 1.4 0l5.3 5.29 5.3-5.3a1 1 0 1 1 1.4 1.42l-6 6a1 1 0 0 1-1.4 0l-6-6a1 1 0 0 1 0-1.42Z"
        }
      )
    );
  }
  function ChevronSmallUpIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M5.3 14.7a1 1 0 0 0 1.4 0L12 9.42l5.3 5.3a1 1 0 0 0 1.4-1.42l-6-6a1 1 0 0 0-1.4 0l-6 6a1 1 0 0 0 0 1.42Z"
        }
      )
    );
  }
  function useRafFn(callback, initiallyActive = true) {
    const raf = require$$0$1.useRef(null);
    const rafActivity = require$$0$1.useRef(false);
    const rafCallback = useLatest(callback);
    const step = require$$0$1.useCallback(
      (time) => {
        if (rafActivity.current) {
          rafCallback.current(time);
          raf.current = requestAnimationFrame(step);
        }
      },
      [rafCallback]
    );
    const result = require$$0$1.useMemo(
      () => [
        () => {
          if (rafActivity.current) {
            rafActivity.current = false;
            raf.current && cancelAnimationFrame(raf.current);
          }
        },
        () => {
          if (!rafActivity.current) {
            rafActivity.current = true;
            raf.current = requestAnimationFrame(step);
          }
        },
        () => rafActivity.current
        // isActive
      ],
      [step]
    );
    require$$0$1.useEffect(() => {
      if (initiallyActive) {
        result[1]();
      }
      return result[0];
    }, [initiallyActive, result]);
    return result;
  }
  function ArrowSmallUpDownIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M16.3 21.7a1 1 0 0 0 1.4 0l4-4a1 1 0 0 0-1.4-1.4L18 18.58V3a1 1 0 1 0-2 0v15.59l-2.3-2.3a1 1 0 0 0-1.4 1.42l4 4ZM6.3 2.3a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L8 5.42V21a1 1 0 1 1-2 0V5.41l-2.3 2.3a1 1 0 0 1-1.4-1.42l4-4Z"
        }
      )
    );
  }
  function SortSelect({ options, value, onChange }) {
    const buttonRef = require$$0$1.useRef();
    const selectedSort = options.find((o) => o.value === value);
    return /* @__PURE__ */ BdApi.React.createElement(
      Popout,
      {
        targetElementRef: buttonRef,
        position: "bottom",
        align: "right",
        renderPopout: (props) => /* @__PURE__ */ BdApi.React.createElement(ContextMenu$1.Menu, { ...props }, /* @__PURE__ */ BdApi.React.createElement(ContextMenu$1.Group, { label: "Sort" }, options.map((option) => /* @__PURE__ */ BdApi.React.createElement(
          ContextMenu$1.RadioItem,
          {
            key: option.value,
            id: `sort-${option.value}`,
            group: "sort",
            label: option.label,
            checked: option.value === value,
            action: () => onChange(option.value)
          }
        ))))
      },
      (props) => /* @__PURE__ */ BdApi.React.createElement(
        Button$1,
        {
          ...props,
          ref: buttonRef,
          variant: "secondary",
          rounded: true,
          icon: ArrowSmallUpDownIcon,
          text: selectedSort?.label ?? "Sort"
        }
      )
    );
  }
  function PackCard({ pack, location = PackContentLocation.CATALOG }) {
    const onClick = () => ModalActions.openModal((props) => /* @__PURE__ */ BdApi.React.createElement(
      PackModal,
      {
        ...props,
        filename: pack.filename,
        location
      }
    ));
    const onIntersection = require$$0$1.useCallback((isIntersecting) => {
      if (location === PackContentLocation.CATALOG && isIntersecting)
        PackRegistry.markAsKnown(pack);
    }, [pack, location]);
    const cardRef = useIsVisible(onIntersection, 0.5);
    return /* @__PURE__ */ BdApi.React.createElement(
      Clickable,
      {
        tag: "div",
        innerRef: cardRef,
        className: "BA__packCard",
        onClick
      },
      /* @__PURE__ */ BdApi.React.createElement(
        PackContent,
        {
          className: "BA__packCardContent",
          pack,
          location,
          size: "sm"
        }
      )
    );
  }
  css`.BA__packCard {
    color: var(--background-base-lowest);
    background-color: currentColor;
    box-shadow: 0 0 0 1px var(--border-subtle);
    border-radius: 16px;
    cursor: pointer;
    overflow: clip;
    position: relative;
    display: flex;
    flex-direction: column;
    transition: color .2s ease;
}
.BA__packCard:hover {
    color: var(--background-base-lower);
}
.BA__packCardContent {
    flex: 1;
}``PackCard`;
  const defaultSortOptions = [
    {
      value: "name",
      label: "By name",
      compare: (a, b) => a.name.localeCompare(b.name)
    },
    {
      value: "author",
      label: "By author",
      compare: (a, b) => a.author.localeCompare(b.author)
    }
  ];
  const defaultSearchableFields = ["name", "author", "description"];
  function usePackSearch(allItems, {
    searchableFields = defaultSearchableFields,
    sort: {
      options: sortOptions = defaultSortOptions,
      preference: sortPreference,
      setPreference: setSortPreference
    } = {}
  } = {}) {
    const [query, setQuery] = require$$0$1.useState("");
    const trimmedQuery = query.trim();
    const [sort, setSort] = require$$0$1.useState(sortPreference ?? sortOptions[0].value);
    const selectedSort = sortOptions.find((o) => o.value === sort);
    require$$0$1.useEffect(() => {
      setSortPreference?.(sort);
    }, [sort]);
    const items2 = matchSorter(
      allItems,
      trimmedQuery,
      { keys: searchableFields }
    ).sort(selectedSort?.compare ?? (() => 0));
    return {
      items: items2,
      query,
      setQuery,
      sort,
      setSort,
      selectedSort,
      sortOptions,
      searchableFields
    };
  }
  function PackListView({
    title,
    items: allItems,
    pending = false,
    error: error2 = null,
    location,
    empty = /* @__PURE__ */ BdApi.React.createElement(NoPacksPlaceholder, null),
    actions,
    sortOptions,
    searchableFields,
    pageSize = 6,
    adjective = "available",
    data: data2,
    leading,
    trailing
  }) {
    const {
      items: filteredItems,
      query,
      setQuery,
      sort,
      setSort,
      sortOptions: displayedSortOptions
    } = usePackSearch(allItems, {
      searchableFields,
      sort: {
        options: sortOptions,
        preference: data2?.sort,
        setPreference: (value) => data2 && (data2.sort = value)
      }
    });
    const { page, setPage, offset, items: items2 } = usePagination(
      filteredItems,
      pageSize,
      [query, pending]
    );
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packListView" }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packListViewHeader" }, /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        variant: "heading-xl/semibold",
        color: "header-primary"
      },
      title
    ), /* @__PURE__ */ BdApi.React.createElement(
      SearchBar,
      {
        className: "BA__packListViewSearchBar",
        placeholder: "Search",
        size: "md",
        query,
        onChange: setQuery,
        onClear: () => setQuery(""),
        autoFocus: true
      }
    )), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packListViewActionBar" }, actions && /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packListViewActions" }, actions), /* @__PURE__ */ BdApi.React.createElement(
      SortSelect,
      {
        options: displayedSortOptions,
        value: sort,
        onChange: setSort
      }
    )), pending ? /* @__PURE__ */ BdApi.React.createElement(Spinner, { className: "BA__packListViewSpinner" }) : error2 ? /* @__PURE__ */ BdApi.React.createElement(ErrorCard, { text: error2 }) : allItems.length > 0 ? /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, items2.length > 0 ? /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, leading, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packListViewList" }, items2.map((pack) => /* @__PURE__ */ BdApi.React.createElement(
      PackCard,
      {
        key: pack.filename,
        pack,
        location
      }
    ))), /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__packListViewMeta",
        variant: "text-sm/medium",
        color: "text-muted"
      },
      "Displaying ",
      items2.length < filteredItems.length ? /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement("b", null, offset + 1, "-", offset + items2.length), " out of ") : filteredItems.length === allItems.length && allItems.length > 1 ? "all " : "",
      items2.length < filteredItems.length ? /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, filteredItems.length) : /* @__PURE__ */ BdApi.React.createElement("b", null, filteredItems.length),
      filteredItems.length === allItems.length && ` ${adjective}`,
      filteredItems.length > 1 ? " packs" : " pack",
      filteredItems.length < allItems.length && ` • ${allItems.length} ${adjective}`
    ), trailing) : /* @__PURE__ */ BdApi.React.createElement(
      NoPacksPlaceholder,
      {
        title: "No results",
        description: "There are no packs matching your search",
        actions: [
          /* @__PURE__ */ BdApi.React.createElement(
            Button$1,
            {
              text: "Show all",
              onClick: () => setQuery("")
            }
          )
        ]
      }
    ), /* @__PURE__ */ BdApi.React.createElement(
      Paginator,
      {
        pageSize,
        totalCount: filteredItems.length,
        maxVisiblePages: 5,
        currentPage: page,
        onPageChange: setPage
      }
    )) : empty);
  }
  css`.BA__packListViewHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 32px;
    margin-bottom: 16px;
}
.BA__packListViewSearchBar {
    max-width: 260px;
}
.BA__packListViewActionBar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
    margin-bottom: 16px;
}
.BA__packListViewActions {
    display: flex;
    align-items: center;
    gap: 4px;
}
.BA__packListViewMeta {
    margin: 16px 0;
    text-align: right;
}
.BA__packListViewMeta b {
    font-weight: 600;
    color: var(--text-default);
}
.BA__packListViewList {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-top: 16px;
}
.BA__packListViewSpinner {
    padding: 40px;
}``PackListView`;
  function FolderIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"
        }
      )
    );
  }
  const usageCompare = (a, b) => Core.getModulesUsingPack(b).length - Core.getModulesUsingPack(a).length;
  const librarySortOptions = [
    {
      value: "default",
      label: "Default",
      compare: (a, b) => {
        const [hasUpdateA, hasUpdateB] = [a, b].map((pack) => PackRegistry.hasUpdate(pack));
        if (hasUpdateA !== hasUpdateB) return hasUpdateA ? -1 : 1;
        return usageCompare(a, b);
      }
    },
    {
      value: "usage",
      label: "By usage",
      compare: usageCompare
    },
    ...defaultSortOptions
  ];
  function Library() {
    const registry = usePackRegistry();
    const [data2] = useData("library");
    return /* @__PURE__ */ BdApi.React.createElement(
      PackListView,
      {
        title: "Library",
        items: PackManager.getAllPacks(true),
        sortOptions: librarySortOptions,
        data: data2,
        adjective: "installed",
        empty: /* @__PURE__ */ BdApi.React.createElement(NoPacksPlaceholder, { actions: ["catalog"] }),
        actions: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, registry.verifier.hasIssues() && /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            variant: "critical-primary",
            icon: CircleWarningIcon,
            text: "Resolve issues",
            onClick: () => registry.verifier.showModal()
          }
        ), registry.hasOutdatedPacks() && /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            icon: DownloadIcon,
            text: "Update all",
            onClick: () => registry.updateAll(),
            loading: registry.hasPending,
            disabled: registry.hasPending
          }
        ), /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: "Open Pack Directory" }, (props) => /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            ...props,
            variant: "icon-only",
            icon: FolderIcon,
            onClick: () => DiscordNative.fileManager.showItemInFolder(
              path.resolve(PackManager.addonFolder, PackManager.addonList[0]?.filename ?? "./")
            )
          }
        )), /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: "Check for updates" }, (props) => /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            ...props,
            variant: "icon-only",
            icon: RefreshIcon,
            onClick: () => registry.checkForUpdates({ useToasts: true }),
            loading: registry.isPending(),
            disabled: registry.isPending()
          }
        ))),
        location: PackContentLocation.LIBRARY,
        leading: registry.hasError && /* @__PURE__ */ BdApi.React.createElement(Alert, { messageType: AlertTypes.ERROR }, Messages.CATALOG_OUT_OF_DATE)
      }
    );
  }
  const packSelectSortOptions = librarySortOptions.filter((option) => ["usage", "name"].includes(option.value));
  function scrollIntoView(el) {
    if (typeof el === "string") el = document.querySelector(el);
    if (!el) return;
    if (typeof el.scrollIntoViewIfNeeded === "function") el.scrollIntoViewIfNeeded(false);
    else el.scrollIntoView({ block: "nearest", inline: "nearest" });
  }
  function PackSelectContent({ pack }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packSelectContent" }, /* @__PURE__ */ BdApi.React.createElement(PackSplash, { pack }), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packSelectContentContainer" }, /* @__PURE__ */ BdApi.React.createElement(
      PackHeader,
      {
        pack,
        size: "sm",
        popoutType: "tooltip"
      }
    ), pack.description && /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__packSelectContentDescription",
        variant: "text-sm/medium",
        color: "text-muted",
        lineClamp: 2
      },
      pack.description
    )));
  }
  function PackSelectOption({ pack, selected = false, focused = false, active = false, onClick }) {
    const props = useListItem(pack.slug);
    return /* @__PURE__ */ BdApi.React.createElement(
      Clickable,
      {
        ...props,
        className: classNames({
          "BA__packSelectOption": true,
          "BA__packSelectOption--focused": focused,
          "BA__packSelectOption--selected": selected
        }),
        onClick,
        focusProps: { enabled: false },
        role: "option"
      },
      /* @__PURE__ */ BdApi.React.createElement(PackSelectContent, { pack }),
      /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packSelectTrailing" }, active && /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packSelectActiveDot" }))
    );
  }
  function PackSelectPopout({ selectRef, packs, selected, onSelect, isActive, updatePosition }) {
    const popoutRef = require$$0$1.useRef();
    const scrollerRef = require$$0$1.useRef();
    const { width } = useElementBounding(selectRef);
    useRafFn(updatePosition);
    const [focused, setFocused] = require$$0$1.useState(selected);
    const setFocus = require$$0$1.useCallback((selector, slug2) => {
      setFocused(slug2);
      scrollIntoView(selector);
    }, [setFocused]);
    const scrollToStart = require$$0$1.useCallback(() => new Promise((resolve) => {
      scrollerRef.current?.scrollTo({ top: 0 });
      requestAnimationFrame(resolve);
    }), [scrollerRef]);
    const scrollToEnd = require$$0$1.useCallback(() => new Promise((resolve) => {
      scrollerRef.current?.scrollTo({ top: scrollerRef.current?.scrollHeight });
      requestAnimationFrame(resolve);
    }), [scrollerRef]);
    const id = require$$0$1.useId();
    const navigator = useListNavigator({
      id,
      isEnabled: true,
      wrap: true,
      defaultFocused: selected,
      useVirtualFocus: true,
      setFocus,
      scrollToStart,
      scrollToEnd,
      disableClickOnSpace: true
    });
    require$$0$1.useLayoutEffect(() => scrollIntoView(`[data-list-item-id="${id}___${selected}"]`), []);
    useFocusLock(popoutRef);
    const [preferences] = useData("preferences");
    const {
      items: items2,
      query,
      setQuery,
      sort,
      setSort,
      sortOptions
    } = usePackSearch(packs, {
      searchableFields: ["name", "description"],
      sort: {
        options: packSelectSortOptions,
        preference: preferences.sort,
        setPreference: (value) => preferences.sort = value
      }
    });
    return /* @__PURE__ */ BdApi.React.createElement(ListNavigatorProvider, { navigator }, /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        ref: popoutRef,
        className: "BA__packSelectPopout",
        style: { width },
        onKeyDown: navigator.containerProps.onKeyDown
      },
      /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packSelectPopoutHeader" }, /* @__PURE__ */ BdApi.React.createElement(
        SearchBar,
        {
          className: "BA__packSelectPopoutSearchBar",
          placeholder: "Search",
          size: "md",
          query,
          onChange: setQuery,
          onClear: () => setQuery(""),
          autoFocus: true
        }
      ), /* @__PURE__ */ BdApi.React.createElement(
        SortSelect,
        {
          options: sortOptions,
          value: sort,
          onChange: setSort
        }
      )),
      /* @__PURE__ */ BdApi.React.createElement(ListNavigatorContainer, null, ({ ref, ...props }) => /* @__PURE__ */ BdApi.React.createElement(
        "div",
        {
          ...props,
          ref: (el) => {
            ref.current = el;
            scrollerRef.current = el;
          },
          className: classNames(
            "BA__packSelectPopoutScroller",
            DiscordClasses.Scroller.thin
          ),
          role: "listbox"
        },
        items2.map((item) => /* @__PURE__ */ BdApi.React.createElement(
          PackSelectOption,
          {
            key: item.slug,
            pack: item,
            selected: item.slug === selected,
            focused: item.slug === focused,
            active: isActive?.(item),
            onClick: () => onSelect(item)
          }
        ))
      ))
    ));
  }
  function PackSelect({ packs, selected, onSelect, className, isActive }) {
    const selectRef = require$$0$1.useRef();
    const selectedPack = packs.find((pack) => pack.slug === selected);
    return /* @__PURE__ */ BdApi.React.createElement(
      Popout,
      {
        targetElementRef: selectRef,
        position: "bottom",
        align: "center",
        clickTrap: true,
        renderPopout: ({ closePopout, updatePosition }) => /* @__PURE__ */ BdApi.React.createElement(
          PackSelectPopout,
          {
            selectRef,
            packs,
            selected,
            onSelect: (pack) => {
              onSelect(pack);
              closePopout();
            },
            isActive,
            updatePosition
          }
        )
      },
      (props, { isShown }) => /* @__PURE__ */ BdApi.React.createElement(
        Clickable,
        {
          ...props,
          innerRef: selectRef,
          className: classNames("BA__packSelect", className)
        },
        selectedPack ? /* @__PURE__ */ BdApi.React.createElement(
          PackSelectContent,
          {
            key: selectedPack.slug,
            pack: selectedPack
          }
        ) : /* @__PURE__ */ BdApi.React.createElement(
          Text$1,
          {
            className: "BA__packSelectPlaceholder",
            variant: "text-md/normal",
            color: "text-muted"
          },
          "Select pack"
        ),
        /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__packSelectTrailing" }, isShown ? /* @__PURE__ */ BdApi.React.createElement(
          ChevronSmallUpIcon,
          {
            size: "md",
            color: colors.INTERACTIVE_NORMAL
          }
        ) : /* @__PURE__ */ BdApi.React.createElement(
          ChevronSmallDownIcon,
          {
            size: "md",
            color: colors.INTERACTIVE_NORMAL
          }
        ))
      )
    );
  }
  css`.BA__packSelect {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    border-radius: 8px;
    background-color: var(--background-base-lowest);
    box-shadow: 0 0 0 1px var(--border-subtle);
    transition: background-color .2s;
    min-height: 84px;
    overflow: hidden;
}
.BA__packSelect:hover {
    background-color: var(--background-base-lower);
}
.BA__packSelectPlaceholder {
    padding-left: 16px;
}

.BA__packSelectPopout {
    display: flex;
    flex-direction: column;
    max-height: 360px;
    border-radius: 8px;
    background-color: var(--background-base-lowest);
    box-shadow: 0 0 0 1px var(--border-subtle),
        var(--shadow-high);
    overflow: hidden;
}
.BA__packSelectPopoutHeader {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px;
    border-bottom: 1px solid var(--border-subtle);
}
.BA__packSelectPopoutScroller {
    overflow: hidden auto;
}

.BA__packSelectOption {
    display: flex;
    justify-content: space-between;
    align-items: stretch;
    cursor: pointer;
    background-color: var(--background-base-lowest);
    transition: background-color .2s;
}
.BA__packSelectOption:is(:hover, :focus-visible),
.BA__packSelectOption--focused {
    background-color: var(--background-base-lower);
}
.BA__packSelectOption--selected {
    background-color: var(--background-base-low) !important;
}

.BA__packSelectContent {
    height: 84px;
    display: flex;
    align-items: stretch;
}
.BA__packSelectContentContainer {
    padding: 12px;
    display: flex;
    flex-direction: column;
    justify-content: center;
}
.BA__packSelectContentDescription {
    margin-top: 2px;
    word-break: break-word;
}

.BA__packSelectTrailing {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    box-sizing: content-box;
    width: 24px;
    padding-left: 12px;
    padding-right: 16px;
    flex-shrink: 0;
}

.BA__packSelectActiveDot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background-color: var(--brand-500);
}``PackSelect`;
  function ModuleSettings({ moduleId, refToScroller, pageSize = 15 }) {
    const [preferences] = useData("preferences");
    const module2 = useModule(moduleId, true);
    const onSelect = require$$0$1.useCallback((type, pack2, animation) => {
      if (!animation) module2.setAnimation(type, null, null);
      else module2.setAnimation(type, pack2.slug, animation.key, {});
    }, [module2]);
    const setIsEnabled = require$$0$1.useCallback((value) => module2.setIsEnabled(value), [module2]);
    const selected = module2.getAnimations();
    const preinstalledPack = PackManager.getPack(PREINSTALLED_PACK_SLUG);
    const preinstalledAnimations = preinstalledPack?.animations.filter((a) => module2.isSupportedBy(a)) ?? [];
    const packs = PackManager.getAllPacks().filter((p) => p.animations.some((a) => module2.isSupportedBy(a)));
    const [packSlug, setPackSlug] = require$$0$1.useState(null);
    const pack = packs.find((pack2) => pack2.slug === packSlug);
    const selectPack = require$$0$1.useCallback((pack2) => {
      setPackSlug(pack2.slug);
      preferences.pack = pack2.slug;
    }, [setPackSlug, preferences]);
    const isPackActive = (pack2) => Object.values(selected).some((data2) => data2.pack?.slug === pack2.slug);
    require$$0$1.useEffect(() => {
      if (!pack) setPackSlug(
        packs.find((pack2) => pack2.slug === selected.enter.pack?.slug)?.slug ?? packs.find((pack2) => pack2.slug === preferences.pack)?.slug ?? packs[0]?.slug ?? null
      );
    }, [!pack]);
    const animations2 = pack?.animations.filter((animation) => module2.isSupportedBy(animation)) ?? [];
    const { page, setPage, items: items2 } = usePagination(
      animations2,
      pageSize,
      [packSlug]
    );
    require$$0$1.useEffect(() => {
      if (!pack) return;
      const indexes = Object.values(selected).map(
        ({ packSlug: packSlug2, animationKey }) => packSlug2 === pack.slug ? animations2.findIndex((animation) => animation.key === animationKey) : -1
      ).filter((i) => i !== -1);
      if (indexes.length) setPage(Math.min(...indexes.map((i) => Math.floor(i / pageSize) + 1)));
    }, [packSlug]);
    return /* @__PURE__ */ BdApi.React.createElement(
      MigratorContainer,
      {
        migrator: Config.migrator,
        className: "BA__moduleSettingsContainer"
      },
      /* @__PURE__ */ BdApi.React.createElement(ModuleContext, { value: module2 }, /* @__PURE__ */ BdApi.React.createElement("div", { key: moduleId, className: "BA__moduleSettings" }, /* @__PURE__ */ BdApi.React.createElement(
        ModuleSettingsHeader,
        {
          module: module2,
          enabled: module2.isEnabled(),
          setEnabled: setIsEnabled,
          selected,
          onSelect,
          refToScroller
        }
      ), preinstalledAnimations.length ? /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "heading-sm/semibold", className: "BA__moduleSettingsSectionTitle" }, /* @__PURE__ */ BdApi.React.createElement("span", null, "ANIMATIONS")), /* @__PURE__ */ BdApi.React.createElement(
        AnimationList,
        {
          module: module2,
          pack: preinstalledPack,
          animations: preinstalledAnimations,
          selected,
          onSelect,
          refToScroller
        }
      )) : null, /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "heading-sm/semibold", className: "BA__moduleSettingsSectionTitle" }, /* @__PURE__ */ BdApi.React.createElement("span", null, "PACKS")), !!packs.length ? /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(
        PackSelect,
        {
          className: "BA__moduleSettingsPackSelect",
          packs,
          selected: packSlug,
          onSelect: selectPack,
          isActive: isPackActive
        }
      ), pack && /* @__PURE__ */ BdApi.React.createElement(
        "div",
        {
          key: pack.slug,
          className: "BA__moduleSettingsPack"
        },
        /* @__PURE__ */ BdApi.React.createElement(
          AnimationList,
          {
            module: module2,
            pack,
            animations: items2,
            selected,
            onSelect,
            refToScroller
          }
        ),
        /* @__PURE__ */ BdApi.React.createElement(
          Paginator,
          {
            pageSize,
            totalCount: animations2.length,
            maxVisiblePages: 5,
            currentPage: page,
            onPageChange: setPage
          }
        )
      )) : /* @__PURE__ */ BdApi.React.createElement(NoPacksPlaceholder, null)))
    );
  }
  css`.BA__moduleSettings {
    transition: transform .4s;
}

.BA__moduleSettingsSectionTitle {
    margin-top: 32px;
    margin-bottom: 16px;
    color: var(--header-secondary);
    text-align: center;
    position: relative;
}
.BA__moduleSettingsSectionTitle::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    width: 100%;
    height: 1px;
    background: var(--border-normal);
}
.BA__moduleSettingsSectionTitle > span {
    position: relative;
    background: var(--background-base-low);
    padding: 0 8px;
}

.BA__moduleSettingsPackSelect {
    margin-bottom: 12px;
}``ModuleSettings`;
  function SettingsSidebarHeader() {
    const [section2] = useSection();
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: classNames(
      "BA__settingsSidebarHeader",
      {
        "BA__settingsSidebarHeader--hidden": section2 === SettingsSection.Home
      }
    ) }, /* @__PURE__ */ BdApi.React.createElement(IconBrand, null), /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-md/semibold" }, meta$1.name.slice(1)));
  }
  css`.BA__settingsSidebarHeader {
    position: relative;
    margin-top: -30px;
    padding-bottom: 10px;
    transition: .2s opacity, .2s transform;
    pointer-events: none;
}
    
.BA__settingsSidebarHeader > svg {
    display: block;
    width: 52px;
    height: 52px;
}

.BA__settingsSidebarHeader > div {
    position: absolute;
    top: 26px;
    left: 41px;
    color: var(--header-primary);
}

.BA__settingsSidebarHeader--hidden {
    opacity: 0;
    transform: translateX(-2px);
}``SettingsSidebarHeader`;
  function ModeSwitch() {
    const [mode, setMode] = useMode();
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: `BA__modeSwitch ${DiscordClasses.Margins.marginBottom8}` }, /* @__PURE__ */ BdApi.React.createElement(
      ButtonGroup,
      {
        options: [
          { label: "Simple", value: SettingsMode.Simple },
          { label: "Advanced", value: SettingsMode.Advanced }
        ],
        selected: mode,
        onChange: setMode
      }
    ));
  }
  const SettingsNoticeComponent = require$$0$1.lazy(async () => ({ default: await SettingsNotice }));
  function FormNotice() {
    const onSave = require$$0$1.useCallback(() => Config.save(), []);
    const onReset = require$$0$1.useCallback(() => Config.load(), []);
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__formNotice" }, /* @__PURE__ */ BdApi.React.createElement(require$$0$1.Suspense, null, /* @__PURE__ */ BdApi.React.createElement(
      SettingsNoticeComponent,
      {
        onSave,
        onReset
      }
    )));
  }
  css`.BA__formNotice > * {
    background-color: var(--background-base-lowest);
    border: none;
    box-shadow: 0 0 0 1px var(--border-subtle);
}``FormNotice`;
  function SpineIcon() {
    return /* @__PURE__ */ BdApi.React.createElement("svg", { width: "12", height: "11", viewBox: "0 0 12 11", fill: "none", "aria-hidden": "true" }, /* @__PURE__ */ BdApi.React.createElement(
      "path",
      {
        d: "M11 9H4C2.89543 9 2 8.10457 2 7V1C2 0.447715 1.55228 0 1 0C0.447715 0 0 0.447715 0 1V7C0 9.20914 1.79086 11 4 11H11C11.5523 11 12 10.5523 12 10C12 9.44771 11.5523 9 11 9Z",
        fill: "currentColor"
      }
    ));
  }
  function HomeIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "m2.4 8.4 8.38-6.46a2 2 0 0 1 2.44 0l8.39 6.45a2 2 0 0 1-.79 3.54l-.32.07-.82 8.2a2 2 0 0 1-1.99 1.8H16a1 1 0 0 1-1-1v-5a3 3 0 0 0-6 0v5a1 1 0 0 1-1 1H6.31a2 2 0 0 1-1.99-1.8L3.5 12l-.32-.07a2 2 0 0 1-.79-3.54Z"
        }
      )
    );
  }
  function ExternalLinkIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: "none",
          stroke: typeof color === "string" ? color : color.css,
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "2",
          d: "M15 3h6v6m-11 5L21 3m-3 10v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"
        }
      )
    );
  }
  function IconAuthor({ size, width, height, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...props,
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 678 678"
      },
      /* @__PURE__ */ BdApi.React.createElement("defs", null, /* @__PURE__ */ BdApi.React.createElement("radialGradient", { id: "BA__iconAuthorGradient", cx: "90.13", cy: "669.95", r: "809.18", gradientTransform: "matrix(-0.1, -0.99, -0.99, 0.1, 711.72, 640.54)", gradientUnits: "userSpaceOnUse" }, /* @__PURE__ */ BdApi.React.createElement("stop", { offset: "0", stopColor: "#f9ed32" }), /* @__PURE__ */ BdApi.React.createElement("stop", { offset: "0.66", stopColor: "#ee2a7b" }), /* @__PURE__ */ BdApi.React.createElement("stop", { offset: "1", stopColor: "#002aff" }))),
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          d: "M583.89,526.07a33.47,33.47,0,0,0,45-11.69q2.84-4.69,5.53-9.49A338.85,338.85,0,0,0,247.38,12.77a338.85,338.85,0,0,0-74.27,621.69,339.76,339.76,0,0,0,353.77-13.27,16.78,16.78,0,0,0-1.11-28.6L480.13,567a33.78,33.78,0,0,0-31.25-.86c-72.77,35.08-161.16,34.86-236.44-8.74-119.18-69-160.94-222.16-93.38-342.18C187.26,94,341.3,50.83,462.57,118.92c102,57.28,148.84,175.34,120.71,283.6a16.77,16.77,0,0,1-24.45,10.33l-38.12-21.4a33.51,33.51,0,0,1-16.92-33.06C511.47,292.38,478.88,225,416,192c-75.58-39.67-175.43-11.64-219.32,61.57-48.18,80.39-20.14,184.51,61,230.09,60.08,33.73,132.39,25.91,183.57-14.08a33.54,33.54,0,0,1,37.05-2.78ZM297.36,406.71A79.49,79.49,0,1,1,400.7,389.12,79.57,79.57,0,0,1,297.36,406.71Z",
          fill: "url(#BA__iconAuthorGradient)"
        }
      )
    );
  }
  function toStyle(state) {
    const translate = Object.values(state.position).map((v) => v + "px").join(", ");
    return {
      transform: `translate(${translate})`,
      transition: `${state.duration}s ease transform`
    };
  }
  function SpotlightAnimation({ count = 8, size = 400, areaSize = 200, speed = 50, className }) {
    const getRandomPosition = require$$0$1.useCallback(() => ({
      x: Math.random() * areaSize,
      y: Math.random() * areaSize
    }), [areaSize]);
    const generateStates = require$$0$1.useCallback(
      () => Array.from({ length: count }).map(() => ({ position: getRandomPosition() })),
      [count, getRandomPosition]
    );
    const [states, setStates] = require$$0$1.useState(generateStates());
    const generateNewState = require$$0$1.useCallback(
      (state) => {
        const position2 = getRandomPosition();
        const duration = Math.hypot(
          Math.abs(position2.x - state.position.x),
          Math.abs(position2.y - state.position.y)
        ) / speed;
        return {
          position: position2,
          duration
        };
      },
      [getRandomPosition]
    );
    const updatePosition = require$$0$1.useCallback(
      (i) => setStates((_states) => {
        const states2 = [..._states];
        states2[i] = generateNewState(states2[i]);
        return states2;
      }),
      [setStates, generateNewState]
    );
    require$$0$1.useEffect(() => {
      const id = requestAnimationFrame(() => setStates(
        (states2) => states2.map(generateNewState)
      ));
      return () => cancelAnimationFrame(id);
    }, [count]);
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        className: classNames("BA__spotlightAnimation", className),
        style: {
          width: areaSize + "px",
          "--ba--spotlight-animation-size": size + "px"
        }
      },
      states.map((state, index2) => /* @__PURE__ */ BdApi.React.createElement(
        "div",
        {
          className: "BA__spotlightAnimationItem",
          style: toStyle(state),
          onTransitionEnd: () => updatePosition(index2)
        }
      ))
    );
  }
  const SpotlightAnimation$1 = require$$0$1.memo(SpotlightAnimation);
  css`.BA__spotlightAnimation {
    position: absolute;
    top: 50%;
    left: 50%;
    translate: -50% -50%;
    pointer-events: none;
    aspect-ratio: 1;
    opacity: .3;
    filter: blur(30px);
    animation: BA__spotlightAnimationRotate 30s linear infinite;
}

.BA__spotlightAnimationItem {
    position: absolute;
    top: 0;
    left: 0;
    width: var(--ba--spotlight-animation-size);
    height: var(--ba--spotlight-animation-size);
    translate: -50% -50%;
}
.BA__spotlightAnimationItem::after {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(circle, var(--brand-500) 30%, transparent 70%);
    animation: BA__spotlightAnimationEnter 5s cubic-bezier(0.16, 1, 0.3, 1);
}

@keyframes BA__spotlightAnimationRotate {
    0% { rotate: 0deg; }
    100% { rotate: 360deg; }
}
@keyframes BA__spotlightAnimationEnter {
    0% {
        scale: .3;
        opacity: 0;
    }
    100% {
        scale: 1;
        opacity: 1;
    }
}``SpotlightAnimation`;
  function BookIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M6.5 2A2.5 2.5 0 0 0 4 4.5v15A2.5 2.5 0 0 0 6.5 22h13.25a.75.75 0 0 0 0-1.5H6.5a1 1 0 0 1-1-1h14.25a.75.75 0 0 0 .75-.75V4.5A2.5 2.5 0 0 0 18 2zM8 5h8a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1"
        }
      )
    );
  }
  const madeByPhrases = [
    "Made by",
    "Developed by",
    "Created by",
    "Authored by",
    "Brought to you by",
    "Crafted by",
    "Produced by",
    "Built by",
    "Designed by",
    "Brought to life by",
    "Cultivated by",
    "Established by"
  ];
  function CatalogPromoTooltip({ packs, displayLimit = 3, children: children2, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      Tooltip$1,
      {
        shouldShow: packs.length > 0,
        tooltipClassName: "BA__catalogPromoTooltip",
        position: "bottom",
        color: Tooltip$1.Colors.BRAND,
        spacing: 12,
        allowOverflow: true,
        text: () => /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__catalogPromoTooltipContent" }, /* @__PURE__ */ BdApi.React.createElement(PackPicture, null), /* @__PURE__ */ BdApi.React.createElement("div", null, `Check out the newly available ${packs.length > 1 ? "packs" : "pack"}: `, /* @__PURE__ */ BdApi.React.createElement(InlineList, { items: packs.map((pack) => pack.name) }), "!")),
        ...props
      },
      children2
    );
  }
  function Home() {
    const [section2, setSection2] = useSection();
    const madeBy = require$$0$1.useMemo(
      () => madeByPhrases[Math.floor(Math.random() * madeByPhrases.length)],
      []
    );
    const { isEnterActive } = require$$0$1.use(AnimeTransitionContext);
    const [{ visited: visitedCatalog }] = useData("catalog");
    const registry = usePackRegistry();
    const unknownPacks = registry.getUnknownPacks();
    const highlightCatalog = !visitedCatalog || unknownPacks.length > 0;
    const { isActive: isMigratorActive } = Config.migrator.use();
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__homeContainer" }, isMigratorActive && /* @__PURE__ */ BdApi.React.createElement(MigratorAlert, { migrator: Config.migrator }), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__home" }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__homeHeading" }, !isEnterActive && /* @__PURE__ */ BdApi.React.createElement(SpotlightAnimation$1, { className: "BA__homeSpotlightAnimation" }), /* @__PURE__ */ BdApi.React.createElement(
      IconBrand,
      {
        size: "custom",
        width: 120,
        height: 120,
        className: "BA__homeIcon"
      }
    ), /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__homeTitle",
        variant: "heading-xxl/bold",
        tag: "h3",
        color: "header-primary"
      },
      meta$1.name
    ), /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__homeDescription",
        variant: "text-md/normal",
        color: "header-primary"
      },
      sanitize$1(meta$1.description)
    ), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__homeHeadingActions" }, /* @__PURE__ */ BdApi.React.createElement(CatalogPromoTooltip, { packs: unknownPacks }, (props) => /* @__PURE__ */ BdApi.React.createElement(
      Button$1,
      {
        ...props,
        variant: highlightCatalog ? "expressive" : "primary",
        icon: ShopIcon,
        text: "Catalog",
        onClick: () => setSection2(SettingsSection.Catalog)
      }
    )), /* @__PURE__ */ BdApi.React.createElement(
      Button$1,
      {
        variant: "secondary",
        icon: BookIcon,
        text: "Documentation",
        onClick: () => handleClick({ href: Documentation.homeUrl })
      }
    ))), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__homeAuthorSection" }, /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__homeAuthorLabel",
        variant: "text-sm/normal",
        color: "text-muted"
      },
      madeBy
    ), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__homeAuthor" }, /* @__PURE__ */ BdApi.React.createElement(
      IconAuthor,
      {
        className: "BA__homeAuthorAvatar",
        size: "custom",
        width: 36,
        height: 36
      }
    ), /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-lg/medium" }, meta$1.author)), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__homeAuthorActions" }, /* @__PURE__ */ BdApi.React.createElement(
      Button$1,
      {
        variant: "active",
        icon: CircleDollarSignIcon,
        text: "Support the author",
        fullWidth: true,
        onClick: () => handleClick({ href: meta$1.donate })
      }
    ), /* @__PURE__ */ BdApi.React.createElement(
      Button$1,
      {
        size: "sm",
        variant: "secondary",
        icon: ExternalLinkIcon,
        iconPosition: "end",
        text: `Plugins made by ${meta$1.author}`,
        fullWidth: true,
        onClick: () => handleClick({ href: meta$1.authorLink })
      }
    )))));
  }
  css`.BA__homeContainer {
    position: absolute;
    inset: 0;
    padding: 60px 40px 40px;
    display: flex;
    flex-direction: column;
}
.BA__home {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: stretch;
    text-align: center;
    flex: 1;
}

.BA__homeHeading {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 8vh;
    position: relative;
    isolation: isolate;
}
.BA__homeDescription {
    margin-top: 12px;
}
.BA__homeHeadingActions {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 24px;
}
.BA__homeSpotlightAnimation {
    z-index: -1;
}

.BA__homeAuthorSection {
    position: relative;
    margin-top: 11vh;
    display: flex;
    flex-direction: column;
    align-items: center;
}
.BA__homeAuthorLabel {
    margin-bottom: 12px;
    text-transform: uppercase;
}
.BA__homeAuthor {
    display: flex;
    align-items: center;
    gap: 12px;
}
.BA__homeAuthorActions {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
    margin-top: 28px;
    width: 250px;
}

.BA__catalogPromoTooltip {
    max-width: 100%;
}
.BA__catalogPromoTooltipContent {
    width: 230px;
    position: relative;
    padding: 10px 0 12px 80px;
}
.BA__catalogPromoTooltipContent svg {
    position: absolute;
    left: -62px;
    top: calc(50% + 6px);
    transform: translateY(-50%);
    height: 123px;
}``Home`;
  function CreateUpsellBanner({ className }) {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: classNames("BA__createUpsellBanner", className) }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__createUpsellArtContainer" }, /* @__PURE__ */ BdApi.React.createElement(PackPicture, { className: "BA__createUpsellArt" })), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__mainColumn" }, /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        tag: "h3",
        variant: "heading-lg/extrabold",
        color: "currentColor"
      },
      "Create your own Animation Packs"
    ), /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        variant: "text-sm/normal",
        color: "currentColor"
      },
      "Build your own animations and publish them to the official Catalog for everyone to download and use"
    )), /* @__PURE__ */ BdApi.React.createElement(
      Button$1,
      {
        className: "BA__createUpsellButton",
        variant: "overlay-primary",
        icon: BookIcon,
        text: "Documentation",
        onClick: () => handleClick({ href: Documentation.createUrl })
      }
    ));
  }
  css`.BA__createUpsellBanner {
    align-items: center;
    background: linear-gradient(187deg, #5865F2, #2F379F);
    background-size: cover;
    border-radius: 16px;
    flex-direction: row;
    padding-right: 24px;
}

.BA__createUpsellBanner, .BA__mainColumn {
    display: flex;
    justify-content: center;
}

.BA__mainColumn {
    color: var(--white-100);
    flex: 1;
    flex-direction: column;
    margin: auto 0;
    min-height: 96px;
    padding: 16px 16px 16px 4px;
}

.BA__createUpsellBanner h3 {
    margin-bottom: 4px;
}

.BA__createUpsellButton {
    padding: 11px 20px;
}

.BA__createUpsellButton:hover {
    opacity: .9;
}

.BA__createUpsellArtContainer {
    align-items: center;
    align-self: stretch;
    display: flex;
    flex-basis: 124px;
    height: 100px;
    position: relative;
}

.BA__createUpsellArt {
    width: 129px;
    bottom: -46px;
    left: -15px;
    object-fit: contain;
    pointer-events: none;
    position: absolute;
}``CreateUpsellBanner`;
  function GitHubIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "-1 -1 26 26"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "m12 .5c-6.63 0-12 5.28-12 11.792 0 5.211 3.438 9.63 8.205 11.188.6.111.82-.254.82-.567 0-.28-.01-1.022-.015-2.005-3.338.711-4.042-1.582-4.042-1.582-.546-1.361-1.335-1.725-1.335-1.725-1.087-.731.084-.716.084-.716 1.205.082 1.838 1.215 1.838 1.215 1.07 1.803 2.809 1.282 3.495.981.108-.763.417-1.282.76-1.577-2.665-.295-5.466-1.309-5.466-5.827 0-1.287.465-2.339 1.235-3.164-.135-.298-.54-1.497.105-3.121 0 0 1.005-.316 3.3 1.209.96-.262 1.98-.392 3-.398 1.02.006 2.04.136 3 .398 2.28-1.525 3.285-1.209 3.285-1.209.645 1.624.24 2.823.12 3.121.765.825 1.23 1.877 1.23 3.164 0 4.53-2.805 5.527-5.475 5.817.42.354.81 1.077.81 2.182 0 1.578-.015 2.846-.015 3.229 0 .309.21.678.825.56 4.801-1.548 8.236-5.97 8.236-11.173 0-6.512-5.373-11.792-12-11.792z"
        }
      )
    );
  }
  const catalogSortOptions = [
    {
      value: "newest",
      label: "Newest first",
      compare: (a, b) => new Date(b.createdAt) - new Date(a.createdAt)
    },
    {
      value: "oldest",
      label: "Oldest first",
      compare: (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
    },
    {
      value: "official",
      label: "Official first",
      compare: (a, b) => b.official - a.official
    },
    ...defaultSortOptions
  ];
  function Catalog() {
    const registry = usePackRegistry();
    const [data2] = useData("catalog");
    require$$0$1.useEffect(() => {
      if (data2.visited) return;
      registry.items.forEach((item) => registry.markAsKnown(item));
      data2.visited = true;
    }, []);
    return /* @__PURE__ */ BdApi.React.createElement(
      PackListView,
      {
        title: "Catalog",
        items: registry.items,
        sortOptions: catalogSortOptions,
        data: data2,
        pending: registry.isPending(),
        error: registry.isFatal && "Failed to load packs. Please try again later.",
        empty: /* @__PURE__ */ BdApi.React.createElement(
          NoPacksPlaceholder,
          {
            title: "No packs at the time",
            description: "Please come back later",
            actions: false
          }
        ),
        location: PackContentLocation.CATALOG,
        actions: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: "View on GitHub" }, (props) => /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            ...props,
            variant: "icon-only",
            icon: GitHubIcon,
            onClick: () => handleClick({ href: registry.baseUrl })
          }
        )), /* @__PURE__ */ BdApi.React.createElement(Tooltip$1, { text: "Refresh" }, (props) => /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            ...props,
            variant: "icon-only",
            icon: RefreshIcon,
            onClick: () => registry.updateRegistry(),
            disabled: registry.isPending()
          }
        ))),
        leading: registry.hasError && /* @__PURE__ */ BdApi.React.createElement(Alert, { messageType: AlertTypes.ERROR }, Messages.CATALOG_OUT_OF_DATE),
        trailing: /* @__PURE__ */ BdApi.React.createElement(CreateUpsellBanner, { className: "BA__catalogBanner" })
      }
    );
  }
  css` .BA__catalogBanner {
    margin-top: 52px;
}``Catalog`;
  function GeneralSettings() {
    const { config: config2, onChange } = useConfig();
    return /* @__PURE__ */ BdApi.React.createElement(MigratorContainer, { migrator: Config.migrator }, /* @__PURE__ */ BdApi.React.createElement(
      FormSection,
      {
        tag: FormTitleTags.H1,
        title: "General Settings"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        FormSection,
        {
          tag: FormTitleTags.H2,
          title: "Appearance",
          className: DiscordClasses.Margins.marginTop20,
          titleClassName: DiscordClasses.Margins.marginBottom8
        },
        /* @__PURE__ */ BdApi.React.createElement(
          FormSwitch,
          {
            className: DiscordClasses.Margins.marginBottom20,
            children: "Quick Preview",
            note: "Play the animation preview when hovering over an animation card. Disable to play it only when an animation card is expanded.",
            value: config2.general.quickPreview,
            onChange: (value) => {
              config2.general.quickPreview = value;
              onChange();
            }
          }
        ),
        /* @__PURE__ */ BdApi.React.createElement(
          FormSwitch,
          {
            className: DiscordClasses.Margins.marginBottom20,
            children: "Disable Hints",
            note: `Hide reference links to ${meta$1.name} documentation in the module settings, animation settings, etc.`,
            value: config2.general.disableHints,
            onChange: (value) => {
              config2.general.disableHints = value;
              onChange();
            }
          }
        ),
        /* @__PURE__ */ BdApi.React.createElement(FormItem, { className: DiscordClasses.Margins.marginBottom20 }, /* @__PURE__ */ BdApi.React.createElement(FormTitle, { className: DiscordClasses.Margins.marginBottom8 }, "Suppress Errors"), /* @__PURE__ */ BdApi.React.createElement(FormText, { className: DiscordClasses.Margins.marginBottom20 }, "Disable the toast notification for occurring errors. When an error is suppressed, it can only be seen via the Console."), /* @__PURE__ */ BdApi.React.createElement(
          RadioGroup,
          {
            options: [
              { value: SuppressErrors.All, name: "Suppress all errors" },
              { value: SuppressErrors.Animation, name: "Suppress animation errors" },
              { value: SuppressErrors.None, name: "Do not suppress errors" }
            ],
            value: config2.general.suppressErrors,
            onChange: ({ value }) => {
              config2.general.suppressErrors = value;
              onChange();
            }
          }
        ), /* @__PURE__ */ BdApi.React.createElement(Divider$2, { className: DiscordClasses.Margins.marginTop20 }))
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        FormSection,
        {
          tag: FormTitleTags.H2,
          title: "Optimizations",
          className: DiscordClasses.Margins.marginTop20,
          titleClassName: DiscordClasses.Margins.marginBottom8
        },
        /* @__PURE__ */ BdApi.React.createElement(
          FormSwitch,
          {
            className: DiscordClasses.Margins.marginBottom20,
            children: Messages.PRIORITIZE_ANIMATION_SMOOTHNESS,
            note: "Delay resource-intensive operations until after animations finish to avoid most of the stuttering that occurs while they are running.",
            value: config2.general.prioritizeAnimationSmoothness,
            onChange: (value) => {
              config2.general.prioritizeAnimationSmoothness = value;
              onChange();
            }
          }
        ),
        /* @__PURE__ */ BdApi.React.createElement(
          FormSwitch,
          {
            className: DiscordClasses.Margins.marginBottom20,
            children: "Preload Layers",
            note: "Load full-screen pages (User Settings, Server Settings, Channel Settings, etc.) in advance to prevent them from interrupting the animations when opened.",
            value: config2.general.preloadLayers,
            onChange: (value) => {
              config2.general.preloadLayers = value;
              onChange();
            }
          }
        ),
        /* @__PURE__ */ BdApi.React.createElement(
          FormSwitch,
          {
            className: DiscordClasses.Margins.marginBottom20,
            children: Messages.CACHE_USER_SETTINGS_SECTIONS,
            note: "Significantly improves performance when opening User Settings.",
            value: config2.general.cacheUserSettingsSections,
            onChange: (value) => {
              config2.general.cacheUserSettingsSections = value;
              onChange();
            }
          }
        )
      ),
      /* @__PURE__ */ BdApi.React.createElement(
        FormSection,
        {
          tag: FormTitleTags.H2,
          title: "Behavior",
          className: DiscordClasses.Margins.marginTop20,
          titleClassName: DiscordClasses.Margins.marginBottom8
        },
        /* @__PURE__ */ BdApi.React.createElement(FormItem, { className: DiscordClasses.Margins.marginBottom20 }, /* @__PURE__ */ BdApi.React.createElement(FormTitle, { className: DiscordClasses.Margins.marginBottom8 }, "Switch Cooldown Duration"), /* @__PURE__ */ BdApi.React.createElement(FormText, { className: DiscordClasses.Margins.marginBottom20 }, "If switch animations overlap, they cancel each other and trigger a cooldown preventing new switch animations from playing for a period of time."), /* @__PURE__ */ BdApi.React.createElement(
          DurationSlider,
          {
            from: 100,
            to: 2e3,
            defaultValue: configDefaults.general.switchCooldownDuration,
            initialValue: config2.general.switchCooldownDuration,
            onValueChange: (value) => {
              config2.general.switchCooldownDuration = value;
              onChange();
            }
          }
        ))
      )
    ));
  }
  function BetterDiscordIcon({ size, width, height, color = colors.INTERACTIVE_NORMAL }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      "svg",
      {
        ...useIconSize(size, { width, height }),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "-2 -2 28 28"
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "path",
        {
          fill: typeof color === "string" ? color : color.css,
          d: "M14.393.861q.514.258.964.57a6.6 6.6 0 0 1 2.122 2.387c.513.987.792 2.133.828 3.409v9.556c-.035 1.275-.313 2.422-.828 3.408a6.6 6.6 0 0 1-2.122 2.387a8 8 0 0 1-.933.555h.933c4.46.024 8.643-2.205 8.643-7.315V8.352c.024-5.21-4.16-7.49-8.62-7.49zM0 .867v9.197l5.693 5.127V5.44h3.31c3.537 0 3.537 4.444 0 4.444H6.817v4.244h2.188c3.536 0 3.536 4.441 0 4.441H0v4.57h8.904c4.59 0 8.151-1.836 8.278-6.388c0-2.094-.574-3.66-1.584-4.748c1.01-1.087 1.584-2.652 1.584-4.746c-.125-4.553-3.687-6.39-8.278-6.39z"
        }
      )
    );
  }
  function SocialLinks() {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__socialLinks" }, /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        tooltip: "Donate",
        onClick: () => handleClick({ href: meta$1.donate })
      },
      /* @__PURE__ */ BdApi.React.createElement(CircleDollarSignIcon, { size: "sm", color: "currentColor" })
    ), /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        tooltip: "Support Server",
        onClick: () => UI.showInviteModal(meta$1.invite)
      },
      /* @__PURE__ */ BdApi.React.createElement(CircleQuestionIcon, { size: "sm", color: "currentColor" })
    ), /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        tooltip: "GitHub",
        onClick: () => handleClick({ href: meta$1.source })
      },
      /* @__PURE__ */ BdApi.React.createElement(GitHubIcon, { size: "sm", color: "currentColor" })
    ), /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        tooltip: "BetterDiscord",
        onClick: () => handleClick({ href: "https://betterdiscord.app/plugin/BetterAnimations" })
      },
      /* @__PURE__ */ BdApi.React.createElement(BetterDiscordIcon, { size: "sm", color: "currentColor" })
    ), /* @__PURE__ */ BdApi.React.createElement(
      IconButton,
      {
        tooltip: "Documentation",
        onClick: () => handleClick({ href: Documentation.homeUrl }),
        style: { margin: "0 -2px" }
      },
      /* @__PURE__ */ BdApi.React.createElement(BookIcon, { size: "sm", color: "currentColor" })
    ));
  }
  css`.BA__socialLinks {
    display: flex;
    align-items: center;
    gap: 8px;
}``SocialLinks`;
  function SystemInfo() {
    const data2 = require$$0$1.useMemo(() => [
      `${meta$1.name} ${meta$1.version}`,
      `BetterDiscord ${bdVersion}`
    ], []);
    return /* @__PURE__ */ BdApi.React.createElement(
      CopiableField,
      {
        text: "Click to copy",
        copyValue: data2.join("\n")
      },
      (props) => /* @__PURE__ */ BdApi.React.createElement(
        Clickable,
        {
          ...props,
          tag: "div",
          className: "BA__settingsSidebarFooterSystemInfo"
        },
        data2.map((text2, i) => /* @__PURE__ */ BdApi.React.createElement(
          Text$1,
          {
            key: i,
            variant: "text-xs/normal",
            color: "text-muted"
          },
          text2
        ))
      )
    );
  }
  function SettingsSidebarFooter() {
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__settingsSidebarFooter" }, /* @__PURE__ */ BdApi.React.createElement(SocialLinks, null), /* @__PURE__ */ BdApi.React.createElement(SystemInfo, null));
  }
  css`.BA__settingsSidebarFooter {
    padding: 8px 10px;
}
.BA__settingsSidebarFooterSystemInfo {
    margin-top: 16px;
    cursor: pointer;
}``SidebarFooter`;
  function useSections() {
    const registry = usePackRegistry();
    const hasIssues = registry.verifier.hasIssues();
    const hasOutdatedPacks = registry.hasOutdatedPacks();
    return require$$0$1.useMemo(() => {
      const notice = {
        element: FormNotice,
        stores: [SettingsStore]
      };
      return [
        {
          section: "CUSTOM",
          element: ErrorBoundary.wrap(SettingsSidebarHeader, { noop: true })
        },
        {
          section: SettingsSection.Home,
          label: "Home",
          icon: /* @__PURE__ */ BdApi.React.createElement(HomeIcon, { size: "xs", color: "currentColor" }),
          element: ErrorBoundary.wrap(Home)
        },
        {
          section: "DIVIDER"
        },
        {
          section: SettingsSection.Catalog,
          label: "Catalog",
          icon: /* @__PURE__ */ BdApi.React.createElement(ShopIcon, { size: "xs", color: "currentColor" }),
          element: ErrorBoundary.wrap(Catalog)
        },
        {
          section: SettingsSection.Library,
          label: "Library",
          icon: hasIssues ? /* @__PURE__ */ BdApi.React.createElement(CircleWarningIcon, { size: "xs", color: colors.STATUS_DANGER }) : hasOutdatedPacks ? /* @__PURE__ */ BdApi.React.createElement(DownloadIcon, { size: "xs", color: "var(--brand-400)" }) : /* @__PURE__ */ BdApi.React.createElement(LibraryIcon, { size: "xs", color: "currentColor" }),
          element: ErrorBoundary.wrap(Library)
        },
        {
          section: "DIVIDER"
        },
        {
          section: "CUSTOM",
          element: ErrorBoundary.wrap(ModeSwitch, { noop: true })
        },
        ...Core.getAllModules(true).map((module2) => ({
          section: module2.id,
          label: module2.name,
          className: module2.parent ? "BA__nestedTabBarItem" : void 0,
          icon: module2.parent ? /* @__PURE__ */ BdApi.React.createElement(SpineIcon, null) : void 0,
          elementProps: { moduleId: module2.id },
          element: ErrorBoundary.wrap(ModuleSettings),
          notice
        })),
        {
          section: "DIVIDER"
        },
        {
          section: SettingsSection.General,
          label: "General",
          icon: /* @__PURE__ */ BdApi.React.createElement(SettingsIcon, { size: "xs", color: "currentColor" }),
          element: ErrorBoundary.wrap(GeneralSettings),
          notice
        },
        {
          section: "DIVIDER"
        },
        {
          section: "CUSTOM",
          element: ErrorBoundary.wrap(SettingsSidebarFooter, { noop: true })
        }
      ];
    }, [hasIssues, hasOutdatedPacks]);
  }
  const DiscordSelectors = new Proxy(DiscordClasses, {
    get(obj, prop) {
      return obj[prop] && new Proxy(obj[prop], {
        get(obj2, prop2) {
          return obj2[prop2]?.split(" ").filter((i) => !!i).map((c) => "." + c).join("");
        }
      });
    }
  });
  const StandardSidebarViewComponent = require$$0$1.lazy(async () => ({ default: await StandardSidebarViewWrapper }));
  function SettingsModal() {
    const theme = useStateFromStores([ThemeStore], () => ThemeStore.theme);
    const title = `${meta$1.name} Settings`;
    const sections = useSections();
    const [section2, setSection2] = useSection();
    const onClose = require$$0$1.useCallback(() => LayerActions.popLayer(), []);
    const actions = (actions2) => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, actions2, /* @__PURE__ */ BdApi.React.createElement(
      Button$1,
      {
        variant: "secondary",
        size: "sm",
        text: "Close Settings",
        onClick: onClose
      }
    ));
    require$$0$1.useEffect(() => () => PackRegistry.storage.clear(), []);
    return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { style: { margin: "auto" }, actions }, /* @__PURE__ */ BdApi.React.createElement(SectionContext, { value: { section: section2, setSection: setSection2 } }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__settingsModal" }, /* @__PURE__ */ BdApi.React.createElement(require$$0$1.Suspense, null, /* @__PURE__ */ BdApi.React.createElement(
      StandardSidebarViewComponent,
      {
        title,
        theme,
        sidebarTheme: theme,
        sections,
        section: section2,
        onSetSection: setSection2,
        onClose
      }
    )))));
  }
  StandardSidebarViewKeyed.then(
    () => css`.BA__settingsModal {
    position: absolute;
    inset: 0;
}
.BA__settingsModal ${DiscordSelectors.StandardSidebarView.noticeRegion} {
    padding-left: 40px;
    padding-right: 40px;
    z-index: 200;
}

${DiscordSelectors.StandardSidebarView.contentColumnDefault}:has(> .BA__moduleSettingsContainer) {
    position: static;
}

.BA__nestedTabBarItem {
    position: relative;
    margin-left: 30px;
    overflow: visible;
}
.BA__nestedTabBarItem svg {
    position: absolute;
    left: -14px;
    bottom: calc(50% - 1px);
    color: var(--interactive-muted);
}``SettingsModal`
  );
  const Settings = new class Settings {
    isSettingsModalOpen() {
      return !!LayerStore$1.getLayers().at(-1)?.__BA_isSettingsModal;
    }
    openSettingsModal(section2 = SettingsSection.Home) {
      if (this.isSettingsModalOpen()) return;
      if (!LayerStore$1.getLayers().includes("USER_SETTINGS"))
        UserSettingsModal.open("plugins");
      setSection(section2);
      const component = () => /* @__PURE__ */ BdApi.React.createElement(SettingsModal, null);
      component.__BA_isSettingsModal = true;
      LayerActions.pushLayer(component);
    }
    closeSettingsModal() {
      if (this.isSettingsModalOpen())
        LayerActions.popLayer();
    }
  }();
  const avatarPlaceholder = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAAhFBMVEV1fop9hpGgpq+ytr2prraXnqfT19vu7/H////29/iGjpju7/DCxszc3+K6vsS6v8WOlqD39/fLztPLz9OPlqDl5+nDx8ygpq6xtr6xtr3m5+iOlp/Dxsvc3+Hd3+GorraGjpnT19rT1tv29/eOlqHU19p+hpGprrWxt72or7bLz9Kfpq+ibmTzAAAEY0lEQVR4AezBAQEAAAQAIPB/swkMqAIAAAAAAAAAAAAAAAAAAAAAgBNZPfFWy86dLimOw3AAV5qYEXFicMKxHIFs03e///PtvaouagjRGMKfNr/vmhorsiMbpwcm+UZjN4PhD2YedR5TZpnZDgfmOww+L/h/jjoaS0iRG7pdk0HBQlECmeevisGEbpDJf7DQlUDJh2xlbm30noWmBGQFuOUcTMeej3CqFeCQzTOCl8i8bymBbPKQDlxeCecGqTH/Dc/ycUVK0LKx51ZVXs08H+WLoSu5la0yQmUK7sXQEKQ592ZOgFLukSE4meUe2YTQlCyinARTFnFOAss9swRlzL1zBCTj/o2ySFdAURCMBV+FiXQFFLP4esADvxGExPKVjJJIX4HCxbcJACyBkq/IxdkDQZVAyVfl4i4AgBIo+cpcvK8AiBJYMsddApY56hJIGcCSrmfFAAq6GsMQTKTvQDEEaILiXAZTBuEAlsAYl8E1wzCRLoEij7QLFKNYmwBhIp0BIo9tBgDMAcMc9xzYMJQcugvytl55VtCHWNx9wHaZ0d+mO6sP6Z7mBnQfYA2R2Fl1yMKCHov8zp3kycHKoQ9x3Mkj9Wv/i9s0FxCC9CJca8cv3JlDxBPecfgz/cwzt9j+etO5hFsCbEM/89I2e/QhoqI+2YBzGnfWEGHRuoBRQ6R9nu0hQJ3AIqgkNwEhLR6oPy7o/2MCQwC2AwWfltAxL/oifgFrhfZhtxitvpexAKug7nnU+gKqw2sO6DDk8bwJKKF6wZRPq8IToO28XqkvDnMK5FiNMB1n9SErqGZ4xeGvQV0IYV2f34ed05qgEIAjgZfAc9oyIATiPbgOvLZgA0IgtkMm7NpCGhCC8evIgkNKILHqEJIQjEZgGfR971wfMmasBLiQj5regkLaObifBd/p0Ls+xHBXOd7NgLH+YepDRIWXAK4yIpE9B4QAJaBgjcq0/3Wl8BDxiJUA4Yuqqob+YiGi7i0BiO4JuCfgnoB7Au4J6ME9AfcE3BNQMqjqnoAYrgkDnAc4BuWoH0sGtUS6J7xdWj4bu5wBHIqqL+yYZz6Lrek47wzOL0M7+kfjLAfyLpGJB3NDYrfnE2wq5VLagNF/GJl3nk/wS+pNM+PuKZAc6EefKP5m87ahPjnWpICMq1lllRsSpmCYxy8aq0sBJcbVnjvw23yR0OHwcR6/cPsuKcjoq+kir1d8lH3O0yl9lYw9oz1+0ZSqQ34SU5O6/KOuV/Zfdf3x4dJFltAB8+wZ9PErvoKqL7vxtp90TY5Pmlyy5ZI2QcDNg+qSZy9VQ9fX1Je7uDM91SNjMPZie/QN9vDFrtZ8OaXwsgcfvjB1y64owBJp+PrlsLrIGfSzIUzN4a7HNxSs2cO8+PSLwfLsJ3Dbh4QEfBlsz/xDjHcTQicHAPIGONck8LJBvpkc7OhMduxzk9CtmUL+U3+2BwcyAAAAAIP8re/xVQAAAAAAAAAAAAAAAAAAAAAAKwFiKavpSRGzHgAAAABJRU5ErkJggg==";
  function ResolveMethodSelector({ size = "sm", pack, method, setMethod, disabled = false }) {
    const selectedMethod = verificationIssueResolveMethods[method];
    const children2 = selectedMethod ? /* @__PURE__ */ BdApi.React.createElement(
      VerificationIssueSelection,
      {
        ...selectedMethod,
        size,
        onUndo: () => setMethod(null)
      }
    ) : /* @__PURE__ */ BdApi.React.createElement(
      VerificationIssueActions,
      {
        pack,
        onSelect: (method2) => setMethod(method2.value),
        size,
        direction: "horizontal-reverse",
        disabled
      }
    );
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__verificationIssueActions" }, children2);
  }
  function VerificationIssue({ pack, method, setMethod, disabled }) {
    const status = require$$0$1.useMemo(
      () => verificationStatuses[pack.verificationStatus],
      [pack.verificationStatus]
    );
    return /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__verificationIssue" }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__verificationIssueInfo" }, /* @__PURE__ */ BdApi.React.createElement(
      PackHeader,
      {
        pack,
        popoutType: "tooltip",
        size: "sm",
        icon: method != null ? /* @__PURE__ */ BdApi.React.createElement(
          CheckIcon,
          {
            size: "sm",
            color: colors.STATUS_POSITIVE
          }
        ) : void 0
      }
    ), /* @__PURE__ */ BdApi.React.createElement(
      ResolveMethodSelector,
      {
        pack,
        method,
        setMethod,
        disabled
      }
    )), method == null && status?.description && /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        className: "BA__verificationIssueDescription",
        variant: "text-sm/normal"
      },
      status.description
    ));
  }
  function VerificationIssuesModal({ onClose, ...props }) {
    const registry = usePackRegistry();
    const loading = registry.hasPending;
    const issues = registry.verifier.getIssues();
    const [selectedMethods, setSelectedMethods] = require$$0$1.useState({});
    require$$0$1.useEffect(() => {
      if (!issues.length) onClose?.();
    }, [issues.length]);
    const resolvers = issues.filter((pack) => selectedMethods[pack.id] != null).map((pack) => ({ pack, method: selectedMethods[pack.id] }));
    const confirmText = require$$0$1.useMemo(() => {
      if (!resolvers.length) return "Resolve issues";
      if (resolvers.length < issues.length) return `Resolve ${resolvers.length} out of ${issues.length} issues`;
      return "Resolve all issues";
    }, [resolvers.length, issues.length]);
    const onConfirm = async (preventClose) => {
      preventClose();
      if (await registry.verifier.resolveIssues(resolvers)) onClose();
    };
    return /* @__PURE__ */ BdApi.React.createElement(
      Modal$2,
      {
        ...props,
        onClose,
        size: ModalSize.MEDIUM,
        title: "Resolve issues",
        cancelText: "Cancel",
        confirmText,
        confirmButtonVariant: "primary",
        loading,
        disabled: !resolvers.length || loading,
        onConfirm
      },
      /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, null, registry.hasError && /* @__PURE__ */ BdApi.React.createElement(Alert, { messageType: AlertTypes.ERROR }, Messages.CATALOG_OUT_OF_DATE), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__verificationIssuesList" }, issues.map((pack) => /* @__PURE__ */ BdApi.React.createElement(
        VerificationIssue,
        {
          key: pack.filename,
          pack,
          method: selectedMethods[pack.id],
          setMethod: (method) => setSelectedMethods((prev) => ({ ...prev, [pack.id]: method })),
          disabled: loading
        }
      ))))
    );
  }
  css`.BA__verificationIssue {
    padding: 16px 0;
    border-bottom: 1px solid var(--border-subtle);
}
.BA__verificationIssueInfo {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 16px;
}
.BA__verificationIssueActions {
    display: flex;
    flex-direction: row-reverse;
    align-items: center;
    gap: 8px;
    flex-shrink: 0;
}
.BA__verificationIssueDescription {
    margin-top: 12px;
}``VerificationIssuesModal`;
  class PackVerifier {
    constructor(registry) {
      this.registry = registry;
      this.temporaryWhitelist = /* @__PURE__ */ new Set();
    }
    get permanentWhitelist() {
      return data.library.whitelist;
    }
    get whitelist() {
      return this.permanentWhitelist.union(this.temporaryWhitelist);
    }
    addToWhitelist(pack, permanent = false) {
      if (permanent) this.permanentWhitelist.add(pack.filename);
      else this.temporaryWhitelist.add(pack.filename);
      Emitter.emit(Events.PackUpdated, pack);
      return true;
    }
    removeFromWhitelist(pack) {
      this.temporaryWhitelist.delete(pack.filename);
      this.permanentWhitelist.delete(pack.filename);
      Emitter.emit(Events.PackUpdated, pack);
      return true;
    }
    check(pack) {
      return this.whitelist.has(pack.filename) || [VerificationStatus.VERIFIED, VerificationStatus.OFFICIAL].includes(pack.verificationStatus);
    }
    getResolveMethod(pack) {
      if (this.permanentWhitelist.has(pack.filename)) return VerificationIssueResolveMethod.ALLOW_ALWAYS;
      if (this.temporaryWhitelist.has(pack.filename)) return VerificationIssueResolveMethod.ALLOW_ONCE;
      return null;
    }
    _verify(pack) {
      if (!this.registry.isReady) return VerificationStatus.UNKNOWN;
      const publishedPack = this.registry.getPack(pack.filename);
      if (!publishedPack) return VerificationStatus.UNVERIFIED;
      if (pack.hash !== (publishedPack.history?.[pack.version] ?? publishedPack).hash)
        return VerificationStatus.FAILED;
      return publishedPack.official ? VerificationStatus.OFFICIAL : VerificationStatus.VERIFIED;
    }
    verify(pack) {
      const status = this._verify(pack);
      const didChange = status !== pack.verificationStatus;
      const hasFailed = didChange && !this.check({ ...pack, verificationStatus: status });
      if (didChange) {
        pack.verificationStatus = status;
        Emitter.emit(Events.PackUpdated, pack);
      }
      return hasFailed;
    }
    verifyAll(packs = PackManager.getAllPacks(true)) {
      const hasFailed = packs.map((pack) => this.verify(pack)).some(Boolean);
      if (hasFailed) this.showModal();
      return hasFailed;
    }
    getIssues(packs = PackManager.getAllPacks(true)) {
      return packs.filter((pack) => !this.check(pack));
    }
    hasIssues(packs = PackManager.getAllPacks(true)) {
      return packs.some((pack) => !this.check(pack));
    }
    showModal() {
      if (!this.hasIssues()) return;
      ModalActions.openModal(
        (props) => /* @__PURE__ */ BdApi.React.createElement(VerificationIssuesModal, { ...props }),
        { modalKey: "BA__verificationIssuesModal" }
      );
    }
    resolveIssue({ pack, method }) {
      switch (method) {
        case VerificationIssueResolveMethod.DELETE:
        case VerificationIssueResolveMethod.UNINSTALL:
          return this.registry.delete(pack.filename);
        case VerificationIssueResolveMethod.REINSTALL:
          return this.registry.reinstall(pack.filename);
        case VerificationIssueResolveMethod.UPDATE:
          return this.registry.update(pack.filename);
        case VerificationIssueResolveMethod.ALLOW_ONCE:
          return this.addToWhitelist(pack, false);
        case VerificationIssueResolveMethod.ALLOW_ALWAYS:
          return this.addToWhitelist(pack, true);
        default:
          return false;
      }
    }
    async resolveIssues(resolvers) {
      const results = await Promise.all(
        resolvers.map((resolver) => this.resolveIssue(resolver))
      );
      return results.every(Boolean);
    }
  }
  class PackRegistryStorage {
    get name() {
      return "PackRegistryStorage";
    }
    constructor(registry) {
      this.registry = registry;
      this._storage = /* @__PURE__ */ new Map();
    }
    async _load(filename) {
      try {
        return PackSchema.parse(
          await this.registry.fetch(filename)
        );
      } catch (error2) {
        Logger.error(this.name, `Failed to load "${filename}":`, error2);
        this._storage.delete(filename);
        throw error2;
      }
    }
    load(filename) {
      const promise = this._load(filename);
      this._storage.set(filename, promise);
      return promise;
    }
    get(filename) {
      return this._storage.get(filename) ?? this.load(filename);
    }
    clear() {
      this._storage.clear();
    }
    use(filename = null) {
      const [pack, setPack] = require$$0$1.useState(null);
      const [loading, setLoading] = require$$0$1.useState(true);
      const [error2, setError] = require$$0$1.useState(null);
      require$$0$1.useEffect(() => {
        if (filename == null) {
          setPack(null);
          setLoading(false);
          setError(null);
          return;
        }
        let ignore = false;
        setLoading(true);
        this.get(filename).then((pack2) => ignore || setPack(pack2)).catch((error22) => ignore || setError(error22)).finally(() => ignore || setLoading(false));
        return () => ignore = true;
      }, [filename]);
      return { pack, loading, error: error2 };
    }
  }
  const PackRegistry = new class PackRegistry {
    get name() {
      return "PackRegistry";
    }
    get baseUrl() {
      return "https://gist.githubusercontent.com/arg0NNY/c0200ac6bc1665a91df8bd3c0eb46749";
    }
    get mainFilename() {
      return "Better-Animations-Pack-Registry.json";
    }
    get data() {
      return data.catalog;
    }
    get cache() {
      return this.data.cache;
    }
    set cache(value) {
      this.data.cache = value;
    }
    get hasCache() {
      return this.cache != null;
    }
    constructor() {
      this.verifier = new PackVerifier(this);
      this.storage = new PackRegistryStorage(this);
      this._pending = /* @__PURE__ */ new Set();
      this._error = null;
      this._items = this.cache?.items ?? [];
      this._authors = this.cache?.authors ?? [];
      this._closeNotice = null;
      this._schedulerCallbackId = null;
      this.onPackLoaded = (pack) => {
        this.verifier.verifyAll([pack]);
        this.scheduleCheckForUpdates({ updateRegistry: false });
      };
      this.onPackUnloaded = (pack) => {
        this.verifier.temporaryWhitelist.delete(pack.filename);
      };
    }
    isPending(filename = this.mainFilename) {
      return this._pending.has(filename);
    }
    get hasPending() {
      return this._pending.size > 0;
    }
    get error() {
      return this._error;
    }
    set error(value) {
      this._error = value;
      this.onChange();
    }
    get hasError() {
      return this.error != null;
    }
    get isFatal() {
      return this.hasError && !this.hasCache;
    }
    get isReady() {
      return !this.isPending() || this.hasCache;
    }
    get items() {
      return this._items.map((item) => ({
        ...item,
        verificationStatus: item.official ? VerificationStatus.OFFICIAL : VerificationStatus.VERIFIED,
        installed: PackManager.getPackByFile(item.filename, true)
      }));
    }
    set items(value) {
      this._items = value;
      this.onChange();
    }
    get authors() {
      return this._authors;
    }
    set authors(value) {
      this._authors = value;
      this.onChange();
    }
    onChange() {
      Emitter.emit(Events.PackRegistryUpdated);
    }
    initialize() {
      this.listenPackEvents();
      this.checkForUpdates();
      Logger.info(this.name, "Initialized.");
    }
    hasPack(filename) {
      return this.items.some((item) => item.filename === filename);
    }
    getPack(filename) {
      return this.items.find((item) => item.filename === filename);
    }
    getAuthor(username) {
      return this.authors.find((author2) => author2.username === username);
    }
    getSourceURL(filename) {
      return `${this.baseUrl}/raw/${filename}`;
    }
    async fetch(filename, parse2 = true, options = {}) {
      const response = await Net.fetch(`${this.getSourceURL(filename)}?${Date.now()}`, options);
      if (!response.ok) throw response;
      return parse2 ? response.json() : response.text();
    }
    async load(filename, parse2, options) {
      this._pending.add(filename);
      this.onChange();
      try {
        return await this.fetch(filename, parse2, options);
      } finally {
        this._pending.delete(filename);
        this.onChange();
      }
    }
    async updateRegistry(options) {
      this.error = null;
      Logger.info(this.name, "Updating registry...");
      try {
        const data2 = await this.load(this.mainFilename, options);
        this.cache = data2;
        this.items = data2.items;
        this.authors = data2.authors;
        Logger.info(this.name, `Loaded ${this.items.length} packs.`);
        return true;
      } catch (error2) {
        this.error = error2;
        Logger.error(this.name, "Failed to update registry:", error2);
        return false;
      } finally {
        this.storage.clear();
        this.verifier.verifyAll();
      }
    }
    async install(filename, options = {}, action = "install") {
      try {
        PackManager.saveAddon(filename, await this.load(filename, false, options));
        return true;
      } catch (error2) {
        Logger.error(this.name, `Failed to ${action} "${filename}":`, error2);
        Toasts.error(`Failed to ${action} "${filename}".`);
        return false;
      }
    }
    update(filename, options) {
      return this.install(filename, "update", options);
    }
    reinstall(filename, options) {
      return this.install(filename, "reinstall", options);
    }
    delete(filename) {
      try {
        PackManager.deleteAddon(filename);
        return true;
      } catch (error2) {
        Logger.error(this.name, `Failed to delete "${filename}":`, error2);
        Toasts.error(`Failed to delete "${filename}".`);
        return false;
      }
    }
    hasUpdate(pack) {
      const latest = this.getPack(pack.filename);
      if (!latest) return false;
      try {
        return Utils.semverCompare(pack.version, latest.version) > 0;
      } catch (error2) {
        Logger.warn(this.name, `Failed to compare versions for "${pack.filename}":`, error2);
        return regex.semver.test(latest.version);
      }
    }
    getOutdatedPacks() {
      return PackManager.getAllPacks(true).filter((pack) => this.hasUpdate(pack));
    }
    hasOutdatedPacks() {
      return PackManager.getAllPacks(true).some((pack) => this.hasUpdate(pack));
    }
    showUpdatesNotice(updatesCount = this.getUpdatesCount()) {
      this._closeNotice?.();
      this._closeNotice = Notices.info(`${meta$1.name} has found updates for ${updatesCount} of your packs!`, {
        buttons: [{
          label: "View Library",
          onClick: () => {
            this._closeNotice?.();
            data.library.sort = "default";
            Settings.openSettingsModal(SettingsSection.Library);
          }
        }]
      });
    }
    async checkForUpdates(options = {}) {
      const { useToasts = false, updateRegistry = true } = options;
      Logger.info(this.name, "Checking for updates...");
      if (updateRegistry) {
        const success = await this.updateRegistry();
        if (!success) {
          if (useToasts) Toasts.error("Unable to check for updates. Please try again later.");
          return;
        }
      }
      const updatesCount = this.getOutdatedPacks().length;
      if (!updatesCount) {
        Logger.info(this.name, "No updates found.");
        if (useToasts) Toasts.success("Everything is up to date!");
        return;
      }
      Logger.info(this.name, `Found ${updatesCount} updates.`);
      if (useToasts) return Toasts.show(`Found updates for ${updatesCount} of your packs!`);
      this.showUpdatesNotice(updatesCount);
    }
    scheduleCheckForUpdates(options) {
      cancelIdleCallback(this._schedulerCallbackId);
      this._schedulerCallbackId = requestIdleCallback(() => this.checkForUpdates(options));
    }
    async updateAll() {
      const packs = this.getOutdatedPacks();
      const results = await Promise.all(
        packs.map((pack) => this.update(pack.filename))
      );
      Logger.info(this.name, `Updated ${packs.length} packs.`);
      if (results.every(Boolean)) {
        Toasts.success("Everything is up to date!");
        this._closeNotice?.();
      }
    }
    getThumbnailSrc(pack) {
      return pack.thumbnailSrc ?? this.getPack(pack.filename)?.thumbnailSrc;
    }
    getAuthorAvatarSrc(pack) {
      const publishedPack = this.getPack(pack.filename);
      if (!publishedPack) return avatarPlaceholder;
      const author2 = this.getAuthor(pack.author);
      if (!author2) return avatarPlaceholder;
      return `https://avatars.githubusercontent.com/u/${author2.githubId}?s=60&v=4`;
    }
    isUnknown(pack) {
      return this.data.visited && !this.data.known.has(pack.filename);
    }
    markAsKnown(pack) {
      if (!this.isUnknown(pack)) return;
      this.data.known.add(pack.filename);
    }
    getUnknownPacks() {
      return this.items.filter((pack) => this.isUnknown(pack));
    }
    listenPackEvents() {
      Emitter.on(Events.PackLoaded, this.onPackLoaded);
      Emitter.on(Events.PackUnloaded, this.onPackUnloaded);
    }
    unlistenPackEvents() {
      Emitter.off(Events.PackLoaded, this.onPackLoaded);
      Emitter.off(Events.PackUnloaded, this.onPackUnloaded);
    }
    shutdown() {
      this.unlistenPackEvents();
      this.storage.clear();
      Logger.info(this.name, "Shutdown.");
    }
  }();
  const PackManager = new class PackManager extends AddonManager {
    get name() {
      return "PackManager";
    }
    get extension() {
      return ".pack.json";
    }
    get duplicatePattern() {
      return /\.pack\s?\([0-9]+\)\.json/;
    }
    get addonFolder() {
      return path.resolve(Plugins.folder, meta$1.name);
    }
    get prefix() {
      return "pack";
    }
    get language() {
      return "json";
    }
    get forbiddenSlugs() {
      return internalPackSlugs;
    }
    /* Aliases */
    updatePackList() {
      return this.updateList();
    }
    loadAllPacks() {
      return this.loadAllAddons();
    }
    unloadPack(idOrFileOrAddon) {
      return this.unloadAddon(idOrFileOrAddon);
    }
    loadPack(filename) {
      return this.loadAddon(filename);
    }
    reloadPack(idOrFileOrAddon) {
      return this.reloadAddon(idOrFileOrAddon);
    }
    loadAddon(filename, shouldToast = true) {
      const error2 = super.loadAddon(filename, shouldToast);
      if (error2) ErrorManager.registerAddonError(error2);
      return error2;
    }
    /* Overrides */
    initializeAddon(addon) {
      try {
        Object.assign(addon, PackSchema.parse(addon));
      } catch (e) {
        Object.assign(
          addon,
          PackFallbackSchema({
            name: addon.slug,
            ...PackRegistry.getPack(addon.filename),
            version: "0.0.0"
          }).parse(addon)
        );
        return new AddonError(
          this.prefix,
          addon,
          formatZodError(e, { pack: addon, received: false, docs: Documentation.getDefinitionUrl(Documentation.Definition.Pack) })
        );
      }
    }
    isRestricted(pack) {
      return pack.partial || !PackRegistry.verifier.check(pack);
    }
    getAllPacks(includeRestricted = false) {
      return this.addonList.filter((p) => includeRestricted || !this.isRestricted(p)).sort((a, b) => a.name.localeCompare(b.name));
    }
    _getPack(predicate, includeRestricted = false) {
      return this.addonList.find(
        (p) => (includeRestricted || !this.isRestricted(p)) && predicate(p)
      );
    }
    getPack(slug2, includeRestricted = false) {
      if (internalPackSlugs.includes(slug2)) return internalPacks[slug2];
      return this._getPack((p) => p.slug === slug2, includeRestricted);
    }
    getPackByFile(filename, includeRestricted = false) {
      return this._getPack((p) => p.filename === filename, includeRestricted);
    }
    showInFolder(filename) {
      DiscordNative.fileManager.showItemInFolder(
        path.resolve(this.addonFolder, filename)
      );
    }
  }();
  function ServerModuleControls({ module: module2 }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      Checkbox,
      {
        value: module2.settings.enhanceLayout,
        onChange: (_, value) => {
          module2.settings.enhanceLayout = value;
          Emitter.emit(Events.ModuleSettingsChanged, module2.id);
        }
      },
      /* @__PURE__ */ BdApi.React.createElement(Flex$1, null, /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-sm/normal" }, "Enhance layout"), /* @__PURE__ */ BdApi.React.createElement(
        Hint,
        {
          className: DiscordClasses.Margins.marginLeft8,
          href: Documentation.enhanceLayoutUrl
        }
      ))
    );
  }
  class Module extends Module$1 {
    get settings() {
      return Config.current.modules[this.id] ??= {};
    }
    getPack(slug2) {
      return PackManager.getPack(slug2);
    }
    getAnimationConfig(pack, animation, type) {
      return Config.pack(pack.slug).getAnimationConfig(animation.key, this.id, type);
    }
    onToggle(value) {
      super.onToggle(value);
      Emitter.emit(Events.ModuleToggled, this.id, value);
    }
    onSettingsChange() {
      super.onSettingsChange();
      Emitter.emit(Events.ModuleSettingsChanged, this.id);
    }
  }
  const moduleOptions = {
    [ModuleKey.Servers]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the transitions when switching between servers and other full-screen pages, such as DMs and Discover. Supports auto-direction for applicable animations determined by the order of elements in the server list."),
      controls: ServerModuleControls
    },
    [ModuleKey.Channels]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the transitions when switching between channels and other pages sharing the same sidebar. Supports auto-direction for applicable animations determined by the order of elements in the sidebar.")
    },
    [ModuleKey.Settings]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the transitions when switching between sections of the settings. Supports auto-direction for applicable animations determined by the order of sections in the navigation sidebar.")
    },
    [ModuleKey.Layers]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the transitions when switching between full-screen views of the Discord app, such as User Settings, Server Settings, ", meta$1.name, " Settings, etc. Supports auto-direction for applicable animations determined by the user’s navigation history across layered views.")
    },
    [ModuleKey.Tooltips]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the appearance and disappearance of informative floating UI elements application-wide, such as various control descriptions, server titles in the server list and other non-interactive elements that provide clarity to Discord's interfaces. Supports auto-position and auto-direction for applicable animations determined by the location of the anchor element.")
    },
    [ModuleKey.Popouts]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the appearance and disappearance of interactive floating UI elements application-wide, such as User Profiles, Select Inputs, Pinned Messages, etc. Supports auto-position and auto-direction for applicable animations determined by the location of the anchor element. Context Menus that have a strictly defined anchor element are controlled by this module.")
    },
    [ModuleKey.ContextMenu]: {
      description: (setSection2) => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the appearance and disappearance of a context menu that is activated by right-clicking on various UI elements. Supports auto-position and auto-direction for applicable animations determined by the location of the pointer. Context Menus that have a strictly defined anchor element, with the exception of context submenus, are controlled by ", /* @__PURE__ */ BdApi.React.createElement(Anchor, { onClick: () => setSection2(ModuleKey.Popouts) }, "Popouts"), ".")
    },
    [ModuleKey.Messages]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the appearance of new messages and the disappearance of deleted messages and other UI elements in the chat. Supports smooth expand and collapse transitions to prevent abrupt layout shifts during dynamic content updates.")
    },
    [ModuleKey.ChannelList]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the appearance and disappearance of channels in the channel list triggered by switching categories, creating or deleting a channel, and other actions that change the contents of the channel list. Supports smooth expand and collapse transitions to prevent abrupt layout shifts during dynamic content updates.")
    },
    [ModuleKey.Modals]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the appearance and disappearance of full-screen modal windows.")
    },
    [ModuleKey.ModalsBackdrop]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the appearance and disappearance of a dimming overlay behind modal windows. Backdrop animations can alter the static styles of the backdrop.")
    },
    [ModuleKey.MembersSidebar]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the appearance and disappearance of sidebars inside the chat area, such as Member List, Message Search Results, etc. Supports smooth expand and collapse transitions to prevent abrupt layout shifts during the switch.")
    },
    [ModuleKey.ThreadSidebar]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the appearance and disappearance of full-screen sidebars, such as Thread Chat, Forum Post Chat, etc. Supports smooth expand and collapse transitions to prevent abrupt layout shifts during the switch.")
    },
    [ModuleKey.ThreadSidebarSwitch]: {
      description: () => /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Animates the transitions when switching between full-screen sidebars, such as between threads or forum posts.")
    }
  };
  const Core = new class Core {
    get name() {
      return "Core";
    }
    constructor() {
      this.modules = modules$1.map(
        (options) => new Module({
          ...options,
          ...moduleOptions[options.id]
        })
      );
      this.globalChangeEvents = [Events.PackLoaded, Events.PackUnloaded, Events.PackUpdated, Events.SettingsChanged];
      this.onGlobalChange = () => this.onChange();
      this.onModuleChange = (id) => this.onChange(id);
    }
    initialize() {
      this.modules.forEach((m) => m.initializeAnimations());
      this.listenEvents();
      Logger.log(this.name, `Initialized ${this.modules.length} animation modules.`);
    }
    shutdown() {
      this.unlistenEvents();
      Logger.log(this.name, "Shutdown.");
    }
    onChange(id = null) {
      if (!id) return this.modules.forEach((m) => m.initializeAnimations());
      this.getModule(id)?.initializeAnimations();
    }
    listenEvents() {
      this.globalChangeEvents.forEach((e) => Emitter.on(e, this.onGlobalChange));
      Emitter.on(Events.ModuleSettingsChanged, this.onModuleChange);
    }
    unlistenEvents() {
      this.globalChangeEvents.forEach((e) => Emitter.off(e, this.onGlobalChange));
      Emitter.off(Events.ModuleSettingsChanged, this.onModuleChange);
    }
    getAllModules(includeNested = false) {
      return this.modules.filter((m) => includeNested || !m.parent);
    }
    getModule(id) {
      return this.modules.find((m) => m.id === id);
    }
    getParentModule(module2) {
      return module2.parent && this.getModule(module2.parent);
    }
    getParentModules(module2, _list = []) {
      const parent = this.getParentModule(module2);
      if (!parent) return _list;
      return this.getParentModules(parent, [parent, ..._list]);
    }
    getChildModules(module2) {
      return this.modules.filter((m) => m.parent === module2.id);
    }
    getModulesUsingPack(pack) {
      return this.getAllModules(true).filter(
        (module2) => Object.values(module2.animations).some((data2) => data2.pack?.filename === pack.filename)
      );
    }
  }();
  function moduleEffectFull(id, callback) {
    const events = [Events.PackLoaded, Events.PackUnloaded, Events.PackEnabled, Events.PackDisabled, Events.PackUpdated, Events.SettingsChanged];
    const moduleEvents = [Events.ModuleToggled, Events.ModuleSettingsChanged];
    const ifSameId = (moduleId) => moduleId === id && callback();
    events.forEach((e) => Emitter.on(e, callback));
    moduleEvents.forEach((e) => Emitter.on(e, ifSameId));
    return () => {
      events.forEach((e) => Emitter.off(e, callback));
      moduleEvents.forEach((e) => Emitter.off(e, ifSameId));
    };
  }
  function moduleEffectToggleOnly(id, callback) {
    const ifSameId = (moduleId) => moduleId === id && callback();
    Emitter.on(Events.ModuleToggled, ifSameId);
    return () => Emitter.off(Events.ModuleToggled, ifSameId);
  }
  function moduleEffect(id, callback, full = false) {
    if (full) return moduleEffectFull(id, callback);
    return moduleEffectToggleOnly(id, callback);
  }
  function injectModule(component, id, full = false) {
    Patcher.after(component?.prototype, "componentDidMount", (self2) => {
      const effects = [].concat(id).map((id2) => moduleEffect(id2, () => self2.forceUpdate(), full));
      self2.__clearModuleEffect = () => effects.forEach((e) => e());
    });
    Patcher.after(component?.prototype, "componentWillUnmount", (self2) => {
      self2.__clearModuleEffect?.();
    });
  }
  function useModule(id, full = false) {
    const update = useUpdate();
    require$$0$1.useEffect(() => moduleEffect(id, update, full), [id]);
    return Core.getModule(id);
  }
  function useSetting(error2) {
    const { config: config2, onChange } = useConfig();
    if (!(error2 instanceof InternalError)) return null;
    switch (error2.category) {
      case InternalError.Category.PRIORITIZE_ANIMATION_SMOOTHNESS:
        return {
          name: Messages.PRIORITIZE_ANIMATION_SMOOTHNESS,
          value: config2.general.prioritizeAnimationSmoothness,
          setValue: (value) => {
            config2.general.prioritizeAnimationSmoothness = value;
            onChange();
          }
        };
      case InternalError.Category.CACHE_USER_SETTINGS_SECTIONS:
        return {
          name: Messages.CACHE_USER_SETTINGS_SECTIONS,
          value: config2.general.cacheUserSettingsSections,
          setValue: (value) => {
            config2.general.cacheUserSettingsSections = value;
            onChange();
          }
        };
      default:
        return null;
    }
  }
  function useActions(error2) {
    const module2 = useModule(error2.module?.id);
    const setting = useSetting(error2);
    const actions = [];
    if (error2 instanceof InternalError) {
      actions.push(
        /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            size: "sm",
            text: "Check for updates",
            onClick: () => {
              UserSettingsModal.open("updates");
              Settings.closeSettingsModal();
              ModalActions.closeAllModals();
            }
          }
        )
      );
      if (setting) actions.push(
        /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            variant: "secondary",
            size: "sm",
            text: `${setting.value ? "Disable" : "Disabled"} ${setting.name}`,
            disabled: !setting.value,
            onClick: () => {
              setting.setValue(false);
              Config.save();
            }
          }
        )
      );
    } else if (module2 && !Settings.isSettingsModalOpen()) actions.push(
      /* @__PURE__ */ BdApi.React.createElement(
        Button$1,
        {
          size: "sm",
          text: "Go to Settings",
          onClick: () => {
            Settings.openSettingsModal(module2.id);
            ModalActions.closeAllModals();
          }
        }
      )
    );
    if (module2) actions.push(
      /* @__PURE__ */ BdApi.React.createElement(
        Button$1,
        {
          variant: "secondary",
          size: "sm",
          text: `${module2.isEnabled() ? "Disable" : "Disabled"} ${error2.module.name} animations`,
          disabled: !module2.isEnabled(),
          onClick: () => {
            module2.setIsEnabled(false);
            Config.save();
          }
        }
      )
    );
    return actions;
  }
  function ErrorDetailsActions({ error: error2, className }) {
    const actions = useActions(error2);
    if (!actions.length) return null;
    return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(FormTitle, null, "Suggested actions"), /* @__PURE__ */ BdApi.React.createElement("div", { className: classNames("BA__errorDetailsActions", className) }, actions));
  }
  const ErrorDetailsActions$1 = require$$0$1.memo(ErrorDetailsActions);
  css`.BA__errorDetailsActions {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 8px;
}``ErrorDetailsActions`;
  function ErrorDetails({ error: error2, open = false }) {
    const icon = require$$0$1.useMemo(() => {
      if (error2 instanceof AnimationError || error2 instanceof AddonError)
        return /* @__PURE__ */ BdApi.React.createElement(JSONIcon, { size: "md" });
      return /* @__PURE__ */ BdApi.React.createElement(IconBrand, { size: "lg", color: colors.INTERACTIVE_NORMAL });
    }, [error2]);
    const title = require$$0$1.useMemo(() => {
      if (error2 instanceof InternalError) return "Internal error";
      if (error2.pack) return error2.pack.name;
      return "Unclassified error";
    }, [error2]);
    const hint = require$$0$1.useMemo(() => {
      if (error2 instanceof InternalError)
        return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, error2.module ? `${error2.module.name} animations` : `Some parts of ${meta$1.name}`, " may not work or function incorrectly.");
      if (error2 instanceof AddonError)
        return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "This pack cannot be loaded due to an unexpected error.");
      if (error2 instanceof AnimationError)
        return /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, 'An unexpected error occurred in the "', error2.animation.name, '" animation on ', error2.module.name, ".");
      return "Unknown error occurred.";
    }, [error2]);
    const code = require$$0$1.useMemo(() => {
      if (error2 instanceof InternalError) return meta$1.invite;
      return error2.pack?.invite;
    }, [error2]);
    const invite2 = useStateFromStores([InviteStore], () => isInviteInvalid(InviteStore.getInvite(code)) ? null : code);
    const alert = require$$0$1.useMemo(() => {
      if (invite2) return "Go to the Support Server to get help with this error:";
      if (error2.pack) return `Reach out to the pack's author${error2.pack.author ? ` (${error2.pack.author})` : ""} to get help with this error.`;
      return null;
    }, [error2, invite2]);
    const content = `${error2.name}: ` + error2.message;
    const codeBlock = attempt(
      () => Parser.codeBlock.react({ content, lang: "json" }, null, {}),
      () => /* @__PURE__ */ BdApi.React.createElement("pre", null, /* @__PURE__ */ BdApi.React.createElement("code", { className: "hljs" }, content))
    );
    return /* @__PURE__ */ BdApi.React.createElement("details", { className: "BA__errorDetails", open }, /* @__PURE__ */ BdApi.React.createElement("summary", { className: "BA__errorDetailsHeader" }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__errorDetailsIcon" }, icon), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__errorDetailsHeaderInner" }, /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        tag: "h3",
        variant: "heading-md/semibold"
      },
      title
    ), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__errorDetailsHeading" }, /* @__PURE__ */ BdApi.React.createElement("svg", { className: "BA__errorDetailsHeadingIcon", "aria-hidden": "false", width: "16", height: "16", viewBox: "0 0 12 12" }, /* @__PURE__ */ BdApi.React.createElement("path", { fill: "currentColor", d: "M6 1C3.243 1 1 3.244 1 6c0 2.758 2.243 5 5 5s5-2.242 5-5c0-2.756-2.243-5-5-5zm0 2.376a.625.625 0 110 1.25.625.625 0 010-1.25zM7.5 8.5h-3v-1h1V6H5V5h1a.5.5 0 01.5.5v2h1v1z" })), /* @__PURE__ */ BdApi.React.createElement(
      Text$1,
      {
        variant: "text-xs/normal",
        color: "header-secondary"
      },
      hint
    ))), /* @__PURE__ */ BdApi.React.createElement("svg", { className: "BA__errorDetailsExpander", width: "24", height: "24", viewBox: "0 0 24 24" }, /* @__PURE__ */ BdApi.React.createElement("path", { fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", d: "M7 10L12 15 17 10", "aria-hidden": "true" }))), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__errorDetailsBody" }, /* @__PURE__ */ BdApi.React.createElement(Divider$2, null), /* @__PURE__ */ BdApi.React.createElement(
      ErrorDetailsActions$1,
      {
        className: DiscordClasses.Margins.marginBottom20,
        error: error2
      }
    ), /* @__PURE__ */ BdApi.React.createElement(FormTitle, null, "Error"), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__errorDetailsStack" }, codeBlock), /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { noop: true }, alert ? /* @__PURE__ */ BdApi.React.createElement(
      Alert,
      {
        messageType: AlertTypes.INFO,
        className: DiscordClasses.Margins.marginTop20
      },
      /* @__PURE__ */ BdApi.React.createElement("div", null, alert),
      invite2 ? /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__errorDetailsInvite" }, /* @__PURE__ */ BdApi.React.createElement(
        InviteEmbed,
        {
          code: invite2,
          message: {
            author: { username: error2.pack?.author }
          },
          getAcceptInviteContext: () => ({})
        }
      )) : null
    ) : null)));
  }
  css`.BA__errorDetails {
    position: relative;
    border-radius: 8px;
    padding: 0;
    background: var(--background-base-lower);
    border: 1px solid var(--border-subtle);
}

.BA__errorDetailsHeader {
    display: flex;
    align-items: center;
    border-radius: 5px;
    padding: 20px 16px;
    cursor: pointer;
    outline: none;
}

.BA__errorDetailsHeader:focus-visible {
    box-shadow: 0 0 0 4px var(--focus-primary);
}

.BA__errorDetailsIcon {
    display: flex;
    align-items: center;
    justify-content: center;
    align-self: flex-start;
    background-color: var(--background-base-lowest);
    width: 48px;
    height: 48px;
    border-radius: 50%;
    margin-right: 10px;
}

.BA__errorDetailsIcon svg {
    fill: var(--interactive-normal);
}

.BA__errorDetailsExpander {
    transform: rotate(-90deg);
    color: var(--interactive-normal);
    transition: transform 0.2s ease;
}

.BA__errorDetails[open] .BA__errorDetailsExpander {
    transform: none;
}

.BA__errorDetailsExpander,
.BA__errorDetailsIcon {
    flex: 0 0 auto;
}

.BA__errorDetailsHeaderInner {
    display: flex;
    flex-direction: column;
    flex: 1 1 auto;
}

.BA__errorDetailsBody {
    padding: 0 16px 24px;
}

.BA__errorDetailsBody .BA__divider {
    margin-bottom: 24px;
}

.BA__errorDetailsHeading {
    display: flex;
    flex-grow: 0;
    justify-content: flex-start;
    margin-top: 4px;
}

.BA__errorDetailsHeadingIcon {
    margin-right: 4px;
    color: var(--interactive-normal);
}

.BA__errorDetailsStack code {
    user-select: text;
    font-size: 0.875rem;
    line-height: 1.125rem;
    text-indent: 0;
    scrollbar-width: thin;
    scrollbar-color: var(--background-base-lowest) var(--background-base-lower);
    background: var(--background-base-lower);
    border: 1px solid var(--background-base-lowest);
}

.BA__errorDetailsStack pre {
    position: relative;
}

.BA__errorDetailsStack pre [class^="codeActions"] {
    position: absolute;
    display: none;
    right: 4px;
    top: 8px;
    color: var(--text-default);
}

.BA__errorDetailsStack pre:hover [class^="codeActions"] {
    display: block;
}

.BA__errorDetailsStack pre [class^="codeActions"] > div {
    cursor: pointer;
}

.BA__errorDetailsInvite {
    margin-top: 8px;
}
.BA__errorDetailsInvite > div {
    max-width: none;
}``ErrorDetails`;
  function ErrorModal({ errors = [], ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      Modal$2,
      {
        title: "Error Inspector",
        size: ModalSize.MEDIUM,
        confirmText: "Dismiss",
        ...props
      },
      /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__errorModalList" }, errors.map((error2) => /* @__PURE__ */ BdApi.React.createElement(ErrorDetails, { error: error2, open: errors.length <= 1 })))
    );
  }
  css`.BA__errorModalList {
    display: flex;
    flex-direction: column;
    gap: 16px;
}``ErrorModal`;
  function ErrorToast({ onView }) {
    useEmitterEffect(Events.ErrorOccurred);
    const count = ErrorManager.errors.length;
    const text2 = count > 1 ? `${count}${ErrorManager.errorsOverload ? "+" : ""} errors occurred.` : "An error occurred.";
    return /* @__PURE__ */ BdApi.React.createElement(Toast, { type: ToastTypes.ERROR, text: text2 }, /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__errorToastButton" }, /* @__PURE__ */ BdApi.React.createElement(
      TextButton,
      {
        className: "BA__errorToastButton",
        text: "View",
        onClick: onView
      }
    )));
  }
  css`.BA__errorToastButton {
    display: flex;
    align-items: center;
    padding: 0 16px;
}``ErrorToast`;
  const ErrorManagerToastSymbol = Symbol("ErrorManagerToast");
  const ErrorManager = new class ErrorManager extends ErrorManager$1 {
    get timeoutDuration() {
      return 1e4;
    }
    get maxErrors() {
      return 20;
    }
    constructor() {
      super();
      this.errors = [];
      this.errorsOverload = false;
      this.timeout = null;
    }
    initialize() {
      this.clear();
      Logger.info(this.name, "Initialized.");
    }
    isToastActive() {
      return useToastStore.getState().currentToastMap.get("APP")?.type === ErrorManagerToastSymbol;
    }
    clear() {
      this.errors = [];
      this.errorsOverload = false;
      clearTimeout(this.timeout);
      this.timeout = null;
      if (this.isToastActive()) popToast("APP", true);
    }
    shouldSuppress(error2) {
      switch (Config.current.general.suppressErrors) {
        case SuppressErrors.All:
          return true;
        case SuppressErrors.Animation:
          return error2 instanceof AnimationError;
        default:
          return false;
      }
    }
    registerError(error2, suppress = false) {
      super.registerError(error2);
      if (suppress || this.shouldSuppress(error2)) return;
      this.errors.unshift(error2);
      if (this.errors.length > this.maxErrors) {
        this.errors = this.errors.slice(0, this.maxErrors);
        this.errorsOverload = true;
      }
      Emitter.emit(Events.ErrorOccurred);
      if (this.isToastActive()) clearTimeout(this.timeout);
      else this.showToast();
      this.timeout = setTimeout(this.clear.bind(this), this.timeoutDuration);
    }
    onView() {
      this.showModal();
      this.clear();
    }
    showToast() {
      useToastStore.setState((state) => ({
        ...state,
        currentToastMap: new Map([
          ...state.currentToastMap,
          ["APP", createToast(null, ErrorManagerToastSymbol, {
            component: /* @__PURE__ */ BdApi.React.createElement(ErrorToast, { onView: this.onView.bind(this) }),
            duration: 0
          })]
        ])
      }));
    }
    showModal(errors = this.errors) {
      if (!errors?.length) return;
      ModalActions.openModal((props) => /* @__PURE__ */ BdApi.React.createElement(
        ErrorModal,
        {
          errors,
          ...props
        }
      ));
    }
    shutdown() {
      this.clear();
      Logger.info(this.name, "Shutdown.");
    }
  }();
  function errorBoundary(callback, fallback = () => {
  }, options = {}) {
    return (...args) => {
      try {
        return callback(...args);
      } catch (error2) {
        ErrorManager.registerInternalError(
          new InternalError(error2.stack, options)
        );
      }
      return fallback(...args);
    };
  }
  function attempt(callback, fallback, options) {
    return errorBoundary(callback, fallback, options)();
  }
  class ErrorBoundary extends require$$0$1.Component {
    static NO_ERROR = {};
    state = { error: ErrorBoundary.NO_ERROR };
    componentDidCatch(error2, errorInfo) {
      this.props.onError?.({ error: error2, errorInfo });
      const internalError = new InternalError(
        error2.stack + errorInfo.componentStack,
        { module: this.props.module }
      );
      this.setState({ error: internalError });
      ErrorManager.registerError(internalError, this.props.silent === true);
    }
    render() {
      const {
        noop: noop2,
        fallback,
        children: children2,
        text: text2 = "An error occurred.",
        actions = (e) => e,
        module: module2,
        ...props
      } = this.props;
      if (this.state.error === ErrorBoundary.NO_ERROR) return children2;
      if (noop2) return null;
      if (fallback !== void 0) return fallback;
      const _actions = /* @__PURE__ */ BdApi.React.createElement(
        Button$1,
        {
          size: "sm",
          text: "View",
          onClick: () => ErrorManager.showModal([this.state.error])
        }
      );
      return /* @__PURE__ */ BdApi.React.createElement(
        ErrorCard,
        {
          ...props,
          text: text2,
          actions: actions?.(_actions)
        }
      );
    }
  }
  ErrorBoundary.wrap = (Component2, boundaryProps) => (props) => /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { ...boundaryProps }, /* @__PURE__ */ BdApi.React.createElement(Component2, { ...props }));
  class BaseTinyPatcher {
    static before(moduleToPatch, functionName, callback) {
      const originalFunction = moduleToPatch[functionName];
      moduleToPatch[functionName] = function(...args) {
        callback(this, args);
        return originalFunction.apply(this, args);
      };
    }
    static after(moduleToPatch, functionName, callback) {
      const originalFunction = moduleToPatch[functionName];
      moduleToPatch[functionName] = function(...args) {
        const value = originalFunction.apply(this, args);
        const returnValue = callback(this, args, value);
        return returnValue !== void 0 ? returnValue : value;
      };
    }
    static instead(moduleToPatch, functionName, callback) {
      const originalFunction = moduleToPatch[functionName];
      moduleToPatch[functionName] = function(...args) {
        return callback(this, args, originalFunction.bind(this));
      };
    }
    static unpatchAll() {
    }
  }
  function getDefaultFallback(type) {
    switch (type) {
      case "after":
        return (self2, args, value) => value;
      case "instead":
        return (self2, args, original) => original.apply(self2, args);
      default:
        return () => void 0;
    }
  }
  class PatcherWrapper {
    constructor(_basePatcher) {
      this._basePatcher = _basePatcher;
    }
    _patch(type, moduleId, moduleToPatch, functionName, callback, options) {
      if (typeof moduleId !== "string") {
        [, moduleToPatch, functionName, callback, options] = arguments;
        moduleId = null;
      }
      const { fallback = getDefaultFallback(type), ...rest } = options ?? {};
      const errorOptions = {
        module: moduleId && Core.getModule(moduleId),
        category: moduleId ? InternalError.Category.MODULE : InternalError.Category.GENERAL,
        ...rest
      };
      return attempt(() => {
        if (typeof moduleToPatch !== "object" || typeof functionName !== "string")
          throw new Error("Module received by Patcher is unresolved or invalid");
        return this._basePatcher[type](
          moduleToPatch,
          functionName,
          errorBoundary(callback, fallback, errorOptions)
        );
      }, () => {
      }, errorOptions);
    }
    before(moduleId, moduleToPatch, functionName, callback, options) {
      return this._patch("before", moduleId, moduleToPatch, functionName, callback, options);
    }
    after(moduleId, moduleToPatch, functionName, callback, options) {
      return this._patch("after", moduleId, moduleToPatch, functionName, callback, options);
    }
    instead(moduleId, moduleToPatch, functionName, callback, options) {
      return this._patch("instead", moduleId, moduleToPatch, functionName, callback, options);
    }
    unpatchAll() {
      return this._basePatcher.unpatchAll();
    }
  }
  const Patcher = new PatcherWrapper(BDPatcher);
  const TinyPatcher = new PatcherWrapper(BaseTinyPatcher);
  function forceAppUpdate() {
    Dispatcher.dispatch({ type: "DOMAIN_MIGRATION_START" });
    requestIdleCallback(() => Dispatcher.dispatch({ type: "DOMAIN_MIGRATION_SKIP" }));
  }
  function usePrevious(value) {
    const ref = require$$0$1.useRef(value);
    require$$0$1.useEffect(() => {
      ref.current = value;
    }, [value]);
    return ref.current;
  }
  function useLocationKey(shouldSwitch, getSwitchDirection = () => 0, location = Router.useLocation()) {
    const prevLocation = usePrevious(location);
    const key2 = require$$0$1.useRef(0);
    let direction = 0;
    if (prevLocation && !Object.is(prevLocation, location) && shouldSwitch(location, prevLocation)) {
      key2.current += 1;
      direction = getSwitchDirection(location, prevLocation);
    }
    return [key2.current, direction];
  }
  function guildActionRowToChannelRoute(guildActionRow) {
    return {
      [GuildActionRow.GUILD_HOME]: StaticChannelRoute.GUILD_HOME,
      [GuildActionRow.GUILD_SCHEDULED_EVENTS]: StaticChannelRoute.GUILD_SCHEDULED_EVENTS,
      [GuildActionRow.GUILD_ROLE_SUBSCRIPTIONS]: StaticChannelRoute.ROLE_SUBSCRIPTIONS,
      [GuildActionRow.GUILD_SHOP]: StaticChannelRoute.GUILD_SHOP,
      [GuildActionRow.CHANNELS_AND_ROLES]: [StaticChannelRoute.CHANNEL_BROWSER, StaticChannelRoute.CUSTOMIZE_COMMUNITY],
      [GuildActionRow.GUILD_MOD_DASH_MEMBER_SAFETY]: StaticChannelRoute.MEMBER_SAFETY,
      [GuildActionRow.GUILD_BOOSTS]: StaticChannelRoute.GUILD_BOOSTS
    }[guildActionRow] ?? guildActionRow;
  }
  function getStaticDMRouteIndex(pathname) {
    return [
      (p) => p === Routes.FRIENDS,
      (p) => p.startsWith(Routes.APPLICATION_LIBRARY),
      (p) => p.startsWith(Routes.MESSAGE_REQUESTS),
      (p) => p.startsWith(Routes.APPLICATION_STORE),
      (p) => p.startsWith(Routes.COLLECTIBLES_SHOP),
      (p) => p.startsWith(Routes.FAMILY_CENTER)
    ].findIndex((c) => c(pathname ?? ""));
  }
  function getSortedGuildTreeIds(node = SortedGuildStore.getGuildsTree().root) {
    if (node.children?.length)
      return node.children.map(getSortedGuildTreeIds).flat();
    return node.id;
  }
  function getSortedGuildChannelIds(guildChannels) {
    return [
      (guildChannels.guildActionSection?.guildActionRows ?? []).map(guildActionRowToChannelRoute),
      guildChannels.getSortedCategories().flatMap(
        (c) => (c.shownChannelIds ?? []).flatMap((id) => [id, ...c.channels[id].threadIds])
      )
    ].flat();
  }
  let currentGuildChannels = null;
  function patchGuildChannelList() {
    Patcher.after(...GuildChannelListKeyed, (self2, args, value) => {
      currentGuildChannels = value.props.guildChannels;
    });
  }
  function matchExact(pathname, path2) {
    return Router.matchPath(pathname, { path: path2, exact: true });
  }
  function matchChannelRoutes(...locations) {
    return locations.map((l) => {
      const channel2 = matchExact(l.pathname, guildChannelPath);
      if (channel2 && !channel2.params.guildId) channel2.params.guildId = "@me";
      return channel2;
    });
  }
  function shouldSwitchContent(next, prev) {
    const [nextChannel, prevChannel] = matchChannelRoutes(next, prev);
    const nextOrPrev = (fn, n = next, p = prev) => fn(n) + fn(p);
    if (nextOrPrev((l) => l.pathname.startsWith(Routes.GLOBAL_DISCOVERY)) === 1 || nextOrPrev((l) => l.pathname.startsWith(Routes.GUILD_MEMBER_VERIFICATION(""))) || nextOrPrev((l) => l.pathname.startsWith(Routes.GUILD_MEMBER_VERIFICATION_FOR_HUB(""))) || nextOrPrev((l) => matchExact(l.pathname, Routes.GUILD_BOOSTING_MARKETING(GuildChannelRouteParams.guildId()))) || nextOrPrev((l) => matchExact(l.pathname, Routes.COLLECTIBLES_SHOP_FULLSCREEN)) || nextOrPrev((l) => l?.params?.channelId === StaticChannelRoute.GUILD_ONBOARDING, nextChannel, prevChannel)) return true;
    if (nextChannel && prevChannel)
      return nextChannel.params.guildId !== prevChannel.params.guildId;
    if (nextChannel || prevChannel)
      return (nextChannel ?? prevChannel).params.guildId !== "@me";
    return false;
  }
  function shouldSwitchPage(next, prev, isContentSwitched = shouldSwitchContent(next, prev)) {
    if (isContentSwitched || next.pathname === prev.pathname) return false;
    const nextOrPrev = (fn, n = next, p = prev) => fn(n) + fn(p);
    if (nextOrPrev((l) => l.pathname.startsWith(Routes.GLOBAL_DISCOVERY)))
      return false;
    const [nextChannel, prevChannel] = matchChannelRoutes(next, prev);
    if (nextChannel && prevChannel && nextChannel.params.channelId === prevChannel.params.channelId)
      return false;
    return true;
  }
  function getSwitchContentDirection(next, prev) {
    const [nextChannel, prevChannel] = matchChannelRoutes(next, prev);
    if (prevChannel?.params.guildId === "@me") return 1;
    if (nextChannel?.params.guildId === "@me") return 0;
    if (prev.pathname.startsWith(Routes.GLOBAL_DISCOVERY)) return 0;
    if (next.pathname.startsWith(Routes.GLOBAL_DISCOVERY)) return 1;
    if (!nextChannel) return 0;
    if (!prevChannel) return 1;
    const sortedGuildIds = getSortedGuildTreeIds();
    const indexOf = (channel2) => sortedGuildIds.indexOf(channel2.params.guildId);
    return +(indexOf(nextChannel) > indexOf(prevChannel));
  }
  function getSwitchPageDirection(next, prev) {
    const [nextChannel, prevChannel] = matchChannelRoutes(next, prev);
    if (nextChannel && prevChannel && nextChannel.params.guildId !== "@me" && nextChannel.params.guildId === prevChannel.params.guildId) {
      const sortedChannelIds = currentGuildChannels ? getSortedGuildChannelIds(currentGuildChannels) : [];
      const indexOf = (channel2) => sortedChannelIds.indexOf(channel2.params.channelId);
      return +(indexOf(nextChannel) > indexOf(prevChannel));
    }
    const [nextDMStaticIndex, prevDMStaticIndex] = [next.pathname, prev.pathname].map(getStaticDMRouteIndex);
    if (nextDMStaticIndex !== -1 && prevDMStaticIndex !== -1)
      return +(nextDMStaticIndex > prevDMStaticIndex);
    if (nextChannel?.params.channelId && prevChannel?.params.channelId) {
      const sortedChannelIds = PrivateChannelSortStore.getPrivateChannelIds();
      const indexOf = (channel2) => sortedChannelIds.indexOf(channel2.params.channelId);
      return +(indexOf(nextChannel) > indexOf(prevChannel));
    }
    if (prevChannel?.params.channelId) return 0;
    if (nextChannel?.params.channelId) return 1;
    return 0;
  }
  const mainWindow = window;
  function useWindow() {
    const { renderWindow } = require$$0$1.use(AppContext);
    return {
      window: renderWindow,
      isMainWindow: renderWindow === mainWindow
    };
  }
  function MainWindowOnly({ children: children2, fallback }) {
    const { isMainWindow } = useWindow();
    return isMainWindow ? typeof children2 === "function" ? children2() : children2 : fallback;
  }
  function getDismissibleKey(theme) {
    return `userPanelMisplacedAlert:${theme.id}`;
  }
  function UserPanelMisplacedAlertModal({ theme, setEnhanceLayout, onClose, ...props }) {
    const themeName = theme.name ?? theme.id;
    const [isDismissed2, setIsDismissed] = useDismissible(getDismissibleKey(theme));
    require$$0$1.useEffect(() => {
      if (isDismissed2) onClose();
    }, [isDismissed2]);
    return /* @__PURE__ */ BdApi.React.createElement(
      Modal$2,
      {
        ...props,
        onClose,
        footer: false
      },
      /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-md/normal" }, /* @__PURE__ */ BdApi.React.createElement("p", null, "User Panel appears to be misplaced."), /* @__PURE__ */ BdApi.React.createElement("p", null, "This may be due to the ", /* @__PURE__ */ BdApi.React.createElement(Anchor, { onClick: () => handleClick({ href: Documentation.enhanceLayoutUrl }) }, /* @__PURE__ */ BdApi.React.createElement("b", null, "Enhance layout")), " option of Servers animations being incompatible with the custom theme ", /* @__PURE__ */ BdApi.React.createElement("b", null, themeName), " you have enabled."), /* @__PURE__ */ BdApi.React.createElement("p", null, /* @__PURE__ */ BdApi.React.createElement(
        ButtonGroup$1,
        {
          direction: "vertical",
          fullWidth: true
        },
        /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            text: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Disable ", /* @__PURE__ */ BdApi.React.createElement("b", null, "Enhance layout")),
            onClick: () => {
              setEnhanceLayout(false);
              onClose();
            }
          }
        ),
        /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            text: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, "Disable ", /* @__PURE__ */ BdApi.React.createElement("b", null, themeName)),
            onClick: () => {
              Themes.disable(theme.id);
              onClose();
            }
          }
        ),
        /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            variant: "secondary",
            text: "How can I make them compatible?",
            onClick: () => handleClick({ href: Documentation.themeCompatibilityUrl })
          }
        )
      ))),
      /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-sm/normal", color: "text-muted" }, /* @__PURE__ */ BdApi.React.createElement(Anchor, { onClick: () => setIsDismissed(true) }, "Hide this notification"), " if you believe that it has been shown to you by mistake.")
    );
  }
  UserPanelMisplacedAlertModal.key = "BA__userPanelMisplacedAlert";
  function patchAppPanels() {
    Patcher.after(ModuleKey.Servers, AppPanels, "type", (self2, args, value) => {
      const [isCooldown, setIsCooldown] = require$$0$1.useState(false);
      const isModalShown = useIsModalAtTop(UserPanelMisplacedAlertModal.key);
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.Servers, true);
      if (!isMainWindow || !module2.isEnabled() || !module2.settings.enhanceLayout) return;
      if (isModalShown) value.props.className = classNames(value.props.className, "BA__appPanelsHighlight");
      value.props.onMouseEnter = (event) => {
        if (isCooldown) return;
        const { x, y, width } = event.currentTarget.getBoundingClientRect();
        const isValid2 = y >= window.innerHeight / 2 && x + width <= window.innerWidth / 2;
        if (isValid2) return;
        const theme = Themes.getAll().find((theme2) => Themes.isEnabled(theme2.id) && !isDismissed(getDismissibleKey(theme2)));
        if (!theme) return;
        ModalActions.openModal((props) => /* @__PURE__ */ BdApi.React.createElement(
          UserPanelMisplacedAlertModal,
          {
            ...props,
            theme,
            setEnhanceLayout: (value2) => {
              module2.settings.enhanceLayout = value2;
              Emitter.emit(Events.ModuleSettingsChanged, module2.id);
              Config.save();
            }
          }
        ), {
          modalKey: UserPanelMisplacedAlertModal.key,
          onCloseCallback: () => {
            setIsCooldown(true);
            setTimeout(() => setIsCooldown(false), 3e4);
          }
        });
      };
    });
  }
  css`.BA__appPanelsHighlight {
    z-index: 10000 !important;
}
.BA__appPanelsHighlight > * {
    pointer-events: none !important;
}``AppPanels`;
  let guildChannelPath = [];
  function useServersModule() {
    const module2 = useModule(ModuleKey.Servers, true);
    const currentState = {
      isEnabled: module2.isEnabled(),
      isEnhancedLayout: module2.isEnabled() && module2.settings.enhanceLayout
    };
    const [isEnabled, setIsEnabled] = require$$0$1.useState(currentState.isEnabled);
    const [isEnhancedLayout] = require$$0$1.useState(currentState.isEnhancedLayout);
    require$$0$1.useEffect(() => {
      if (isEnhancedLayout !== currentState.isEnhancedLayout) forceAppUpdate();
      else if (isEnabled !== currentState.isEnabled) setIsEnabled(currentState.isEnabled);
    }, [currentState.isEnabled, currentState.isEnhancedLayout]);
    return { module: module2, isEnabled, isEnhancedLayout };
  }
  function AppViewTransition({ className, module: module2, shouldSwitch, getSwitchDirection, children: children2 }) {
    const [key2, direction] = useLocationKey(shouldSwitch, getSwitchDirection);
    const auto2 = { direction };
    return /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { className, childFactory: passAuto(auto2) }, /* @__PURE__ */ BdApi.React.createElement(
      AnimeTransition,
      {
        key: key2,
        container: { className },
        defaultLayoutStyles: false,
        freeze: true,
        module: module2,
        auto: auto2
      },
      children2
    ));
  }
  function patchAppView() {
    Patcher.after(...AppViewKeyed, (self2, args, value) => {
      const { isMainWindow } = useWindow();
      const {
        module: serversModule,
        isEnabled: isServersModuleEnabled,
        isEnhancedLayout
      } = useServersModule();
      const channelsModule = useModule(ModuleKey.Channels);
      if (!isMainWindow) return;
      const base = findInReactTree(value, byClassName(DiscordClasses.AppView.base));
      if (!base) return;
      const contentIndex = base.props.children.findIndex(byClassName(DiscordClasses.AppView.content));
      if (contentIndex === -1) return;
      const content = base.props.children[contentIndex];
      if (isServersModuleEnabled) base.props.children[contentIndex] = /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: serversModule, fallback: content }, /* @__PURE__ */ BdApi.React.createElement(
        AppViewTransition,
        {
          className: "BA__content",
          module: serversModule,
          shouldSwitch: shouldSwitchContent,
          getSwitchDirection: getSwitchContentDirection
        },
        content
      ));
      const pageIndex = content.props.children.findIndex(byClassName(DiscordClasses.AppView.page));
      if (pageIndex === -1) return;
      const page = content.props.children[pageIndex];
      if (channelsModule.isEnabled()) content.props.children[pageIndex] = /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: channelsModule, fallback: page }, /* @__PURE__ */ BdApi.React.createElement(
        AppViewTransition,
        {
          className: "BA__page",
          module: channelsModule,
          shouldSwitch: shouldSwitchPage,
          getSwitchDirection: getSwitchPageDirection
        },
        page
      ));
      const routes = findInReactTree(page, (m) => m?.type === Router.Switch)?.props.children;
      const guildChannelRoute = routes?.find((r) => r?.props?.impressionName === ImpressionNames.GUILD_CHANNEL);
      if (guildChannelRoute) guildChannelPath = guildChannelRoute.props.path;
      if (!isEnhancedLayout) return;
      base.props.className = classNames(base.props.className, "BA__baseEnhancedLayout");
      const sidebarIndex = content.props.children.findIndex((m) => "isSidebarOpen" in (m?.props ?? {}));
      if (sidebarIndex === -1) return;
      const sidebar = content.props.children[sidebarIndex];
      let renderedSidebar = sidebar.type(sidebar.props);
      renderedSidebar = renderedSidebar.type(renderedSidebar.props);
      const sidebarContainer = findInReactTree(renderedSidebar, byClassName(DiscordClasses.AppView.sidebar));
      if (sidebarContainer) {
        sidebarContainer.props.children = sidebarContainer.props.children.flatMap((m) => m?.type === require$$0$1.Fragment ? m.props.children : m);
        const guildsIndex = sidebarContainer.props.children.findIndex(byClassName(DiscordClasses.AppView.guilds));
        if (guildsIndex !== -1) {
          base.props.children.splice(
            contentIndex,
            0,
            ...sidebarContainer.props.children.splice(guildsIndex, 1)
          );
        }
        const panelsIndex = sidebarContainer.props.children.findIndex((m) => m?.type === AppPanels);
        if (panelsIndex !== -1) {
          base.props.children.push(
            ...sidebarContainer.props.children.splice(panelsIndex, 1)
          );
        }
      }
      content.props.children[sidebarIndex] = renderedSidebar;
    });
    patchAppPanels();
  }
  css`.BA__content, .BA__page {
    position: relative;
    isolation: isolate;
    display: grid;
    grid-template-columns: subgrid;
    grid-template-rows: subgrid;
    min-width: 0;
    min-height: 0;
    flex: 1;
}
.BA__content {
    grid-column: start / end;
    grid-row: titleBarEnd / end;
}
.BA__page {
    grid-area: page;
}

.BA__baseEnhancedLayout :is(.BA__content, ${DiscordSelectors.AppView.content}) {
    /* Indexes used instead of labels to solve conflicts with ServerFolders */
    grid-column: -3 / end;
    grid-row: -2 / end;
}
.BA__baseEnhancedLayout ${DiscordSelectors.AppView.sidebar} {
    grid-area: channelsList;
}
.BA__baseEnhancedLayout ${DiscordSelectors.AppView.panels} {
    width: calc(var(--custom-guild-sidebar-width) - var(--space-xs)*2);
    z-index: 100;
}

/* Hide the moved elements in the fullscreen voice call */
.BA__baseEnhancedLayout[data-fullscreen="true"] :is(${DiscordSelectors.AppView.guilds}, ${DiscordSelectors.AppView.panels}) {
    display: none;
}

/* Fix for ServerFolders */
.BA__baseEnhancedLayout ${DiscordSelectors.AppView.guilds}[class*="closed"] {
    display: none;
}``AppView (Servers, Channels)`;
  function autoPosition(self2, defaultPosition, source = { align: Position.Top }) {
    if (!self2.__autoRef) {
      self2.__autoRef = require$$0$1.createRef();
      self2.__autoRef.current = Object.assign({}, source, { position: defaultPosition });
    }
    return {
      autoRef: self2.__autoRef,
      setPosition: (position2) => self2.__autoRef.current.position = position2
    };
  }
  function useAutoPosition(defaultPosition, source = { align: Position.Top }) {
    const autoRef = require$$0$1.useRef(
      Object.assign({}, source, { position: defaultPosition })
    );
    return {
      autoRef,
      setPosition: (position2) => autoRef.current.position = position2
    };
  }
  function patchContextSubmenu() {
    const callback = (self2, [props], original) => {
      const layerRef = require$$0$1.useRef();
      const { autoRef, setPosition } = useAutoPosition(Position.Right);
      const timeout = require$$0$1.useMemo(() => new Timeout(), []);
      const [isFocused, setIsFocused] = require$$0$1.useState(props.isFocused);
      require$$0$1.useEffect(() => {
        if (props.isFocused) timeout.start(20, () => setIsFocused(true));
        else {
          timeout.stop();
          setIsFocused(false);
        }
      }, [props.isFocused]);
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.ContextMenu);
      if (!isMainWindow || !module2.isEnabled()) return original(props);
      const value = original({ ...props, isFocused: true });
      const { children: children2 } = value.props;
      const i = children2.length - 1;
      if (!children2[i]) return value;
      children2[i] = /* @__PURE__ */ BdApi.React.createElement(
        AnimeTransition,
        {
          in: isFocused,
          layerRef,
          module: module2,
          autoRef,
          anchor: value.props.ref
        },
        /* @__PURE__ */ BdApi.React.createElement(AppLayer, { layerContext: appLayerContext }, require$$0$1.cloneElement(children2[i], {
          onPositionChange: setPosition,
          ref: layerRef
        }))
      );
      return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: /* @__PURE__ */ BdApi.React.createElement("original", { ...props }) }, value);
    };
    Patcher.instead(ModuleKey.ContextMenu, ...MenuSubmenuItemKeyed, callback);
    Patcher.instead(ModuleKey.ContextMenu, ...MenuSubmenuListItemKeyed, callback);
  }
  function ensureOnce() {
    let triggered = /* @__PURE__ */ new Map();
    return (fn, key2 = "default") => {
      if (triggered.get(key2)) return;
      fn();
      triggered.set(key2, true);
    };
  }
  function patchContextMenu() {
    const once = ensureOnce();
    Patcher.after(ModuleKey.ContextMenu, ...ContextMenuKeyed, (self2, args, value) => {
      once(() => {
        injectModule(value?.type, ModuleKey.ContextMenu);
        Patcher.after(ModuleKey.ContextMenu, value?.type?.prototype, "componentDidMount", (self22) => {
          self22.__anchor = Mouse$1?.getAnchor();
        });
        Patcher.after(ModuleKey.ContextMenu, value?.type?.prototype, "render", (self22, args2, value2) => {
          const module22 = Core.getModule(ModuleKey.ContextMenu);
          if (!module22.isEnabled()) return;
          return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module22, fallback: value2 }, /* @__PURE__ */ BdApi.React.createElement(MainWindowOnly, { fallback: value2 }, () => {
            const { config: config2 = {} } = self22.props;
            const { autoRef, setPosition } = autoPosition(
              self22,
              config2.position ?? Position.Right,
              { align: config2.align ?? Position.Top }
            );
            if (value2)
              TinyPatcher.after(value2, "type", (self3, [props], value3) => {
                value3.props.onPositionChange = props.onPositionChange ?? (() => {
                });
                props.setLayerRef?.(value3.props.ref);
              });
            return /* @__PURE__ */ BdApi.React.createElement(
              AnimeTransition,
              {
                in: self22.props.in && !!value2,
                layerRef: () => self22.__layerRef?.current,
                module: module22,
                autoRef,
                anchor: self22.__anchor
              },
              value2 && require$$0$1.cloneElement(value2, {
                onPositionChange: setPosition,
                setLayerRef: (value3) => self22.__layerRef = value3
              })
            );
          }));
        });
      });
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.ContextMenu);
      if (!isMainWindow || !module2.isEnabled()) return;
      return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: value }, /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null }, value.props.isOpen && value));
    });
    patchContextSubmenu();
  }
  function patchPopoutCSSAnimator() {
    Patcher.instead(ModuleKey.Popouts, ...PopoutCSSAnimatorKeyed, (self2, [props], original) => {
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.Popouts);
      if (!isMainWindow || !module2.isEnabled()) return original(props);
      return props?.children;
    });
  }
  function shouldShow(self2, props = self2.props, state = self2.state) {
    return (!state.isLoading || state.shouldShowLoadingState) && self2.shouldShowPopout(props, state);
  }
  function PopoutLayer({ ref, children: children2, ...props }) {
    const layerRef = require$$0$1.useRef();
    const layer = findInReactTree(children2, (m) => m?.type === ReferencePositionLayer);
    if (layer) layer.props.ref = (value) => {
      layerRef.current = value;
      if (props.in) ref.current = value;
    };
    return /* @__PURE__ */ BdApi.React.createElement(
      AnimeTransition,
      {
        layerRef,
        ...props
      },
      children2
    );
  }
  function patchBasePopout() {
    injectModule(BasePopout, ModuleKey.Popouts);
    Patcher.after(ModuleKey.Popouts, BasePopout?.prototype, "componentDidUpdate", (self2, [props, state]) => {
      if (shouldShow(self2, props, state) !== shouldShow(self2) || state.isLoading !== self2.state.isLoading)
        requestAnimationFrame(() => {
          reactDom.flushSync(() => self2.setState({ resizeKey: self2.state.resizeKey + 1 }));
        });
    });
    Patcher.after(ModuleKey.Popouts, BasePopout?.prototype, "renderLayer", (self2, args, value) => {
      const module2 = Core.getModule(ModuleKey.Popouts);
      if (!module2.isEnabled()) return;
      return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: value }, /* @__PURE__ */ BdApi.React.createElement(MainWindowOnly, { fallback: value }, () => {
        const { autoRef, setPosition } = autoPosition(
          self2,
          self2.props.position,
          { align: self2.props.align }
        );
        const position2 = self2.state.renderedPosition ?? self2.props.position;
        if (autoRef.current.position !== position2) setPosition(position2);
        return /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null }, value && shouldShow(self2) && /* @__PURE__ */ BdApi.React.createElement(
          PopoutLayer,
          {
            key: +self2.state.isLoading,
            ref: self2.layerRef,
            module: module2,
            autoRef,
            anchor: self2.domElementRef
          },
          value
        ));
      }));
    });
    patchPopoutCSSAnimator();
  }
  function useSafeBoolean(value, store = AnimationStore$1) {
    const [safeValue, setSafeValue] = require$$0$1.useState(value);
    require$$0$1.useEffect(() => {
      if (store.isSafe) return setSafeValue(value);
      setSafeValue(false);
      return store.onceSafe(() => setSafeValue(value));
    }, [value]);
    return safeValue;
  }
  function TooltipTransition(props) {
    const { module: module2, isVisible, onAnimationRest, ...rest } = props;
    const onRest = (isVisible2) => () => onAnimationRest?.(
      { value: {}, finished: true },
      {
        ctrl: {},
        expired: !isVisible2,
        item: isVisible2,
        key: isVisible2 ? "tooltip" : "empty",
        phase: isVisible2 ? SpringTransitionPhases.ENTER : SpringTransitionPhases.LEAVE
      }
    );
    const layerRef = require$$0$1.useRef();
    const { autoRef, setPosition } = useAutoPosition(props.position, { align: props.align });
    const layer = TooltipLayer(rest);
    const safeIsVisible = useSafeBoolean(isVisible);
    return /* @__PURE__ */ BdApi.React.createElement(
      AnimeTransition,
      {
        in: safeIsVisible,
        layerRef,
        module: module2,
        autoRef,
        onEntered: onRest(true),
        onExited: onRest(false),
        anchor: props.targetElementRef
      },
      require$$0$1.cloneElement(layer, {
        ref: layerRef,
        onPositionChange: setPosition
      })
    );
  }
  function patchTooltip() {
    if (Tooltip$1) Tooltip$1.defaultProps.delay = 0;
    injectModule(Tooltip$1, ModuleKey.Tooltips);
    Patcher.after(ModuleKey.Tooltips, Tooltip$1?.prototype, "renderTooltip", (self2, args, value) => {
      const module2 = Core.getModule(ModuleKey.Tooltips);
      if (!module2.isEnabled()) return;
      const { text: text2 } = self2.props;
      return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: value }, /* @__PURE__ */ BdApi.React.createElement(MainWindowOnly, { fallback: value }, () => /* @__PURE__ */ BdApi.React.createElement(
        TooltipTransition,
        {
          ...value.props,
          children: typeof text2 === "function" ? text2() : text2,
          module: module2
        }
      )));
    });
  }
  function getMessageKey(message) {
    return message?.nonce ?? message?.id;
  }
  const toEnter = /* @__PURE__ */ new Set();
  const toExit = /* @__PURE__ */ new Set();
  function handleMessageCreate({ message }) {
    const key2 = getMessageKey(message);
    toEnter.add(key2);
    setTimeout(() => toEnter.delete(key2), MAX_ANIMATION_DURATION);
  }
  function handleMessageDelete({ id }) {
    toExit.add(id);
    setTimeout(() => toExit.delete(id), MAX_ANIMATION_DURATION);
  }
  const MessageStackStore = new class MessageStackStore extends Flux.Store {
    getMessagesAwaitingTransition() {
      return { toEnter, toExit };
    }
  }(Dispatcher, {
    MESSAGE_CREATE: handleMessageCreate,
    MESSAGE_DELETE: handleMessageDelete
  });
  function patchMessage() {
    Patcher.after(ModuleKey.Messages, Message$1, "type", (self2, [props], value) => {
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.Messages);
      if (!isMainWindow || !module2.isEnabled()) return;
      const messageListItem = findInReactTree(value, (m) => m?.className?.includes(DiscordClasses.MessageList.messageListItem));
      if (!messageListItem) return;
      messageListItem.ref = props.ref;
      const message = findInReactTree(messageListItem, (m) => m?.className?.includes(DiscordClasses.MessageList.message));
      if (!message?.className.includes(DiscordClasses.MessageList.groupStart)) return;
      message.className = message.className.replace(DiscordClasses.MessageList.groupStart, "");
      messageListItem.className += " " + DiscordClasses.MessageList.groupStart;
    });
  }
  function patchMessageDivider() {
    Patcher.after(ModuleKey.Messages, MessageDivider, "render", (self2, [props], value) => {
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.Messages);
      if (!isMainWindow || !module2.isEnabled()) return;
      const { children: children2, className, ...rest } = value.props;
      return /* @__PURE__ */ BdApi.React.createElement("div", { className: props.className, ...rest }, /* @__PURE__ */ BdApi.React.createElement(value.type, { className: className.replace(props.className, "") }, children2));
    });
  }
  function patchChannelMessageList() {
    const once = ensureOnce();
    Patcher.after(ChannelMessageList, "type", (self2, args, value) => {
      once(
        () => Patcher.after(ModuleKey.Messages, findInReactTree(value?.props?.children, (m) => m?.props?.messages)?.type, "type", (self22, [{ channel: channel2 }], value2) => {
          const hasLayers = useStateFromStores([LayerStore$1], () => LayerStore$1.hasLayers());
          const { toEnter: toEnter2, toExit: toExit2 } = useStateFromStores([MessageStackStore], () => MessageStackStore.getMessagesAwaitingTransition());
          const { isMainWindow } = useWindow();
          const module2 = useModule(ModuleKey.Messages);
          if (!isMainWindow || !module2.isEnabled()) return;
          const list = findInReactTree(value2, (m) => m?.type === "ol");
          if (!list) return;
          const i = list.props.children.findIndex((i2) => Array.isArray(i2));
          if (i === -1) return;
          const childFactory = (e, index2, arr) => {
            const message = findInReactTree(e, (m) => m?.message)?.message ?? findInReactTree(arr[index2 + 1] ?? {}, (m) => m?.message)?.message;
            return require$$0$1.cloneElement(e, {
              exit: !hasLayers && toExit2.has(message?.id)
            });
          };
          list.props.children[i] = /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: list.props.children[i] }, /* @__PURE__ */ BdApi.React.createElement(
            TransitionGroup,
            {
              key: channel2.id,
              component: null,
              childFactory
            },
            list.props.children[i].map((item, index2, arr) => {
              const { message } = item.props;
              if (message) item.key = getMessageKey(message);
              return /* @__PURE__ */ BdApi.React.createElement(
                AnimeTransition,
                {
                  key: item.key,
                  injectContainerRef: true,
                  enter: !hasLayers && toEnter2.has(message ? item.key : getMessageKey(arr[index2 + 1]?.props?.message)),
                  exit: false,
                  module: module2
                },
                item
              );
            })
          ));
        })
      );
    });
    patchMessage();
    patchMessageDivider();
  }
  css`${DiscordSelectors.MessageList.divider} {
    position: relative;
}``ChannelMessageList (Messages)`;
  const { ENTERED, ENTERING, EXITING } = Transition;
  function areChildrenDifferent(oldChildren, newChildren) {
    if (oldChildren === newChildren) return false;
    if (require$$0$1.isValidElement(oldChildren) && require$$0$1.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
      return false;
    }
    return true;
  }
  const modes = {
    out: "out-in",
    in: "in-out"
  };
  const callHook = (element2, name2, cb) => (...args) => {
    element2.props[name2] && element2.props[name2](...args);
    cb();
  };
  const leaveRenders = {
    [modes.out]: ({ current, changeState }) => require$$0$1.cloneElement(current, {
      in: false,
      onExited: callHook(current, "onExited", () => {
        changeState(ENTERING, null);
      })
    }),
    [modes.in]: ({ current, changeState, children: children2 }) => [
      current,
      require$$0$1.cloneElement(children2, {
        in: true,
        onEntered: callHook(children2, "onEntered", () => {
          changeState(ENTERING);
        })
      })
    ]
  };
  const enterRenders = {
    [modes.out]: ({ children: children2, changeState }) => require$$0$1.cloneElement(children2, {
      in: true,
      onEntered: callHook(children2, "onEntered", () => {
        changeState(ENTERED, require$$0$1.cloneElement(children2, { in: true }));
      })
    }),
    [modes.in]: ({ current, children: children2, changeState }) => [
      require$$0$1.cloneElement(current, {
        in: false,
        onExited: callHook(current, "onExited", () => {
          changeState(ENTERED, require$$0$1.cloneElement(children2, { in: true }));
        })
      }),
      require$$0$1.cloneElement(children2, {
        in: true
      })
    ]
  };
  class SwitchTransition extends require$$0$1.Component {
    state = {
      status: ENTERED,
      current: null
    };
    appeared = false;
    static getDerivedStateFromProps(props, state) {
      if (props.children == null) {
        return {
          current: null
        };
      }
      if (state.status === ENTERING && props.mode === modes.in) {
        return {
          status: ENTERING
        };
      }
      if (state.current && areChildrenDifferent(state.current, props.children)) {
        return {
          status: EXITING
        };
      }
      return {
        current: require$$0$1.cloneElement(props.children, {
          in: true
        })
      };
    }
    componentDidMount() {
      this.appeared = true;
    }
    changeState = (status, current = this.state.current) => {
      this.setState({
        status,
        current
      });
    };
    render() {
      const {
        props: { children: children2, mode },
        state: { status, current }
      } = this;
      const data2 = { children: children2, current, changeState: this.changeState, status };
      let component;
      switch (status) {
        case ENTERING:
          component = enterRenders[mode](data2);
          break;
        case EXITING:
          component = leaveRenders[mode](data2);
          break;
        case ENTERED:
          component = current;
      }
      return /* @__PURE__ */ BdApi.React.createElement(TransitionGroupContext, { value: { isMounting: !this.appeared } }, component);
    }
  }
  SwitchTransition.defaultProps = {
    mode: modes.out
  };
  function patchChatSidebar() {
    Patcher.instead(...ChatSidebarKeyed, (self2, [props], original) => {
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.ThreadSidebar);
      const switchModule = useModule(ModuleKey.ThreadSidebarSwitch);
      if (!isMainWindow || !module2.isEnabled() && !switchModule.isEnabled()) return original(props);
      const value = original({
        ...props,
        maxWidth: Math.max(props.maxWidth, 451),
        floatingLayer: null
      });
      const chatTarget = findInReactTree(value, byClassName(DiscordClasses.ChatSidebar.chatTarget));
      if (chatTarget) {
        chatTarget.props = {};
        chatTarget.type = require$$0$1.Fragment;
      }
      return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { fallback: /* @__PURE__ */ BdApi.React.createElement("original", { ...props }) }, /* @__PURE__ */ BdApi.React.createElement(
        AnimeContainer,
        {
          ref: props.ref,
          id: ModuleKey.ThreadSidebarSwitch,
          container: { className: "BA__sidebar" }
        },
        /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__sidebar" }, value)
      ));
    });
  }
  function SwitchSidebarTransition({ state, injectContainerRef: injectContainerRef2 = true, ...props }) {
    const key2 = JSON.stringify(state);
    return /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null }, /* @__PURE__ */ BdApi.React.createElement(
      AnimeTransition,
      {
        key: key2,
        injectContainerRef: injectContainerRef2,
        ...props
      }
    ));
  }
  function SidebarTransition({ module: module2, switchModule, state, injectContainerRef: injectContainerRef2, children: children2 }) {
    const key2 = state?.type ?? "none";
    return /* @__PURE__ */ BdApi.React.createElement(SwitchTransition, null, /* @__PURE__ */ BdApi.React.createElement(
      AnimeTransition,
      {
        key: key2,
        container: { className: "BA__sidebar" },
        module: module2
      },
      /* @__PURE__ */ BdApi.React.createElement(
        SwitchSidebarTransition,
        {
          state,
          module: switchModule,
          injectContainerRef: injectContainerRef2
        },
        children2
      )
    ));
  }
  function injectContainerRef(children2, ref) {
    const div = findInReactTree(children2, (m) => m?.type === "div");
    if (div) div.props.ref = ref;
  }
  async function patchMembersModViewSidebar() {
    Patcher.after(...await MembersModViewSidebarKeyed, (self2, [{ guildId }], value) => {
      const state = useStateFromStores([ChannelSectionStore], () => ChannelSectionStore.getGuildSidebarState(guildId), [guildId]);
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.ThreadSidebar);
      const switchModule = useModule(ModuleKey.ThreadSidebarSwitch);
      if (!isMainWindow || !module2.isEnabled() && !switchModule.isEnabled()) return;
      return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { fallback: value }, /* @__PURE__ */ BdApi.React.createElement(
        SidebarTransition,
        {
          module: module2,
          switchModule,
          state,
          injectContainerRef
        },
        value
      ));
    });
  }
  function patchCallChatSidebar() {
    Patcher.after(ModuleKey.ThreadSidebar, ...CallChatSidebarKeyed, (self2, [props], value) => {
      value.props.ref = props.ref;
    });
  }
  function patchVoiceChannelView() {
    const once = ensureOnce();
    Patcher.after(ModuleKey.ThreadSidebar, ...VoiceChannelViewKeyed, (self2, args, value) => {
      const channelView = findInReactTree(value, (m) => m?.props?.channel);
      if (!channelView) return;
      once(() => {
        injectModule(channelView.type, ModuleKey.ThreadSidebar);
        Patcher.after(ModuleKey.ThreadSidebar, channelView.type?.prototype, "render", (self22, args2, value2) => {
          const module2 = Core.getModule(ModuleKey.ThreadSidebar);
          if (!module2.isEnabled()) return;
          if (!self22.__containerRef) self22.__containerRef = require$$0$1.createRef();
          const chatWrapper = findInReactTree(value2, byClassName(DiscordClasses.VoiceChannelView.channelChatWrapper));
          if (!chatWrapper) return;
          const fragment = findInReactTree(chatWrapper, (m) => m?.type === require$$0$1.Fragment);
          if (!fragment) return;
          const { children: children2 } = fragment.props;
          const callChatSidebarIndex = 0;
          return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: value2 }, /* @__PURE__ */ BdApi.React.createElement(MainWindowOnly, { fallback: value2 }, () => {
            children2[callChatSidebarIndex] = /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null }, children2[callChatSidebarIndex] && /* @__PURE__ */ BdApi.React.createElement(
              AnimeTransition,
              {
                injectContainerRef: true,
                module: module2
              },
              children2[callChatSidebarIndex]
            ));
            return value2;
          }));
        });
      });
    });
    patchCallChatSidebar();
  }
  function patchChannelView() {
    const once = ensureOnce();
    Patcher.after(ChannelView, "type", (self2, args, value) => {
      TinyPatcher.after(value?.type, "render", (self22, args2, value2) => {
        const guildChannel = findInReactTree(value2, (m) => "guild" in (m?.props ?? {}));
        if (!guildChannel) return;
        once(() => {
          injectModule(guildChannel.type, [
            ModuleKey.MembersSidebar,
            ModuleKey.ThreadSidebar,
            ModuleKey.ThreadSidebarSwitch
          ]);
          Patcher.after(ModuleKey.MembersSidebar, guildChannel.type?.prototype, "renderSidebar", (self3, args3, value3) => {
            const module2 = Core.getModule(ModuleKey.MembersSidebar);
            if (!module2.isEnabled()) return value3;
            return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: value3 }, /* @__PURE__ */ BdApi.React.createElement(MainWindowOnly, { fallback: value3 }, /* @__PURE__ */ BdApi.React.createElement(SwitchTransition, null, /* @__PURE__ */ BdApi.React.createElement(
              AnimeTransition,
              {
                key: self3.props.section,
                container: { className: "BA__sidebar" },
                module: module2,
                freeze: true
              },
              value3
            ))));
          });
          Patcher.after(guildChannel.type?.prototype, "renderThreadSidebar", (self3, args3, value3) => {
            const module2 = Core.getModule(ModuleKey.ThreadSidebar);
            const switchModule = Core.getModule(ModuleKey.ThreadSidebarSwitch);
            if (!module2.isEnabled() && !switchModule.isEnabled()) return;
            const state = self3.props.channelSidebarState ?? self3.props.guildSidebarState;
            return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { fallback: value3 }, /* @__PURE__ */ BdApi.React.createElement(MainWindowOnly, { fallback: value3 }, /* @__PURE__ */ BdApi.React.createElement(
              SidebarTransition,
              {
                module: module2,
                switchModule,
                state
              },
              value3
            )));
          });
        });
      });
    });
    patchChatSidebar();
    patchVoiceChannelView();
    patchMembersModViewSidebar();
  }
  css`.BA__sidebar {
    position: relative;
    isolation: isolate;
    display: flex;
    justify-content: flex-end;
    height: 100%;
}
${DiscordSelectors.AppView.base} {
    overflow: clip;
}
${DiscordSelectors.AppView.page} {
    overflow: visible !important;
    min-height: 0;
    min-width: 0;
}
${DiscordSelectors.ChannelView.chat} {
    overflow: clip;
    isolation: isolate;
}
${DiscordSelectors.ChatSidebar.chatLayerWrapper} {
    filter: none;
}``ChannelView (Sidebars)`;
  function useDirection(list, current) {
    const prev = usePrevious(current);
    const direction = require$$0$1.useRef(1);
    if (prev !== current)
      direction.current = +(list.indexOf(prev) < list.indexOf(current));
    return direction.current;
  }
  async function patchStandardSidebarView() {
    Patcher.after((await StandardSidebarViewWrapper)?.prototype, "render", (self2, args, value) => {
      const view = findInReactTree(value, (m) => m?.props?.content && m?.props?.sidebar);
      if (!view) return;
      view.props.sections = self2.getPredicateSections().map((s) => s.section);
    });
    Patcher.after(...await StandardSidebarViewKeyed, (self2, [props], value) => {
      const direction = useDirection(props.sections, props.section);
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.Settings);
      const layersModule = useModule(ModuleKey.Layers);
      if (!isMainWindow) return;
      if (layersModule.isEnabled()) {
        const animated = findInReactTree(value, (m) => m?.type?.displayName?.startsWith("Animated"));
        if (animated) {
          delete animated.props.style;
          animated.type = "div";
        }
      }
      if (!module2.isEnabled()) return;
      const standardSidebarView = findInReactTree(value, byClassName(DiscordClasses.StandardSidebarView.standardSidebarView));
      if (!standardSidebarView) return;
      const { children: children2 } = standardSidebarView.props;
      const i = children2.findIndex(byClassName(DiscordClasses.StandardSidebarView.contentRegion));
      if (i === -1) return;
      const contentRegion = children2[i];
      const auto2 = { direction };
      children2[i] = /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: contentRegion }, /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { className: DiscordClasses.StandardSidebarView.contentRegion, childFactory: passAuto(auto2) }, /* @__PURE__ */ BdApi.React.createElement(
        AnimeTransition,
        {
          key: props.section,
          container: { className: DiscordClasses.StandardSidebarView.contentRegion },
          module: module2,
          auto: auto2
        },
        contentRegion
      )));
    });
  }
  StandardSidebarViewKeyed.then(
    () => css`${DiscordSelectors.StandardSidebarView.contentRegion}:has(> ${DiscordSelectors.StandardSidebarView.contentRegion}[data-ba-container]) {
    isolation: isolate;
    z-index: 2; /* Allow overflowing the sidebar */
}
${DiscordSelectors.StandardSidebarView.contentRegion}[data-ba-container] {
    background: none;
}
${DiscordSelectors.StandardSidebarView.contentRegion} > ${DiscordSelectors.StandardSidebarView.contentRegion} {
    height: 100%;
}

.platform-win ${DiscordSelectors.StandardSidebarView.contentRegionScroller} {
    height: calc(100% - var(--custom-app-top-bar-height));
}

${DiscordSelectors.StandardSidebarView.contentRegionScroller}:has(.BA__home) {
    overflow: visible !important;
}``StandardSidebarView (Settings)`
  );
  function patchModalItem(component) {
    injectModule(component, ModuleKey.Modals);
    Patcher.after(ModuleKey.Modals, component?.prototype, "render", (self2, args, value) => {
      const module2 = Core.getModule(ModuleKey.Modals);
      if (!module2.isEnabled()) return;
      const container = findInReactTree(value, (m) => m?.type === "div");
      if (!container) return;
      container.props.ref = self2.props.layerRef;
      container.props.className = classNames(container.props.className, {
        "BA__modal--hidden": self2.props.hidden
      });
    });
  }
  function useTransitionCustomCondition(condition, props) {
    const isShown = condition && props.in;
    const wasShown = usePrevious(isShown);
    require$$0$1.useEffect(() => {
      if (!props.in && !wasShown) props.onExited?.();
    }, [props.in]);
    return isShown;
  }
  function patchManaModalRoot() {
    Patcher.after(ModuleKey.Modals, ...Mana.ModalRootKeyed, (self2, args, value) => {
      const module2 = Core.getModule(ModuleKey.Modals);
      if (!module2.isEnabled()) return;
      const container = findInReactTree(value, byClassName(DiscordClasses.ManaModal.container));
      if (!container) return;
      Object.assign(container, /* @__PURE__ */ BdApi.React.createElement(
        AnimeContainer,
        {
          id: ModuleKey.Modals,
          container: {
            className: classNames(
              "BA__manaModalContainer",
              container.props.className
            )
          }
        },
        require$$0$1.cloneElement(container)
      ));
    });
  }
  css`.BA__manaModalContainer {
    background: none !important;
    border: none !important;
    box-shadow: none !important;
    padding: 0 !important;
    border-radius: 0 !important;
}

${DiscordSelectors.ManaModal.container} {
    min-height: 0;
}``ManaModalRoot`;
  function ModalBackdrop({ isVisible, onClick, disabled = false, disablePointerEvents = false, ...props }) {
    return /* @__PURE__ */ BdApi.React.createElement(
      AnimeTransition,
      {
        ...props,
        in: isVisible,
        container: {
          className: classNames({
            "BA__backdropContainer": true,
            "BA__backdropContainer--disablePointerEvents": disablePointerEvents
          })
        },
        appear: true,
        defaultLayoutStyles: false
      },
      /* @__PURE__ */ BdApi.React.createElement(
        "div",
        {
          className: "BA__backdrop",
          onClick: disabled ? void 0 : onClick
        }
      )
    );
  }
  function patchModalScrim() {
    Patcher.after(ModuleKey.ModalsBackdrop, ModalScrim, "render", (self2, [props], value) => {
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.ModalsBackdrop);
      if (!isMainWindow || !module2.isEnabled()) return;
      return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: value }, /* @__PURE__ */ BdApi.React.createElement(
        ModalBackdrop,
        {
          ...props,
          module: module2
        }
      ));
    });
  }
  css`.BA__backdropContainer {
    position: fixed;
    inset: 0;
    right: var(--devtools-sidebar-width, 0);
    pointer-events: auto;
}
.BA__backdropContainer--disablePointerEvents {
    pointer-events: none;
}
.BA__backdrop {
    position: absolute;
    inset: 0;
    background-color: rgba(0, 0, 0, .7);
}``ModalScrim`;
  function Modal({ modal, ...props }) {
    const layerRef = require$$0$1.useRef();
    const containerRef = require$$0$1.useMemo(() => ({
      get current() {
        return layerRef.current?.querySelector(`[data-ba-container="${ModuleKey.Modals}"]`) ?? directChild(layerRef.current);
      }
    }), [layerRef]);
    const isShown = useTransitionCustomCondition(modal.props.isVisible, props);
    return /* @__PURE__ */ BdApi.React.createElement(
      AnimeTransition,
      {
        ...props,
        in: isShown,
        containerRef,
        enter: !modal.props.instant,
        exit: !modal.props.instant,
        mountOnEnter: false,
        unmountOnExit: false
      },
      (state) => require$$0$1.cloneElement(modal, {
        layerRef,
        hidden: state === Transition.EXITED && !modal.props.isVisible,
        instant: true
        // Disable Discord's internal modal animations
      })
    );
  }
  function patchModals() {
    const once = ensureOnce();
    Patcher.after(ModuleKey.Modals, ...ModalsKeyed, (self2, args, value) => {
      const modals = value.props.children[1];
      if (modals?.length) once(() => patchModalItem(modals[0].type));
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.Modals);
      if (!isMainWindow || !module2.isEnabled()) return;
      value.props.children[1] = /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: modals }, /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null }, modals.map((modal) => /* @__PURE__ */ BdApi.React.createElement(
        Modal,
        {
          key: modal.props.modalKey,
          module: module2,
          modal
        }
      ))));
    });
    patchModalScrim();
    patchManaModalRoot();
  }
  css`${DiscordSelectors.Modal.root}, .bd-modal-root {
    isolation: isolate;
}
${DiscordSelectors.Modal.focusLock}:has(> [class*="carouselModal"]) {
    position: absolute !important;
    inset: 0;
}
.BA__modal--hidden {
    visibility: hidden;
    pointer-events: none;
}``Modals`;
  let LayersComponent = null;
  function getWindowCenterAnchor() {
    return {
      x: window.innerWidth / 2,
      y: window.innerHeight / 2,
      width: 0,
      height: 0
    };
  }
  function Layer({ baseLayer, hidden, children: children2 }) {
    const isUserPanelMisplacedAlertModalShown = useIsModalAtTop(UserPanelMisplacedAlertModal.key);
    return /* @__PURE__ */ BdApi.React.createElement(
      "div",
      {
        className: classNames(
          DiscordClasses.Layers.layer,
          {
            [DiscordClasses.Layers.baseLayer]: baseLayer,
            "BA__layer--hidden": hidden,
            "BA__layer--containNone": baseLayer && isUserPanelMisplacedAlertModalShown
          }
        )
      },
      children2
    );
  }
  function LayerTransition({ layer, ...props }) {
    const isShown = useTransitionCustomCondition(layer.props.mode === "SHOWN", props);
    return /* @__PURE__ */ BdApi.React.createElement(
      AnimeTransition,
      {
        ...props,
        in: isShown,
        container: { className: "BA__layerContainer" },
        defaultLayoutStyles: false,
        mountOnEnter: false,
        unmountOnExit: false
      },
      (state) => /* @__PURE__ */ BdApi.React.createElement(
        Layer,
        {
          ...layer.props,
          key: layer.key,
          hidden: state === Transition.EXITED
        }
      )
    );
  }
  class LayerStore {
    constructor() {
      this.anchors = [];
      this.currentAnchor = null;
      this.currentDirection = 0;
    }
    get count() {
      return this.anchors.length;
    }
    getLastAnchor() {
      return this.anchors[this.anchors.length - 1];
    }
    report() {
      return {
        direction: this.currentDirection,
        anchor: this.currentAnchor ?? getWindowCenterAnchor()
      };
    }
    update(count) {
      this.anchors = Array.from({ length: count }).map(
        this.count === 0 ? () => null : (_, i) => this.anchors[i] === void 0 ? Mouse$1.getAnchor() : this.anchors[i]
      );
    }
    onRender(count) {
      if (this.count === count) return this.report();
      if (count > this.count) {
        this.currentDirection = 1;
        this.update(count);
        this.currentAnchor = this.getLastAnchor();
      } else {
        this.currentDirection = 0;
        this.currentAnchor = this.getLastAnchor();
        this.update(count);
      }
      return this.report();
    }
  }
  function patchLayers() {
    const once = ensureOnce();
    Patcher.after(ModuleKey.Layers, ...LayersKeyed, (self2, args, value) => {
      once(
        () => {
          LayersComponent = value?.type;
          const layerStore = new LayerStore();
          injectModule(value?.type, ModuleKey.Layers);
          Patcher.after(ModuleKey.Layers, value?.type?.prototype, "renderLayers", (self22, args2, value2) => {
            const module2 = Core.getModule(ModuleKey.Layers);
            if (!module2.isEnabled()) return;
            const { direction, anchor } = layerStore.onRender(value2.length);
            const auto2 = { direction, preservedMouse: anchor };
            return /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: value2 }, /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null, childFactory: passAuto(auto2) }, value2.map((layer) => /* @__PURE__ */ BdApi.React.createElement(
              LayerTransition,
              {
                key: layer.key,
                module: module2,
                auto: auto2,
                layer
              }
            ))));
          });
        }
      );
    });
  }
  css`.BA__layerContainer {
    position: absolute;
    inset: 0;
}
${DiscordSelectors.Layers.layer} {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    contain: strict;
}
.BA__layer--hidden {
    visibility: hidden;
    pointer-events: none;
}
.BA__layer--containNone {
    contain: none;
}``Layers`;
  const channels = /* @__PURE__ */ new Set();
  const guilds = /* @__PURE__ */ new Set();
  function add(set, item, timeout = 10) {
    set.add(item);
    setTimeout(() => set.delete(item), timeout);
  }
  function handleCategoryCollapse({ id }) {
    const channel2 = ChannelStore.getChannel(id);
    add(guilds, channel2?.guild_id ?? id);
  }
  function handleCategoryCollapseAll({ guildId }) {
    add(guilds, guildId);
  }
  function handleChannelCreate({ channel: channel2 }) {
    add(channels, channel2.id);
  }
  const ChannelStackStore = new class ChannelStackStore extends Flux.Store {
    getChannelsAwaitingTransition() {
      return { channels, guilds };
    }
  }(Dispatcher, {
    CATEGORY_COLLAPSE: handleCategoryCollapse,
    CATEGORY_EXPAND: handleCategoryCollapse,
    CATEGORY_COLLAPSE_ALL: handleCategoryCollapseAll,
    CATEGORY_EXPAND_ALL: handleCategoryCollapseAll,
    CHANNEL_CREATE: handleChannelCreate,
    CHANNEL_DELETE: handleChannelCreate
  });
  function PassThrough({ children: children2, ...props }) {
    return children2(props);
  }
  function patchChannelItem() {
    const once = ensureOnce();
    const callback = (key2) => (self2, args, value) => {
      once(() => {
        injectModule(value?.type?.DecoratedComponent, ModuleKey.ChannelList);
        Patcher.after(ModuleKey.ChannelList, value?.type?.DecoratedComponent?.prototype, "render", (self3, args2, value2) => {
          const module2 = Core.getModule(ModuleKey.ChannelList);
          if (!module2.isEnabled()) return;
          if (!self3.__containerRef) self3.__containerRef = require$$0$1.createRef();
          const container = findInReactTree(value2, (m) => m?.type === "li");
          if (!container) return;
          switch (typeof container.props.ref) {
            case "object":
              self3.__containerRef = container.props.ref;
              break;
            case "function":
              TinyPatcher.after(container.props, "ref", (_, [ref]) => self3.__containerRef.current = ref);
              break;
            default:
              container.props.ref = self3.__containerRef;
          }
        });
      }, key2);
    };
    Patcher.after(...ChannelItemKeyed, callback("channel"));
    Patcher.after(...VoiceChannelItemKeyed, callback("voice"));
    Patcher.after(...StageVoiceChannelItemKeyed, callback("stage"));
  }
  function patchChannelThreadList() {
    Patcher.after(ModuleKey.ChannelList, ChannelThreadList, "type", (self2, [props], value) => {
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.ChannelList);
      if (!isMainWindow || !module2.isEnabled()) return;
      const container = findInReactTree(value, (m) => m?.type === "li");
      if (!container) return;
      container.props.ref = props.ref;
    });
  }
  function ListItem({ children: children2, ...props }) {
    const itemRef = require$$0$1.useRef();
    children2.props.ref = itemRef;
    const containerRef = require$$0$1.useMemo(() => ({
      get current() {
        if (itemRef.current instanceof HTMLElement) return itemRef.current;
        return Utils.findInTree(
          itemRef.current,
          (m) => m?.__containerRef,
          { walkable: ["decoratedRef", "current"] }
        )?.__containerRef.current;
      }
    }), [itemRef]);
    return /* @__PURE__ */ BdApi.React.createElement(
      AnimeTransition,
      {
        containerRef,
        ...props
      },
      children2
    );
  }
  function patchListThin() {
    Patcher.after(ModuleKey.ChannelList, ListThin, "render", (self2, [props], value) => {
      const isChannelList = props.id?.includes("channels");
      const channelsToAnimate = isChannelList && useStateFromStores([ChannelStackStore], () => ChannelStackStore.getChannelsAwaitingTransition());
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.ChannelList);
      if (!isMainWindow || !isChannelList || !module2.isEnabled()) return;
      const focusRingScope = findInReactTree(value, (m) => m?.containerRef);
      if (!focusRingScope || !Array.isArray(focusRingScope.children)) return;
      const shouldAnimate = (item) => {
        if (isChannelList) {
          const { channel: channel2 } = findInReactTree(item, (m) => m?.channel) ?? {};
          if (channel2) return channelsToAnimate.channels.has(channel2.id) || channelsToAnimate.guilds.has(channel2.guild_id);
        }
        return false;
      };
      const childFactory = (e) => require$$0$1.cloneElement(e, {
        exit: e.props.items.some((i) => shouldAnimate(i))
      });
      focusRingScope.children = /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: focusRingScope.children }, /* @__PURE__ */ BdApi.React.createElement(
        TransitionGroup,
        {
          component: null,
          childFactory
        },
        focusRingScope.children.map((item) => {
          if (!item) return item;
          const items2 = [].concat(
            item.type === require$$0$1.Fragment ? item.props.children : item
          ).filter((i) => !!i);
          return /* @__PURE__ */ BdApi.React.createElement(
            PassThrough,
            {
              key: item.key,
              enter: shouldAnimate(item),
              exit: false,
              module: module2,
              items: items2
            },
            (props2) => props2.items.map((item2) => /* @__PURE__ */ BdApi.React.createElement(ListItem, { ...props2 }, item2))
          );
        })
      ));
    });
    patchChannelItem();
    patchChannelThreadList();
  }
  css`${DiscordSelectors.ChannelItem.containerDefault}, ${DiscordSelectors.ChannelItem.containerDragBefore},
${DiscordSelectors.ChannelItem.containerUserOver}, ${DiscordSelectors.ChannelItem.containerDragAfter} {
    transition: none;
}``ListThin (Channel List)`;
  const Prompt = new class Prompt {
    Types = Enum({
      HardwareAcceleration: "hardwareAcceleration"
    });
    get state() {
      return data.prompts;
    }
    onStartup() {
      this.showPrompt(this.Types.HardwareAcceleration);
    }
    hasShown(type) {
      return this.state[type] === true;
    }
    setHasShown(type, value) {
      this.state[type] = value;
    }
    _showPrompt(type) {
      switch (type) {
        case this.Types.HardwareAcceleration:
          return this.promptHardwareAccelerationIfNeeded();
      }
    }
    async showPrompt(type, force = false) {
      if (this.hasShown(type) && !force) return;
      this.setHasShown(type, !!await Promise.resolve(this._showPrompt(type)));
    }
    promptHardwareAccelerationIfNeeded() {
      if (!App.getEnableHardwareAcceleration())
        return this.promptHardwareAcceleration();
    }
    promptHardwareAcceleration() {
      return new Promise(
        (resolve) => ModalActions.openModal((props) => /* @__PURE__ */ BdApi.React.createElement(
          Modal$2,
          {
            ...props,
            cancelText: "Cancel",
            confirmText: "Enable",
            confirmButtonVariant: "critical-primary",
            onCancel: () => resolve(true),
            onConfirm: () => {
              resolve(false);
              App.setEnableHardwareAcceleration(true);
            }
          },
          /* @__PURE__ */ BdApi.React.createElement(Heading, { variant: "heading-md/semibold", className: DiscordClasses.Margins.marginBottom8 }, "HARDWARE ACCELERATION IS DISABLED"),
          /* @__PURE__ */ BdApi.React.createElement(Text$1, { variant: "text-sm/normal" }, "The animations might be choppy, turn the Hardware Acceleration on to drastically improve the performance. Discord will quit and re-launch.")
        ))
      );
    }
  }();
  function patchReferencePositionLayer() {
    Patcher.after(ReferencePositionLayer?.prototype, "componentDidMount", (self2) => {
      queueMicrotask(
        () => self2.props.onPositionChange?.call(self2.props, self2.calculateState().position)
      );
    });
  }
  css`/* Force layers to respect their order inside DOM for overlapping */
${DiscordSelectors.Layer.layerContainer} > * {
    isolation: isolate;
}

/* Don't trap clicks while exit animation is playing on the layer */
${DiscordSelectors.Layer.clickTrapContainer}:has([data-baa-type="exit"]) {
    pointer-events: none !important;
}``ReferencePositionLayer`;
  function createPatcher() {
    let patchedPopout = null;
    return (self2, args, value) => {
      const popout = findInReactTree(value, (m) => m?.renderPopout);
      if (!popout) return;
      popout.align = Position.Center;
      TinyPatcher.after(popout, "renderPopout", (self3, args2, value2) => {
        if (!patchedPopout) {
          const { type: original } = value2;
          patchedPopout = (props) => {
            const value3 = original(props);
            const [v, setV] = require$$0$1.useState(0);
            require$$0$1.useLayoutEffect(() => setV(1), []);
            require$$0$1.useLayoutEffect(() => {
              if (v === 1) props.updatePosition();
            }, [v]);
            return value3;
          };
        }
        value2.type = patchedPopout;
      });
    };
  }
  function patchSelect() {
    const patcher = createPatcher();
    Patcher.after(...SelectKeyed, patcher);
    Patcher.after(...SingleSelectKeyed, (...[, , value]) => {
      TinyPatcher.after(value, "type", patcher);
    });
    Patcher.after(SearchableSelect, "render", createPatcher());
  }
  css`/* Fixes a bug where the measurement element may interfere with the select inner element positioning */
${DiscordSelectors.Select.measurement} {
    top: 0;
    left: 0;
}``Select`;
  function patchMenuItem() {
    Patcher.after(...MenuItemKeyed, (self2, [props], value) => {
      if (!value?.props?.onClick) return;
      TinyPatcher.before(value.props, "onClick", (self22, [event]) => {
        Object.defineProperty(event.nativeEvent, "view", {
          value: new Proxy(event.nativeEvent.view, {
            get(target, prop) {
              if (prop === "requestAnimationFrame") return (cb) => cb();
              return target[prop];
            }
          })
        });
      });
    });
  }
  function patchExpressionPicker() {
    let expressionPickerRendering = false;
    Patcher.before(...useExpressionPickerStoreKeyed, (self2, args) => {
      if (!expressionPickerRendering) return;
      args[0] = (state) => state.activeView ?? state.lastActiveView;
    });
    Patcher.instead(ModuleKey.Popouts, ExpressionPicker, "type", (self2, [props], original) => {
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.Popouts);
      if (!isMainWindow || !module2.isEnabled()) return original(props);
      expressionPickerRendering = true;
      let value;
      try {
        value = original(props);
      } finally {
        expressionPickerRendering = false;
      }
      const positionLayer = findInReactTree(value, byClassName("positionLayer"));
      if (!positionLayer) return value;
      positionLayer.props.onPositionChange = props.onPositionChange;
      TinyPatcher.after(ModuleKey.Popouts, positionLayer.props, "children", (self22, args, value2) => {
        const drawerSizingWrapper = findInReactTree(value2, byClassName("drawerSizingWrapper"));
        if (!drawerSizingWrapper) return;
        const { children: children2 } = drawerSizingWrapper.props;
        const contentWrapperIndex = children2.findIndex(byClassName("contentWrapper"));
        if (contentWrapperIndex === -1) return;
        children2[contentWrapperIndex] = /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: children2[contentWrapperIndex] }, /* @__PURE__ */ BdApi.React.createElement(
          AnimeContainer,
          {
            ref: props.__containerRef,
            id: ModuleKey.Popouts,
            container: { className: "BA__expressionPickerContainer" }
          },
          children2[contentWrapperIndex]
        ));
      });
      return value;
    });
  }
  css`.BA__expressionPickerContainer {
    height: 100%;
}``ExpressionPicker`;
  function patchAppLauncherPopup() {
    Patcher.after(ModuleKey.Popouts, AppLauncherPopup, "type", (self2, [props], value) => {
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.Popouts);
      if (!isMainWindow || !module2.isEnabled()) return;
      const positionLayer = findInReactTree(value, byClassName("positionLayer"));
      if (!positionLayer) return;
      positionLayer.props.ref = props.layerRef;
      positionLayer.props.onPositionChange = props.onPositionChange;
    });
  }
  function patchChannelAppLauncher() {
    Patcher.after(ModuleKey.Popouts, ChannelAppLauncher, "type", (self2, args, value) => {
      const layerRef = require$$0$1.useRef();
      const { autoRef, setPosition } = useAutoPosition(Position.Top, { align: Position.Right });
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.Popouts);
      if (!isMainWindow || !module2.isEnabled()) return;
      const wrapper = findInReactTree(value, (m) => Array.isArray(m?.children));
      if (!wrapper) return;
      const { children: children2 } = wrapper;
      const popupIndex = children2.length - 1;
      children2[popupIndex] = /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: children2[popupIndex] }, /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null }, children2[popupIndex] && /* @__PURE__ */ BdApi.React.createElement(
        AnimeTransition,
        {
          module: module2,
          layerRef,
          autoRef,
          anchor: children2[popupIndex].props?.positionTargetRef
        },
        require$$0$1.cloneElement(children2[popupIndex], {
          layerRef,
          onPositionChange: setPosition
        })
      )));
    });
    patchAppLauncherPopup();
  }
  function patchChannelTextAreaButtons() {
    Patcher.after(ModuleKey.Popouts, ChannelTextAreaButtons, "type", (self2, [{ buttonRefs }], value) => {
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.Popouts);
      if (!isMainWindow || !module2.isEnabled() || !buttonRefs) return;
      const buttons = findInReactTree(value, byClassName("buttons"));
      if (!buttons) return;
      for (const button of buttons.props.children) {
        if (!button.key) continue;
        button.props.ref = (el) => buttonRefs.current[button.key] = el;
      }
    });
  }
  function patchChannelTextArea() {
    Patcher.after(ModuleKey.Popouts, ChannelTextArea?.type, "render", (self2, args, value) => {
      const { autoRef, setPosition } = useAutoPosition(Position.Top, { align: Position.Right });
      const buttonRefs = require$$0$1.useRef({});
      const anchorRef = require$$0$1.useCallback(() => {
        const { activeView, lastActiveView } = unkeyed(useExpressionPickerStoreKeyed).getState();
        return buttonRefs.current[activeView ?? lastActiveView] ?? buttonRefs.current["emoji"];
      }, [buttonRefs]);
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.Popouts);
      if (!isMainWindow || !module2.isEnabled()) return;
      const buttons = findInReactTree(value, (m) => m?.type === ChannelTextAreaButtons);
      if (buttons) buttons.props.buttonRefs = buttonRefs;
      const wrapper = findInReactTree(value, (m) => Array.isArray(m?.children));
      if (!wrapper) return;
      const { children: children2 } = wrapper;
      const expressionPickerIndex = children2.length - 1;
      const injectContainerRef2 = (children22, ref) => {
        if (children22?.props) children22.props.__containerRef = ref;
      };
      children2[expressionPickerIndex] = /* @__PURE__ */ BdApi.React.createElement(ErrorBoundary, { module: module2, fallback: children2[expressionPickerIndex] }, /* @__PURE__ */ BdApi.React.createElement(TransitionGroup, { component: null }, children2[expressionPickerIndex] && /* @__PURE__ */ BdApi.React.createElement(
        AnimeTransition,
        {
          module: module2,
          injectContainerRef: injectContainerRef2,
          autoRef,
          anchor: anchorRef
        },
        require$$0$1.cloneElement(children2[expressionPickerIndex], {
          onPositionChange: setPosition
        })
      )));
    });
    patchChannelTextAreaButtons();
    patchExpressionPicker();
    patchChannelAppLauncher();
  }
  function patchPopToast() {
    Patcher.instead(...popToastKeyed, (self2, [key2, force], original) => {
      if (key2 === "APP" && force !== true && ErrorManager.isToastActive()) return;
      return original(key2);
    });
  }
  class WebSocketController {
    get name() {
      return "WebSocketController";
    }
    constructor() {
      this.queue = [];
      this.isPaused = false;
      this._messageHandler = null;
      this.interceptor = (message) => {
        this.queue.push(message);
      };
    }
    getOriginalMessageHandler() {
      const handler2 = GatewaySocket.webSocket?.onmessage;
      return handler2 === this.interceptor ? this._messageHandler : handler2;
    }
    setMessageHandler(handler2) {
      if (GatewaySocket.webSocket) GatewaySocket.webSocket.onmessage = handler2;
    }
    get messageHandler() {
      return this._messageHandler ?? this.getOriginalMessageHandler();
    }
    flushQueue() {
      if (!this.queue.length || !this.messageHandler) return;
      Logger.debug(this.name, `Flushing ${this.queue.length} message${this.queue.length > 1 ? "s" : ""}.`);
      Flux.Emitter.batched(() => {
        this.queue.forEach((message) => this.messageHandler(message));
        this.queue = [];
      });
    }
    pauseMessages() {
      if (this.isPaused || !GatewaySocket.webSocket) return;
      this._messageHandler = this.getOriginalMessageHandler();
      this.setMessageHandler(this.interceptor);
      this.isPaused = true;
      Logger.debug(this.name, "Messages paused.");
    }
    resumeMessages(flush = true) {
      if (!this.isPaused || !GatewaySocket.webSocket) return;
      this.setMessageHandler(this.messageHandler);
      this._messageHandler = null;
      this.isPaused = false;
      Logger.debug(this.name, "Messages resumed.");
      if (flush) this.flushQueue();
    }
  }
  const ignoredEvents = [
    "CHANNEL_SELECT",
    "UPDATE_CHANNEL_DIMENSIONS",
    "GUILD_HOME_SETTINGS_FETCH_START"
  ];
  const alwaysInterceptedEvents = [
    "GUILD_CREATE",
    "GUILD_MEMBER_LIST_UPDATE",
    "LOAD_MESSAGES_SUCCESS",
    "THREAD_LIST_SYNC"
  ];
  const connectedStores = [
    SelectedGuildStore,
    SelectedChannelStore,
    ChannelSectionStore,
    LayerStore$1
  ];
  class DispatchController {
    get name() {
      return "DispatchController";
    }
    get isEnabled() {
      return Config.current.general.prioritizeAnimationSmoothness;
    }
    constructor() {
      this.webSocketController = new WebSocketController();
      this.queue = [];
      this.isEmitterPaused = false;
      this._visibleEntities = this.getVisibleEntities();
      this._clearWatcher = null;
      this.interceptor = (event) => {
        if (!AnimationStore$1.shouldInterceptEvents || this.isEmitterPaused) return;
        if (!this.shouldIntercept(event)) return;
        Logger.debug(this.name, `Intercepted and queued ${event.type}.`);
        this.queue.push(event);
        return true;
      };
      this.onSettingsChange = () => {
        if (this.isEnabled) {
          this.registerInterceptor();
          Logger.log(this.name, "Enabled.");
        } else {
          this.clearInterceptor();
          this.webSocketController.resumeMessages(false);
          this.resumeEmitter();
          this.flush();
          Logger.log(this.name, "Disabled.");
        }
      };
      this.onConnectedStoreChange = () => {
        const visibleEntities = this.getVisibleEntities();
        if (!isEqual(visibleEntities, this._visibleEntities)) this.flush();
        this._visibleEntities = visibleEntities;
      };
    }
    _debugEvent(event) {
      Logger.debug(this.name, `Event fired:`, event);
      console.time(event.type);
      requestAnimationFrame(() => console.timeEnd(event.type));
    }
    getVisibleEntities() {
      if (LayerStore$1.hasLayers()) return { guildId: null, channelId: null, threadId: null };
      const guildId = SelectedGuildStore.getGuildId();
      const channelId = SelectedChannelStore.getChannelId(guildId);
      const threadId = ChannelSectionStore.getCurrentSidebarChannelId(channelId);
      return { guildId, channelId, threadId };
    }
    shouldIntercept(event) {
      if (ignoredEvents.includes(event.type)) return false;
      if (alwaysInterceptedEvents.includes(event.type)) return true;
      const { guildId, channelId, threadId } = this._visibleEntities;
      return typeof event.guildId === "string" && event.guildId !== guildId || typeof event.channelId === "string" && event.channelId !== channelId && event.channelId !== threadId;
    }
    flushQueue() {
      if (!this.queue.length) return;
      Logger.debug(this.name, `Flushing ${this.queue.length} event${this.queue.length > 1 ? "s" : ""}:`, this.queue);
      Flux.Emitter.batched(() => {
        this.queue.forEach((event) => Dispatcher.dispatch(event));
        this.queue = [];
      });
    }
    flush() {
      this.webSocketController.flushQueue();
      this.flushQueue();
    }
    registerInterceptor() {
      if (Dispatcher._interceptors.includes(this.interceptor)) return;
      Dispatcher._interceptors.unshift(this.interceptor);
    }
    clearInterceptor() {
      Dispatcher._interceptors = Dispatcher._interceptors.filter((i) => i !== this.interceptor);
    }
    pauseEmitter() {
      if (this.isEmitterPaused) return;
      this.isEmitterPaused = true;
      Logger.debug(this.name, "Emitter paused. Safely flushing queue...");
      this.flushQueue();
    }
    resumeEmitter() {
      if (!this.isEmitterPaused) return;
      this.isEmitterPaused = false;
      Logger.debug(this.name, "Emitter resumed. Emitting changes...");
      Flux.Emitter.emit();
    }
    registerWatcher() {
      this._clearWatcher = AnimationStore$1.watch(() => {
        if (this.isEnabled && AnimationStore$1.shouldPauseEmitter) {
          this.webSocketController.pauseMessages();
          this.pauseEmitter();
        } else {
          this.webSocketController.resumeMessages();
          this.resumeEmitter();
        }
        if (!AnimationStore$1.shouldInterceptEvents) this.flush();
      });
    }
    clearWatcher() {
      this._clearWatcher?.();
    }
    connectStores() {
      connectedStores.forEach(
        (store) => store.addChangeListener(this.onConnectedStoreChange)
      );
    }
    disconnectStores() {
      connectedStores.forEach(
        (store) => store.removeChangeListener(this.onConnectedStoreChange)
      );
    }
    initialize() {
      if (this.isEnabled) this.registerInterceptor();
      this.registerWatcher();
      this.connectStores();
      Emitter.on(Events.SettingsChanged, this.onSettingsChange);
      Logger.log(this.name, `Initialized${this.isEnabled ? " and enabled" : ""}.`);
    }
    shutdown() {
      this.clearInterceptor();
      this.clearWatcher();
      this.disconnectStores();
      Emitter.off(Events.SettingsChanged, this.onSettingsChange);
      this.webSocketController.resumeMessages(false);
      this.resumeEmitter();
      this.flush();
      Logger.log(this.name, "Shutdown.");
    }
  }
  const DispatchController$1 = new DispatchController();
  function getLazyLayerComponent(id) {
    if (!LayersComponent) return;
    try {
      const suspense = findInReactTree(
        LayersComponent.prototype.renderComponent(id),
        (m) => m?.type?.displayName?.startsWith("Suspense")
      );
      return suspense?.type()?.props?.children?.type;
    } catch (error2) {
      Logger.err("getLazyLayerComponent", error2);
    }
  }
  const LAYER_IDS = [
    "USER_SETTINGS",
    "CHANNEL_SETTINGS",
    "GUILD_SETTINGS",
    "COLLECTIBLES_SHOP"
  ];
  const LoadStatus = {
    IDLE: 0,
    PENDING: 1,
    FINISHED: 2
  };
  class LazyLoader {
    get name() {
      return "LazyLoader";
    }
    constructor() {
      this.active = false;
      this.layers = LAYER_IDS.map((id) => ({
        id,
        status: LoadStatus.IDLE
      }));
      this.iterate = () => {
        if (!this.active) return;
        if (this.isIdle()) {
          const done = this.iterateLayers();
          if (done) return Logger.log(this.name, "No modules in queue.");
        }
        requestIdleCallback(this.iterate);
      };
    }
    isIdle() {
      return !AnimationStore$1.animations.length;
    }
    iterateLayers() {
      if (!Config.current.general.preloadLayers) return true;
      const layer = this.layers.find((l) => l.status !== LoadStatus.FINISHED);
      if (!layer) return true;
      if (layer.status === LoadStatus.PENDING) return false;
      const component = getLazyLayerComponent(layer.id);
      if (!component || isLazyLoaded(component)) {
        if (!component) Logger.warn(this.name, `Unable to find component for layer "${layer.id}". Skipping...`);
        else Logger.log(this.name, `Layer "${layer.id}" is already loaded. Skipping...`);
        layer.status = LoadStatus.FINISHED;
      } else {
        Logger.log(this.name, `Loading layer "${layer.id}"...`);
        loadLazy(component).then(() => Logger.log(this.name, `Layer "${layer.id}" was loaded.`)).catch((err) => Logger.error(this.name, `Failed to load layer "${layer.id}":`, err)).finally(() => layer.status = LoadStatus.FINISHED);
      }
      return false;
    }
    initialize() {
      this.active = true;
      requestIdleCallback(this.iterate);
      Emitter.on(Events.SettingsChanged, this.iterate);
      Logger.info(this.name, "Initialized.");
    }
    shutdown() {
      this.active = false;
      Emitter.off(Events.SettingsChanged, this.iterate);
      Logger.info(this.name, "Shutdown.");
    }
  }
  const LazyLoader$1 = new LazyLoader();
  function isEmojiOverload(data2, priority, limit = 100) {
    let count = 0;
    for (let i = priority; i >= 1; i--) {
      count += data2[i];
      if (count > limit) return true;
    }
    return false;
  }
  function patchEmoji() {
    Patcher.after(...EmojiKeyed, (self2, [{ className, size }], value) => {
      const { config: config2 } = useConfig();
      const { isEnterActive, state, props, data: data2, tree } = require$$0$1.use(AnimeTransitionContext);
      const priority = require$$0$1.useMemo(() => size === "reaction" ? 2 : 1, [size]);
      require$$0$1.useEffect(() => {
        tree.forEach((t) => t.data.emoji[priority] += 1);
        return () => tree.forEach((t) => t.data.emoji[priority] -= 1);
      }, [priority]);
      if (config2.general.prioritizeAnimationSmoothness && isEnterActive && props?.mountOnEnter && (state === Transition.EXITED || isEmojiOverload(data2.emoji, priority))) return /* @__PURE__ */ BdApi.React.createElement(
        "div",
        {
          className: classNames("emoji", "BA__emojiPlaceholder", className, {
            jumboable: size === "jumbo"
          })
        }
      );
      return value;
    }, { category: InternalError.Category.PRIORITIZE_ANIMATION_SMOOTHNESS });
  }
  css`.BA__emojiPlaceholder {
    display: inline-block;
    border-radius: 12%;
    background-color: var(--background-mod-strong);
    flex-shrink: 0;
}``Emoji`;
  function patchProfileEffects() {
    Patcher.after(...ProfileEffectsKeyed, () => {
      const { config: config2 } = useConfig();
      const { isEnterActive } = require$$0$1.use(AnimeTransitionContext);
      if (config2.general.prioritizeAnimationSmoothness && isEnterActive) return null;
    }, { category: InternalError.Category.PRIORITIZE_ANIMATION_SMOOTHNESS });
  }
  function patchUseIsVisible() {
    Patcher.instead(...useIsVisibleKeyed, (self2, [callback, ...args], original) => {
      const { config: config2 } = useConfig();
      const isEnabled = config2.general.prioritizeAnimationSmoothness;
      const unwatch = require$$0$1.useRef();
      const onUpdate = require$$0$1.useCallback((isIntersecting) => {
        unwatch.current?.();
        if (AnimationStore$1.isSafe) callback(isIntersecting);
        else unwatch.current = AnimationStore$1.onceSafe(() => callback(isIntersecting));
      }, [callback]);
      require$$0$1.useEffect(() => () => unwatch.current?.(), []);
      return original(isEnabled ? onUpdate : callback, ...args);
    }, { category: InternalError.Category.PRIORITIZE_ANIMATION_SMOOTHNESS });
  }
  async function patchGenerateUserSettingsSections() {
    const cached = {
      params: null,
      value: null
    };
    Patcher.instead(...await generateUserSettingsSectionsKeyed, (self2, [params], original) => {
      if (!Config.current.general.cacheUserSettingsSections) return original(params);
      if (!cached.params || Object.keys(params).some((k) => params[k] !== cached.params[k])) {
        cached.params = params;
        cached.value = original(params);
      }
      return cached.value;
    }, { category: InternalError.Category.CACHE_USER_SETTINGS_SECTIONS });
  }
  function patchEmitter() {
    Patcher.instead(Flux.Emitter, "emit", (self2, args, original) => {
      if (DispatchController$1.isEmitterPaused) return;
      return original.apply(self2, args);
    });
  }
  function applyOptimizationPatches() {
    patchEmoji();
    patchProfileEffects();
    patchUseIsVisible();
    patchGenerateUserSettingsSections();
    patchEmitter();
  }
  function patchRootElementContext() {
    Patcher.after(...useRootElementContextKeyed, (self2, args, value) => {
      return {
        ...value,
        className: classNames(
          value.className,
          Core.getAllModules(true).filter((m) => {
            switch (m.id) {
              case ModuleKey.ThreadSidebar:
                return m.isEnabled() || Core.getModule(ModuleKey.ThreadSidebarSwitch).isEnabled();
              default:
                return m.isEnabled();
            }
          }).map((m) => `BA__module_${m.id}`)
        )
      };
    });
  }
  function patchBasePopover() {
    Patcher.after(ModuleKey.Popouts, ...BasePopoverKeyed, (self2, [{ shouldShow: shouldShow2 = true }], value) => {
      const { isMainWindow } = useWindow();
      const module2 = useModule(ModuleKey.Popouts);
      if (!isMainWindow || !module2.isEnabled()) return;
      value.props.shouldShow = shouldShow2;
      TinyPatcher.after(value.props, "renderPopout", (self22, args, value2) => {
        const animated = findInReactTree(value2, (m) => m?.type?.displayName?.startsWith("Animated"));
        if (!animated) return;
        delete animated.props.style;
        animated.type = "div";
      });
    });
  }
  const changelog = {
    "2.0.0": { "banner": "https://github.com/arg0NNY/BetterAnimations/raw/refs/heads/main/assets/V2.webp", "blurb": "Larger, faster, and rebuilt from the ground up. **BetterAnimations 2.0** is here, transforming your Discord experience with a new generation of silky-smooth, deeply integrated animations.", "changes": [{ "type": "added", "title": "What's New in 2.0", "items": ["🎭 **Expanded Animation Library** — experience motion across Discord like never before. This release introduces 10 new animation modules, bringing the total to 14. Animate everything from Servers and Messages to the Thread Sidebar and Modals.", "⚙️ **Native-Level Integration** — animations are now woven directly into Discord's core UI. This creates a more reliable, rigid, and natural-feeling experience that truly belongs.", "🚀 **Unmatched Performance** — enjoy buttery-smooth animations that make Discord feel snappier and more responsive than ever.", "🎨 **Ultimate Customization** — take full control with a completely redesigned Settings Panel. Fine-tune every detail of your animations or craft entirely new ones from scratch.", "🌐 **Client Mod & Framework** — expand your library with community-made animations or build and share your own through the official Catalog."] }] },
    "2.0.1": { "changes": [{ "type": "added", "title": "What's new", "items": ["Enhance layout: Added alert when conflict with the custom theme is detected."] }, { "type": "fixed", "title": "Fixes", "items": ["General Settings: Updated to work in the latest release of Discord."] }] },
    "2.0.2": { "changes": [{ "type": "fixed", "title": "Fixes", "items": ["Fixed the plugin failing to load."] }] }
  };
  function parseVersion(version2) {
    const data2 = version2.match(regex.semver);
    if (!data2) return null;
    const [, major, minor, patch2, id] = data2;
    return { major, minor, patch: patch2, id };
  }
  class Changelog {
    get name() {
      return "Changelog";
    }
    constructor() {
      this.onPackLoaded = (pack) => this.showPackModalIfNeeded(pack);
    }
    get data() {
      return data.currentVersionInfo;
    }
    set data(value) {
      data.currentVersionInfo = value;
    }
    initialize() {
      this.showPluginModalIfNeeded();
      Emitter.on(Events.PackLoaded, this.onPackLoaded);
      Logger.log(this.name, "Initialized.");
    }
    shutdown() {
      Emitter.off(Events.PackLoaded, this.onPackLoaded);
      Logger.log(this.name, "Shutdown.");
    }
    showModal({ title, version: version2, subtitle, footer, ...props }) {
      return UI.showChangelogModal({
        ...props,
        title: /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__changelogModalHeader" }, /* @__PURE__ */ BdApi.React.createElement(
          Tooltip$1,
          {
            text: meta$1.name,
            shouldShow: !!title,
            position: "bottom",
            align: "left"
          },
          (props2) => /* @__PURE__ */ BdApi.React.createElement(
            IconBrand,
            {
              ...props2,
              size: "custom",
              width: 36,
              height: 36
            }
          )
        ), /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__changelogModalHeaderInfo" }, /* @__PURE__ */ BdApi.React.createElement("span", null, title ?? meta$1.name, " "), version2 && /* @__PURE__ */ BdApi.React.createElement(
          Text$1,
          {
            tag: "span",
            variant: "text-sm/semibold",
            color: "text-muted"
          },
          "v",
          version2
        ))),
        footer: footer && /* @__PURE__ */ BdApi.React.createElement("div", { className: "BA__changelogModalFooter" }, footer)
      });
    }
    showPluginModal(version2, props = changelog[version2]) {
      if (!props) return;
      return this.showModal({
        ...props,
        version: version2,
        footer: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(SocialLinks, null), /* @__PURE__ */ BdApi.React.createElement(
          Button$1,
          {
            size: "sm",
            icon: ArrowSmallRightIcon,
            iconPosition: "end",
            text: "Go to Settings",
            onClick: () => {
              ModalActions.closeAllModals();
              Settings.openSettingsModal();
            }
          }
        ))
      });
    }
    showPluginMajorModalIfNeeded() {
      const [a, b] = [this.data.version, version$1].map(parseVersion);
      if (a && b && a.major !== b.major && [b.minor, b.patch].some((i) => i !== "0")) this.showPluginModal(`${b.major}.0.0`);
    }
    showPluginModalIfNeeded() {
      if (this.data.version === version$1 && this.data.hasShownChangelog) return;
      this.showPluginModal(version$1);
      this.showPluginMajorModalIfNeeded();
      this.data = { version: version$1, hasShownChangelog: true };
    }
    showPackModal(pack) {
      if (!pack.changelog) return;
      const showPackModal = () => ModalActions.openModal((props) => /* @__PURE__ */ BdApi.React.createElement(
        PackModal,
        {
          ...props,
          filename: pack.filename,
          location: PackContentLocation.LIBRARY
        }
      ));
      try {
        return this.showModal({
          banner: PackRegistry.getThumbnailSrc(pack),
          ...pack.changelog,
          title: pack.name,
          version: pack.version,
          footer: /* @__PURE__ */ BdApi.React.createElement(BdApi.React.Fragment, null, /* @__PURE__ */ BdApi.React.createElement(PackMeta$1, { pack }), /* @__PURE__ */ BdApi.React.createElement(
            Button$1,
            {
              size: "sm",
              icon: ArrowSmallRightIcon,
              iconPosition: "end",
              text: "View",
              onClick: showPackModal
            }
          ))
        });
      } catch (error2) {
        Logger.error(this.name, `Failed to show changelog modal for pack ${pack.name}:`, error2);
      }
    }
    showPackModalIfNeeded(pack) {
      if (pack.partial) return;
      const data2 = PackData$1.pack(pack.slug);
      if (data2.currentVersion === pack.version) return;
      if (data2.currentVersion) this.showPackModal(pack);
      data2.currentVersion = pack.version;
    }
  }
  const Changelog$1 = new Changelog();
  css`.BA__changelogModalHeader {
    display: flex;
    align-items: center;
    gap: 4px;
}
.BA__changelogModalFooter {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
}``Changelog`;
  function index(meta2) {
    saveMeta(meta2);
    return {
      start() {
        Logger.info("Startup", "Initializing modules...");
        ErrorManager.initialize();
        PackData$1.initialize();
        Config.initialize();
        Mouse$1.initialize();
        style.initialize();
        Changelog$1.initialize();
        PackRegistry.initialize();
        PackManager.initialize();
        AnimationStore$1.initialize();
        Core.initialize();
        DispatchController$1.initialize();
        LazyLoader$1.initialize();
        Validator$1.onStartup();
        Prompt.onStartup();
        Logger.info("Startup", "Applying patches...");
        patchAppView();
        patchContextMenu();
        patchMenuItem();
        patchBasePopout();
        patchBasePopover();
        patchTooltip();
        patchChannelMessageList();
        patchChannelView();
        patchStandardSidebarView();
        patchModals();
        patchLayers();
        patchListThin();
        patchGuildChannelList();
        patchReferencePositionLayer();
        patchSelect();
        patchChannelTextArea();
        patchPopToast();
        patchRootElementContext();
        applyOptimizationPatches();
        Logger.info("Startup", "Forcing app update...");
        forceAppUpdate();
        Logger.info("Startup", "Finished.");
      },
      stop() {
        Emitter.emit(Events.PluginDisabled);
        Logger.info("Shutdown", "Shutting down modules...");
        Core.shutdown();
        Mouse$1.shutdown();
        style.shutdown();
        Config.shutdown();
        PackData$1.shutdown();
        ErrorManager.shutdown();
        Changelog$1.shutdown();
        PackRegistry.shutdown();
        PackManager.shutdown();
        AnimationStore$1.shutdown();
        DispatchController$1.shutdown();
        LazyLoader$1.shutdown();
        Settings.closeSettingsModal();
        Logger.info("Shutdown", "Removing patches...");
        Patcher.unpatchAll();
        Logger.info("Shutdown", "Forcing app update...");
        forceAppUpdate();
        Logger.info("Shutdown", "Finished.");
      },
      getSettingsPanel() {
        queueMicrotask(() => {
          ModalActions.closeAllModals();
          Settings.openSettingsModal();
        });
      }
    };
  }
  css`#app-mount {
    overflow: clip;
}``General`;
  return index;
}(BdApi.React, require("events"), BdApi.Utils.className, require("fs"), require("path"), BdApi.ReactDOM);
